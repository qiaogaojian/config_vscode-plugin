[
{
"title":"Articulations",
"snippets":[
{
"title":"Articulation",
"snippets":[
{
"title":"import ...",
"description":"Import class",
"snippet":"from omni.isaac.core.articulations import Articulation\n",
"category":"import"
},
{
"title":"Articulation",
"description":"High level wrapper to deal with an articulation prim (only one articulation prim) and its attributes/properties.\n\n*Warning:*\nThe articulation object must be initialized in order to be able to operate on it.\nSee the `initialize` method for more details.\n\n**Args:**\n\n * `prim_path` (str): prim path of the Prim to encapsulate or create.\n * `name` (str, optional): shortname to be used as a key by Scene class. Note: needs to be unique if the object is added to the Scene. Defaults to \"articulation\".\n * `position` (Optional\\[Sequence\\[float\\]\\], optional): position in the world frame of the prim. Shape is (3, ). Defaults to None, which means left unchanged.\n * `translation` (Optional\\[Sequence\\[float\\]\\], optional): translation in the local frame of the prim (with respect to its parent prim). Shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the world/ local frame of the prim (depends if translation or position is specified). quaternion is scalar-first (w, x, y, z). Shape is (4, ). Defaults to None, which means left unchanged.\n * `scale` (Optional\\[Sequence\\[float\\]\\], optional): local scale to be applied to the prim's dimensions. Shape is (3, ). Defaults to None, which means left unchanged.\n * `visible` (bool, optional): set to false for an invisible prim in the stage while rendering. Defaults to True.\n * `articulation_controller` (Optional\\[ArticulationController\\], optional): a custom ArticulationController which inherits from it. Defaults to creating the basic ArticulationController.\n * `enable_dof_force_sensors` (bool, optional): enables the solver computed dof force sensors on articulation joints. Defaults to False.\n\n---\n**Example:**\n\n```python\n>>> import omni.isaac.core.utils.stage as stage_utils\n>>> from omni.isaac.core.articulations import Articulation\n>>>\n>>> usd_path = \"/home/<user>/Documents/Assets/Robots/Franka/franka_alt_fingers.usd\"\n>>> prim_path = \"/World/envs/env_0/panda\"\n>>>\n>>> # load the Franka Panda robot USD file\n>>> stage_utils.add_reference_to_stage(usd_path, prim_path)\n>>>\n>>> # wrap the prim as an articulation\n>>> prim = Articulation(prim_path=prim_path, name=\"franka_panda\")\n>>> prim\n<omni.isaac.core.articulations.articulation.Articulation object at 0x7fdd165bf520>\n```\n",
"snippet":"articulation = Articulation(prim_path=prim_path)\n",
"category":"class"
},
{
"title":"apply_action",
"description":"Apply joint positions, velocities and/or efforts to control an articulation\n\n**Args:**\n\n * `control_actions` (ArticulationAction): actions to be applied for next physics step.\n * `indices` (Optional\\[Union\\[list, np.ndarray\\]\\], optional): degree of freedom indices to apply actions to. Defaults to all degrees of freedom.\n\n*Hint:*\nHigh stiffness makes the joints snap faster and harder to the desired target,\nand higher damping smoothes but also slows down the joint's movement to target\n\n * For position control, set relatively high stiffness and low damping (to reduce vibrations)\n * For velocity control, stiffness must be set to zero with a non-zero damping\n * For effort control, stiffness and damping must be set to zero\n\n---\n**Example:**\n\n```python\n>>> from omni.isaac.core.utils.types import ArticulationAction\n>>>\n>>> # move all the robot joints to the indicated position\n>>> action = ArticulationAction(joint_positions=np.array([0.0, -1.0, 0.0, -2.2, 0.0, 2.4, 0.8, 0.04, 0.04]))\n>>> prim.apply_action(action)\n>>>\n>>> # close the robot fingers: panda_finger_joint1 (7) and panda_finger_joint2 (8) to 0.0\n>>> action = ArticulationAction(joint_positions=np.array([0.0, 0.0]), joint_indices=np.array([7, 8]))\n>>> prim.apply_action(action)\n```\n",
"snippet":"articulation.apply_action(control_actions=control_actions)\n",
"category":"method"
},
{
"title":"apply_visual_material",
"description":"Apply visual material to the held prim and optionally its descendants.\n\n**Args:**\n\n * `visual_material` (VisualMaterial): visual material to be applied to the held prim. Currently supports PreviewSurface, OmniPBR and OmniGlass.\n * `weaker_than_descendants` (bool, optional): True if the material shouldn't override the descendants materials, otherwise False. Defaults to False.\n\n---\n**Example:**\n\n```python\n>>> from omni.isaac.core.materials import OmniGlass\n>>>\n>>> # create a dark-red glass visual material\n>>> material = OmniGlass(\n...     prim_path=\"/World/material/glass\",  # path to the material prim to create\n...     ior=1.25,\n...     depth=0.001,\n...     thin_walled=False,\n...     color=np.array([0.5, 0.0, 0.0])\n... )\n>>> prim.apply_visual_material(material)\n```\n",
"snippet":"articulation.apply_visual_material(visual_material=visual_material)\n",
"category":"method"
},
{
"title":"articulation_handle",
"description":"A handler to the articulation\n\nThe handler is a unique identifier used by the Dynamic Control extension to manage the articulation\n\n**Returns:**\n\n * int: handle\n\n---\n**Example:**\n\n```python\n>>> prim.articulation_handle\n1116691496961\n```\n",
"snippet":"articulation_handle = articulation.articulation_handle\n",
"category":"property"
},
{
"title":"disable_gravity",
"description":"Keep gravity from affecting the robot\n\n---\n**Example:**\n\n```python\n>>> prim.disable_gravity()\n```\n",
"snippet":"articulation.disable_gravity()\n",
"category":"method"
},
{
"title":"dof_names",
"description":"List of prim names for each DOF.\n\n**Returns:**\n\n * list(string): prim names\n\n---\n**Example:**\n\n```python\n>>> prim.dof_names\n['panda_joint1', 'panda_joint2', 'panda_joint3', 'panda_joint4', 'panda_joint5',\n 'panda_joint6', 'panda_joint7', 'panda_finger_joint1', 'panda_finger_joint2']\n```\n",
"snippet":"dof_names = articulation.dof_names\n",
"category":"property"
},
{
"title":"dof_properties",
"description":"Articulation DOF properties\n\n| Index | Property name | Description                                                                |\n|-------|---------------|----------------------------------------------------------------------------|\n| 0     | `type`        | DOF type: invalid/unknown/uninitialized (0), rotation (1), translation (2) |\n| 1     | `hasLimits`   | Whether the DOF has limits                                                 |\n| 2     | `lower`       | Lower DOF limit (in radians or meters)                                     |\n| 3     | `upper`       | Upper DOF limit (in radians or meters)                                     |\n| 4     | `driveMode`   | Drive mode for the DOF: force (1), acceleration (2)                        |\n| 5     | `maxVelocity` | Maximum DOF velocity. In radians/s, or stage\\_units/s                      |\n| 6     | `maxEffort`   | Maximum DOF effort. In N or N\\*stage\\_units                                |\n| 7     | `stiffness`   | DOF stiffness                                                              |\n| 8     | `damping`     | DOF damping                                                                |\n\n**Returns:**\n\n * np.ndarray: named NumPy array of shape (num\\_dof, 9)\n\n---\n**Example:**\n\n```python\n>>> # get properties for all DOFs\n>>> prim.dof_properties\n[(1,  True, -2.8973,  2.8973, 1, 1.0000000e+01, 5220., 60000., 3000.)\n (1,  True, -1.7628,  1.7628, 1, 1.0000000e+01, 5220., 60000., 3000.)\n (1,  True, -2.8973,  2.8973, 1, 5.9390470e+36, 5220., 60000., 3000.)\n (1,  True, -3.0718, -0.0698, 1, 5.9390470e+36, 5220., 60000., 3000.)\n (1,  True, -2.8973,  2.8973, 1, 5.9390470e+36,  720., 25000., 3000.)\n (1,  True, -0.0175,  3.7525, 1, 5.9390470e+36,  720., 15000., 3000.)\n (1,  True, -2.8973,  2.8973, 1, 1.0000000e+01,  720.,  5000., 3000.)\n (2,  True,  0.    ,  0.04  , 1, 3.4028235e+38,  720.,  6000., 1000.)\n (2,  True,  0.    ,  0.04  , 1, 3.4028235e+38,  720.,  6000., 1000.)]\n>>>\n>>> # property names\n>>> prim.dof_properties.dtype.names\n('type', 'hasLimits', 'lower', 'upper', 'driveMode', 'maxVelocity', 'maxEffort', 'stiffness', 'damping')\n>>>\n>>> # get DOF upper limits\n>>> prim.dof_properties[\"upper\"]\n[ 2.8973  1.7628  2.8973 -0.0698  2.8973  3.7525  2.8973  0.04    0.04  ]\n>>>\n>>> # get the last DOF (panda_finger_joint2) upper limit\n>>> prim.dof_properties[\"upper\"][8]  # or prim.dof_properties[8][3]\n0.04\n```\n",
"snippet":"dof_properties = articulation.dof_properties\n",
"category":"property"
},
{
"title":"enable_gravity",
"description":"Gravity will affect the robot\n\n---\n**Example:**\n\n```python\n>>> prim.enable_gravity()\n```\n",
"snippet":"articulation.enable_gravity()\n",
"category":"method"
},
{
"title":"get_angular_velocity",
"description":"Get the angular velocity of the root articulation prim\n\n**Returns:**\n\n * np.ndarray: 3D angular velocity vector. Shape (3,)\n\n---\n**Example:**\n\n```python\n>>> prim.get_angular_velocity()\n[0. 0. 0.]\n```\n",
"snippet":"angular_velocity = articulation.get_angular_velocity()\n",
"category":"method"
},
{
"title":"get_applied_action",
"description":"Get the last applied action\n\n**Returns:**\n\n * ArticulationAction: last applied action. Note: a dictionary is used as the object's string representation\n\n---\n**Example:**\n\n```python\n>>> # last applied action: joint_positions -> [0.0, -1.0, 0.0, -2.2, 0.0, 2.4, 0.8, 0.04, 0.04]\n>>> prim.get_applied_action()\n{'joint_positions': [0.0, -1.0, 0.0, -2.200000047683716, 0.0, 2.4000000953674316, 0.800000011920929, 0.03999999910593033, 0.03999999910593033],\n 'joint_velocities': [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n 'joint_efforts': [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]}\n```\n",
"snippet":"applied_action = articulation.get_applied_action()\n",
"category":"method"
},
{
"title":"get_applied_joint_efforts",
"description":"Get the efforts applied to the joints set by the `set_joint_efforts` method\n\n**Args:**\n\n * `joint_indices` (Optional\\[Union\\[List, np.ndarray\\]\\], optional): indices to specify which joints to read. Defaults to None (all joints)\n\n**Raises:**\n\n * Exception: If the handlers are not initialized\n\n**Returns:**\n\n * np.ndarray: all or selected articulation joint applied efforts\n\n---\n**Example:**\n\n```python\n>>> # get all applied joint efforts\n>>> prim.get_applied_joint_efforts()\n[ 0.  0.  0.  0.  0.  0.  0.  0.  0.]\n>>>\n>>> # get finger applied efforts: panda_finger_joint1 (7) and panda_finger_joint2 (8)\n>>> prim.get_applied_joint_efforts(joint_indices=np.array([7, 8]))\n[0.  0.]\n```\n",
"snippet":"applied_joint_efforts = articulation.get_applied_joint_efforts()\n",
"category":"method"
},
{
"title":"get_applied_visual_material",
"description":"Return the current applied visual material in case it was applied using apply\\_visual\\_material\nor it's one of the following materials that was already applied before: PreviewSurface, OmniPBR and OmniGlass.\n\n**Returns:**\n\n * VisualMaterial: the current applied visual material if its type is currently supported.\n\n---\n**Example:**\n\n```python\n>>> # given a visual material applied\n>>> prim.get_applied_visual_material()\n<omni.isaac.core.materials.omni_glass.OmniGlass object at 0x7f36263106a0>\n```\n",
"snippet":"applied_visual_material = articulation.get_applied_visual_material()\n",
"category":"method"
},
{
"title":"get_articulation_body_count",
"description":"Get the number of bodies (links) that make up the articulation\n\n**Returns:**\n\n * int: amount of bodies\n\n---\n**Example:**\n\n```python\n>>> prim.get_articulation_body_count()\n12\n```\n",
"snippet":"articulation_body_count = articulation.get_articulation_body_count()\n",
"category":"method"
},
{
"title":"get_articulation_controller",
"description":"Get the articulation controller\n\n*Note:*\nIf no `articulation_controller` was passed during class instantiation, a default controller\nof type `ArticulationController` (a Proportional-Derivative controller that can apply position targets,\nvelocity targets and efforts) will be used\n\n**Returns:**\n\n * ArticulationController: articulation controller\n\n---\n**Example:**\n\n```python\n>>> prim.get_articulation_controller()\n<omni.isaac.core.controllers.articulation_controller.ArticulationController object at 0x7f04a0060190>\n```\n",
"snippet":"articulation_controller = articulation.get_articulation_controller()\n",
"category":"method"
},
{
"title":"get_default_state",
"description":"Get the default prim states (spatial position and orientation).\n\n**Returns:**\n\n * XFormPrimState: an object that contains the default state of the prim (position and orientation)\n\n---\n**Example:**\n\n```python\n>>> state = prim.get_default_state()\n>>> state\n<omni.isaac.core.utils.types.XFormPrimState object at 0x7f33addda650>\n>>>\n>>> state.position\n[-4.5299529e-08 -1.8347054e-09 -2.8610229e-08]\n>>> state.orientation\n[1. 0. 0. 0.]\n```\n",
"snippet":"default_state = articulation.get_default_state()\n",
"category":"method"
},
{
"title":"get_dof_index",
"description":"Get a DOF index given its name\n\n**Args:**\n\n * `dof_name` (str): name of the DOF\n\n**Returns:**\n\n * int: DOF index\n\n---\n**Example:**\n\n```python\n>>> prim.get_dof_index(\"panda_finger_joint2\")\n8\n```\n",
"snippet":"dof_index = articulation.get_dof_index(dof_name=dof_name)\n",
"category":"method"
},
{
"title":"get_enabled_self_collisions",
"description":"Get the enable self collisions flag (`physxArticulation:enabledSelfCollisions`)\n\n**Returns:**\n\n * int: self collisions flag (boolean interpreted as int)\n\n---\n**Example:**\n\n```python\n>>> prim.get_enabled_self_collisions()\n0\n```\n",
"snippet":"enabled_self_collisions = articulation.get_enabled_self_collisions()\n",
"category":"method"
},
{
"title":"get_joint_positions",
"description":"Get the articulation joint positions\n\n**Args:**\n\n * `joint_indices` (Optional\\[Union\\[List, np.ndarray\\]\\], optional): indices to specify which joints to read. Defaults to None (all joints)\n\n**Returns:**\n\n * np.ndarray: all or selected articulation joint positions\n\n---\n**Example:**\n\n```python\n>>> # get all joint positions\n>>> prim.get_joint_positions()\n[ 1.1999920e-02 -5.6962633e-01  1.3480479e-08 -2.8105433e+00  6.8284894e-06\n  3.0301569e+00  7.3234749e-01  3.9912373e-02  3.9999999e-02]\n>>>\n>>> # get finger positions: panda_finger_joint1 (7) and panda_finger_joint2 (8)\n>>> prim.get_joint_positions(joint_indices=np.array([7, 8]))\n[0.03991237  3.9999999e-02]\n```\n",
"snippet":"joint_positions = articulation.get_joint_positions()\n",
"category":"method"
},
{
"title":"get_joint_velocities",
"description":"Get the articulation joint velocities\n\n**Args:**\n\n * `joint_indices` (Optional\\[Union\\[List, np.ndarray\\]\\], optional): indices to specify which joints to read. Defaults to None (all joints)\n\n**Returns:**\n\n * np.ndarray: all or selected articulation joint velocities\n\n---\n**Example:**\n\n```python\n>>> # get all joint velocities\n>>> prim.get_joint_velocities()\n[ 1.91603772e-06 -7.67638255e-03 -2.19138826e-07  1.10636465e-02 -4.63412944e-05\n  3.48245539e-02  8.84692147e-02  5.40335372e-04 1.02849208e-05]\n>>>\n>>> # get finger velocities: panda_finger_joint1 (7) and panda_finger_joint2 (8)\n>>> prim.get_joint_velocities(joint_indices=np.array([7, 8]))\n[5.4033537e-04 1.0284921e-05]\n```\n",
"snippet":"joint_velocities = articulation.get_joint_velocities()\n",
"category":"method"
},
{
"title":"get_joints_default_state",
"description":"Get the default joint states (positions and velocities).\n\n**Returns:**\n\n * JointsState: an object that contains the default joint positions and velocities\n\n---\n**Example:**\n\n```python\n>>> state = prim.get_joints_default_state()\n>>> state\n<omni.isaac.core.utils.types.JointsState object at 0x7f04a0061240>\n>>>\n>>> state.positions\n[ 0.012  -0.57000005  0.  -2.81  0.  3.037  0.785398  0.04  0.04 ]\n>>> state.velocities\n[0. 0. 0. 0. 0. 0. 0. 0. 0.]\n```\n",
"snippet":"joints_default_state = articulation.get_joints_default_state()\n",
"category":"method"
},
{
"title":"get_joints_state",
"description":"Get the current joint states (positions and velocities)\n\n**Returns:**\n\n * JointsState: an object that contains the current joint positions and velocities\n\n---\n**Example:**\n\n```python\n>>> state = prim.get_joints_state()\n>>> state\n<omni.isaac.core.utils.types.JointsState object at 0x7f02f6df57b0>\n>>>\n>>> state.positions\n[ 1.1999920e-02 -5.6962633e-01  1.3480479e-08 -2.8105433e+00 6.8284894e-06\n  3.0301569e+00  7.3234749e-01  3.9912373e-02  3.9999999e-02]\n>>> state.velocities\n[ 1.91603772e-06 -7.67638255e-03 -2.19138826e-07  1.10636465e-02 -4.63412944e-05\n  245539e-02  8.84692147e-02  5.40335372e-04  1.02849208e-05]\n```\n",
"snippet":"joints_state = articulation.get_joints_state()\n",
"category":"method"
},
{
"title":"get_linear_velocity",
"description":"Get the linear velocity of the root articulation prim\n\n**Returns:**\n\n * np.ndarray: 3D linear velocity vector. Shape (3,)\n\n---\n**Example:**\n\n```python\n>>> prim.get_linear_velocity()\n[0. 0. 0.]\n```\n",
"snippet":"linear_velocity = articulation.get_linear_velocity()\n",
"category":"method"
},
{
"title":"get_local_pose",
"description":"Get prim's pose with respect to the local frame (the prim's parent frame)\n\n**Returns:**\n\n * Tuple\\[np.ndarray, np.ndarray\\]: first index is the position in the local frame (with shape (3, )).\n    Second index is quaternion orientation (with shape (4, )) in the local frame\n\n---\n**Example:**\n\n```python\n>>> # if the prim is in position (1.0, 0.5, 0.0) with respect to the world frame\n>>> position, orientation = prim.get_local_pose()\n>>> position\n[0. 0. 0.]\n>>> orientation\n[0. 0. 0.]\n```\n",
"snippet":"local_pose = articulation.get_local_pose()\n",
"category":"method"
},
{
"title":"get_local_scale",
"description":"Get prim's scale with respect to the local frame (the parent's frame)\n\n**Returns:**\n\n * np.ndarray: scale applied to the prim's dimensions in the local frame. shape is (3, ).\n\n---\n**Example:**\n\n```python\n>>> prim.get_local_scale()\n[1. 1. 1.]\n```\n",
"snippet":"local_scale = articulation.get_local_scale()\n",
"category":"method"
},
{
"title":"get_measured_joint_efforts",
"description":"Returns the efforts computed/measured by the physics solver of the joint forces in the DOF motion direction\n\n**Args:**\n\n * `joint_indices` (Optional\\[Union\\[List, np.ndarray\\]\\], optional): indices to specify which joints to read. Defaults to None (all joints)\n\n**Raises:**\n\n * Exception: If the handlers are not initialized\n\n**Returns:**\n\n * np.ndarray: all or selected articulation joint measured efforts\n\n---\n**Example:**\n\n```python\n>>> # get all joint efforts\n>>> prim.get_measured_joint_efforts()\n[ 2.7897308e-06 -6.9083519e+00 -3.6398471e-06  1.9158335e+01 -4.3552645e-06\n  1.1866090e+00 -4.7079347e-06  3.2339853e-04 -3.2044132e-04]\n>>>\n>>> # get finger efforts: panda_finger_joint1 (7) and panda_finger_joint2 (8)\n>>> prim.get_measured_joint_efforts(joint_indices=np.array([7, 8]))\n[ 0.0003234  -0.00032044]\n```\n",
"snippet":"measured_joint_efforts = articulation.get_measured_joint_efforts()\n",
"category":"method"
},
{
"title":"get_measured_joint_forces",
"description":"Get the measured joint reaction forces and torques (link incoming joint forces and torques) to external loads\n\n*Note:*\nSince the *name-\\>index* map for joints has not been exposed yet,\nit is possible to access the joint names and their indices through the articulation metadata.\n\n> ```python\n> ```\n>\n> prim.\\_articulation\\_view.\\_metadata.joint\\_names \\# list of names prim.\\_articulation\\_view.\\_metadata.joint\\_indices \\# dict of name: index\n>\n> To retrieve a specific row for the link incoming joint force/torque use `joint_index + 1`\n\n**Args:**\n\n * `joint_indices` (Optional\\[Union\\[List, np.ndarray\\]\\], optional): indices to specify which joints to read. Defaults to None (all joints)\n\n**Raises:**\n\n * Exception: If the handlers are not initialized\n\n**Returns:**\n\n * np.ndarray: measured joint forces and torques. Shape is (num\\_joint + 1, 6). Row index 0 is the incoming\n    joint of the base link. For the last dimension the first 3 values are for forces and the last 3 for torques\n\n---\n**Example:**\n\n```python\n>>> # get all measured joint forces and torques\n>>> prim.get_measured_joint_forces()\n[[ 0.0000000e+00  0.0000000e+00  0.0000000e+00  0.0000000e+00  0.0000000e+00  0.0000000e+00]\n [ 1.4995076e+02  4.2574748e-06  5.6364370e-04  4.8701895e-05 -6.9072924e+00  3.1881387e-05]\n [-2.8971717e-05 -1.0677823e+02 -6.8384506e+01 -6.9072924e+00 -5.4927128e-05  6.1222494e-07]\n [ 8.7120995e+01 -4.3871860e-05 -5.5795174e+01  5.3687054e-05 -2.4538563e+01  1.3333466e-05]\n [ 5.3519474e-05 -4.8109909e+01  6.0709282e+01  1.9157074e+01 -5.9258469e-05  8.2744418e-07]\n [-3.1691040e+01  2.3313689e-04  3.9990173e+01 -5.8968733e-05 -1.1863431e+00  2.2335558e-05]\n [-1.0809851e-04  1.5340537e+01 -1.5458489e+01  1.1863426e+00  6.1094368e-05 -1.5940281e-05]\n [-7.5418940e+00 -5.0814648e+00 -5.6512990e+00 -5.6385466e-05  3.8859999e-01 -3.4943256e-01]\n [ 4.7421460e+00 -3.1945827e+00  3.5528181e+00  5.5852943e-05  8.4794536e-03  7.6405057e-03]\n [ 4.0760727e+00  2.1640673e-01 -4.0513167e+00 -5.9565349e-04  1.1407082e-02  2.1432268e-06]\n [ 5.1680198e-03 -9.7754575e-02 -9.7093947e-02 -8.4155556e-12 -1.2910691e-12 -1.9347857e-11]\n [-5.1910793e-03  9.7588278e-02 -9.7106412e-02  8.4155573e-12  1.2910637e-12 -1.9347855e-11]]\n>>>\n>>> # get measured joint force and torque for the fingers\n>>> metadata = prim._articulation_view._metadata\n>>> joint_indices = 1 + np.array([\n...     metadata.joint_indices[\"panda_finger_joint1\"],\n...     metadata.joint_indices[\"panda_finger_joint2\"],\n... ])\n>>> joint_indices\n[10 11]\n>>> prim.get_measured_joint_forces(joint_indices)\n[[ 5.1680198e-03 -9.7754575e-02 -9.7093947e-02 -8.4155556e-12 -1.2910691e-12 -1.9347857e-11]\n [-5.1910793e-03  9.7588278e-02 -9.7106412e-02  8.4155573e-12  1.2910637e-12 -1.9347855e-11]]\n```\n",
"snippet":"measured_joint_forces = articulation.get_measured_joint_forces()\n",
"category":"method"
},
{
"title":"get_sleep_threshold",
"description":"Get the threshold for articulations to enter a sleep state\n\nSearch for *Articulations and Sleeping* in for more details\n\n**Returns:**\n\n * float: sleep threshold\n\n---\n**Example:**\n\n```python\n>>> prim.get_sleep_threshold()\n0.005\n```\n",
"snippet":"sleep_threshold = articulation.get_sleep_threshold()\n",
"category":"method"
},
{
"title":"get_solver_position_iteration_count",
"description":"Get the solver (position) iteration count for the articulation\n\nThe solver iteration count determines how accurately contacts, drives, and limits are resolved.\nSearch for *Solver Iteration Count* in for more details.\n\n**Returns:**\n\n * int: position iteration count\n\n---\n**Example:**\n\n```python\n>>> prim.get_solver_position_iteration_count()\n32\n```\n",
"snippet":"solver_position_iteration_count = articulation.get_solver_position_iteration_count()\n",
"category":"method"
},
{
"title":"get_solver_velocity_iteration_count",
"description":"Get the solver (velocity) iteration count for the articulation\n\nThe solver iteration count determines how accurately contacts, drives, and limits are resolved.\nSearch for *Solver Iteration Count* in for more details.\n\n**Returns:**\n\n * int: velocity iteration count\n\n---\n**Example:**\n\n```python\n>>> prim.get_solver_velocity_iteration_count()\n32\n```\n",
"snippet":"solver_velocity_iteration_count = articulation.get_solver_velocity_iteration_count()\n",
"category":"method"
},
{
"title":"get_stabilization_threshold",
"description":"Get the mass-normalized kinetic energy below which the articulation may participate in stabilization\n\nSearch for *Stabilization Threshold* in for more details\n\n**Returns:**\n\n * float: stabilization threshold\n\n---\n**Example:**\n\n```python\n>>> prim.get_stabilization_threshold()\n0.0009999999\n```\n",
"snippet":"stabilization_threshold = articulation.get_stabilization_threshold()\n",
"category":"method"
},
{
"title":"get_visibility",
"description":"**Returns:**\n\n * bool: true if the prim is visible in stage. false otherwise.\n\n---\n**Example:**\n\n```python\n>>> # get the visible state of an visible prim on the stage\n>>> prim.get_visibility()\nTrue\n```\n",
"snippet":"visibility = articulation.get_visibility()\n",
"category":"method"
},
{
"title":"get_world_pose",
"description":"Get prim's pose with respect to the world's frame\n\n**Returns:**\n\n * Tuple\\[np.ndarray, np.ndarray\\]: first index is the position in the world frame (with shape (3, )).\n    Second index is quaternion orientation (with shape (4, )) in the world frame\n\n---\n**Example:**\n\n```python\n>>> # if the prim is in position (1.0, 0.5, 0.0) with respect to the world frame\n>>> position, orientation = prim.get_world_pose()\n>>> position\n[1.  0.5 0. ]\n>>> orientation\n[1. 0. 0. 0.]\n```\n",
"snippet":"world_pose = articulation.get_world_pose()\n",
"category":"method"
},
{
"title":"get_world_scale",
"description":"Get prim's scale with respect to the world's frame\n\n**Returns:**\n\n * np.ndarray: scale applied to the prim's dimensions in the world frame. shape is (3, ).\n\n---\n**Example:**\n\n```python\n>>> prim.get_world_scale()\n[1. 1. 1.]\n```\n",
"snippet":"world_scale = articulation.get_world_scale()\n",
"category":"method"
},
{
"title":"handles_initialized",
"description":"Check if articulation handler is initialized\n\n**Returns:**\n\n * bool: whether the handler was initialized\n\n---\n**Example:**\n\n```python\n>>> prim.handles_initialized\nTrue\n```\n",
"snippet":"handles_initialized = articulation.handles_initialized\n",
"category":"property"
},
{
"title":"initialize",
"description":"Create a physics simulation view if not passed and an articulation view using PhysX tensor API\n\n*Note:*\nIf the articulation has been added to the world scene (e.g., `world.scene.add(prim)`),\nit will be automatically initialized when the world is reset (e.g., `world.reset()`).\n\n*Warning:*\nThis method needs to be called after each hard reset (e.g., Stop + Play on the timeline)\nbefore interacting with any other class method.\n\n**Args:**\n\n * `physics_sim_view` (omni.physics.tensors.SimulationView, optional): current physics simulation view. Defaults to None.\n\n---\n**Example:**\n\n```python\n>>> prim.initialize()\n```\n",
"snippet":"articulation.initialize()\n",
"category":"method"
},
{
"title":"initialize",
"description":"Create a physics simulation view if not passed and using PhysX tensor API\n\n*Note:*\nIf the prim has been added to the world scene (e.g., `world.scene.add(prim)`),\nit will be automatically initialized when the world is reset (e.g., `world.reset()`).\n\n**Args:**\n\n * `physics_sim_view` (omni.physics.tensors.SimulationView, optional): current physics simulation view. Defaults to None.\n\n---\n**Example:**\n\n```python\n>>> prim.initialize()\n```\n",
"snippet":"articulation.initialize()\n",
"category":"method"
},
{
"title":"is_valid",
"description":"Check if the prim path has a valid USD Prim at it\n\n**Returns:**\n\n * bool: True is the current prim path corresponds to a valid prim in stage. False otherwise.\n\n---\n**Example:**\n\n```python\n>>> # given an existing and valid prim\n>>> prims.is_valid()\nTrue\n```\n",
"snippet":"value = articulation.is_valid()\n",
"category":"method"
},
{
"title":"is_visual_material_applied",
"description":"Check if there is a visual material applied\n\n**Returns:**\n\n * bool: True if there is a visual material applied. False otherwise.\n\n---\n**Example:**\n\n```python\n>>> # given a visual material applied\n>>> prim.is_visual_material_applied()\nTrue\n```\n",
"snippet":"value = articulation.is_visual_material_applied()\n",
"category":"method"
},
{
"title":"num_dof",
"description":"Number of DOF of the articulation\n\n**Returns:**\n\n * int: amount of DOFs\n\n---\n**Example:**\n\n```python\n>>> prim.num_dof\n9\n```\n",
"snippet":"num_dof = articulation.num_dof\n",
"category":"property"
},
{
"title":"post_reset",
"description":"Reset the prim to its default state (position and orientation).\n\n*Note:*\nFor an articulation, in addition to configuring the root prim's default position and spatial orientation\n(defined via the `set_default_state` method), the joint's positions, velocities, and efforts\n(defined via the `set_joints_default_state` method) are imposed\n\n---\n**Example:**\n\n```python\n>>> prim.post_reset()\n```\n",
"snippet":"articulation.post_reset()\n",
"category":"method"
},
{
"title":"set_angular_velocity",
"description":"Set the angular velocity of the root articulation prim\n\n*Warning:*\nThis method will immediately set the articulation state\n\n**Args:**\n\n * `velocity` (np.ndarray): 3D angular velocity vector. Shape (3,)\n\n*Hint:*\nThis method belongs to the methods used to set the articulation kinematic state:\n\n> `set_linear_velocity`, `set_angular_velocity`, `set_joint_positions`,\n> `set_joint_velocities`, `set_joint_efforts`\n\n---\n**Example:**\n\n```python\n>>> prim.set_angular_velocity(np.array([0.1, 0.0, 0.0]))\n```\n",
"snippet":"articulation.set_angular_velocity(velocity=velocity)\n",
"category":"method"
},
{
"title":"set_default_state",
"description":"Set the default state of the prim (position and orientation), that will be used after each reset.\n\n**Args:**\n\n * `position` (Optional\\[Sequence\\[float\\]\\], optional): position in the world frame of the prim. shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the world frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n\n---\n**Example:**\n\n```python\n>>> # configure default state\n>>> prim.set_default_state(position=np.array([1.0, 0.5, 0.0]), orientation=np.array([1, 0, 0, 0]))\n>>>\n>>> # set default states during post-reset\n>>> prim.post_reset()\n```\n",
"snippet":"articulation.set_default_state()\n",
"category":"method"
},
{
"title":"set_enabled_self_collisions",
"description":"Set the enable self collisions flag (`physxArticulation:enabledSelfCollisions`)\n\n**Args:**\n\n * `flag` (bool): whether to enable self collisions\n\n---\n**Example:**\n\n```python\n>>> prim.set_enabled_self_collisions(True)\n```\n",
"snippet":"articulation.set_enabled_self_collisions(flag=flag)\n",
"category":"method"
},
{
"title":"set_joint_efforts",
"description":"Set the articulation joint efforts\n\n*Note:*\nThis method can be used for effort control. For this purpose, there must be no joint drive\nor the stiffness and damping must be set to zero.\n\n**Args:**\n\n * `efforts` (np.ndarray): articulation joint efforts\n * `joint_indices` (Optional\\[Union\\[list, np.ndarray\\]\\], optional): indices to specify which joints to manipulate. Defaults to None (all joints)\n\n*Hint:*\nThis method belongs to the methods used to set the articulation kinematic state:\n\n> `set_linear_velocity`, `set_angular_velocity`, `set_joint_positions`,\n> `set_joint_velocities`, `set_joint_efforts`\n\n---\n**Example:**\n\n```python\n>>> # set all the robot joint efforts to 0.0\n>>> prim.set_joint_efforts(np.array([0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]))\n>>>\n>>> # set only the fingers efforts: panda_finger_joint1 (7) and panda_finger_joint2 (8) to 10\n>>> prim.set_joint_efforts(np.array([10, 10]), joint_indices=np.array([7, 8]))\n```\n",
"snippet":"articulation.set_joint_efforts(efforts=efforts)\n",
"category":"method"
},
{
"title":"set_joint_positions",
"description":"Set the articulation joint positions\n\n*Warning:*\nThis method will immediately set (teleport) the affected joints to the indicated value.\nUse the `apply_action` method to control robot joints.\n\n**Args:**\n\n * `positions` (np.ndarray): articulation joint positions\n * `joint_indices` (Optional\\[Union\\[list, np.ndarray\\]\\], optional): indices to specify which joints to manipulate. Defaults to None (all joints)\n\n*Hint:*\nThis method belongs to the methods used to set the articulation kinematic state:\n\n> `set_linear_velocity`, `set_angular_velocity`, `set_joint_positions`,\n> `set_joint_velocities`, `set_joint_efforts`\n\n---\n**Example:**\n\n```python\n>>> # set all the robot joints\n>>> prim.set_joint_positions(np.array([0.0, -1.0, 0.0, -2.2, 0.0, 2.4, 0.8, 0.04, 0.04]))\n>>>\n>>> # set only the fingers in closed position: panda_finger_joint1 (7) and panda_finger_joint2 (8) to 0.0\n>>> prim.set_joint_positions(np.array([0.04, 0.04]), joint_indices=np.array([7, 8]))\n```\n",
"snippet":"articulation.set_joint_positions(positions=positions)\n",
"category":"method"
},
{
"title":"set_joint_velocities",
"description":"Set the articulation joint velocities\n\n*Warning:*\nThis method will immediately set the affected joints to the indicated value.\nUse the `apply_action` method to control robot joints.\n\n**Args:**\n\n * `velocities` (np.ndarray): articulation joint velocities\n * `joint_indices` (Optional\\[Union\\[list, np.ndarray\\]\\], optional): indices to specify which joints to manipulate. Defaults to None (all joints)\n\n*Hint:*\nThis method belongs to the methods used to set the articulation kinematic state:\n\n> `set_linear_velocity`, `set_angular_velocity`, `set_joint_positions`,\n> `set_joint_velocities`, `set_joint_efforts`\n\n---\n**Example:**\n\n```python\n>>> # set all the robot joint velocities to 0.0\n>>> prim.set_joint_velocities(np.array([0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]))\n>>>\n>>> # set only the fingers velocities: panda_finger_joint1 (7) and panda_finger_joint2 (8) to -0.01\n>>> prim.set_joint_velocities(np.array([-0.01, -0.01]), joint_indices=np.array([7, 8]))\n```\n",
"snippet":"articulation.set_joint_velocities(velocities=velocities)\n",
"category":"method"
},
{
"title":"set_joints_default_state",
"description":"Set the joint default states (positions, velocities and/or efforts) to be applied after each reset.\n\n*Note:*\nThe default states will be set during post-reset (e.g., calling `.post_reset()` or `world.reset()` methods)\n\n**Args:**\n\n * `positions` (Optional\\[np.ndarray\\], optional): joint positions. Defaults to None.\n * `velocities` (Optional\\[np.ndarray\\], optional): joint velocities. Defaults to None.\n * `efforts` (Optional\\[np.ndarray\\], optional): joint efforts. Defaults to None.\n\n---\n**Example:**\n\n```python\n>>> # configure default joint states\n>>> prim.set_joints_default_state(\n...     positions=np.array([0.0, -1.0, 0.0, -2.2, 0.0, 2.4, 0.8, 0.04, 0.04]),\n...     velocities=np.zeros(shape=(prim.num_dof,)),\n...     efforts=np.zeros(shape=(prim.num_dof,))\n... )\n>>>\n>>> # set default states during post-reset\n>>> prim.post_reset()\n```\n",
"snippet":"articulation.set_joints_default_state()\n",
"category":"method"
},
{
"title":"set_linear_velocity",
"description":"Set the linear velocity of the root articulation prim\n\n*Warning:*\nThis method will immediately set the articulation state\n\n**Args:**\n\n * `velocity` (np.ndarray): 3D linear velocity vector. Shape (3,).\n\n*Hint:*\nThis method belongs to the methods used to set the articulation kinematic state:\n\n> `set_linear_velocity`, `set_angular_velocity`, `set_joint_positions`,\n> `set_joint_velocities`, `set_joint_efforts`\n\n---\n**Example:**\n\n```python\n>>> prim.set_linear_velocity(np.array([0.1, 0.0, 0.0]))\n```\n",
"snippet":"articulation.set_linear_velocity(velocity=velocity)\n",
"category":"method"
},
{
"title":"set_local_pose",
"description":"Set prim's pose with respect to the local frame (the prim's parent frame).\n\n*Warning:*\nThis method will change (teleport) the prim pose immediately to the indicated value\n\n**Args:**\n\n * `translation` (Optional\\[Sequence\\[float\\]\\], optional): translation in the local frame of the prim (with respect to its parent prim). shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the local frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n\n*Hint:*\nThis method belongs to the methods used to set the prim state\n\n---\n**Example:**\n\n```python\n>>> prim.set_local_pose(translation=np.array([1.0, 0.5, 0.0]), orientation=np.array([1., 0., 0., 0.]))\n```\n",
"snippet":"articulation.set_local_pose()\n",
"category":"method"
},
{
"title":"set_local_scale",
"description":"Set prim's scale with respect to the local frame (the prim's parent frame).\n\n**Args:**\n\n * `scale` (Optional\\[Sequence\\[float\\]\\]): scale to be applied to the prim's dimensions. shape is (3, ). Defaults to None, which means left unchanged.\n\n---\n**Example:**\n\n```python\n>>> # scale prim 10 times smaller\n>>> prim.set_local_scale(np.array([0.1, 0.1, 0.1]))\n```\n",
"snippet":"articulation.set_local_scale(scale=scale)\n",
"category":"method"
},
{
"title":"set_sleep_threshold",
"description":"Set the threshold for articulations to enter a sleep state\n\nSearch for *Articulations and Sleeping* in for more details\n\n**Args:**\n\n * `threshold` (float): sleep threshold\n\n---\n**Example:**\n\n```python\n>>> prim.set_sleep_threshold(0.01)\n```\n",
"snippet":"articulation.set_sleep_threshold(threshold=threshold)\n",
"category":"method"
},
{
"title":"set_solver_position_iteration_count",
"description":"Set the solver (position) iteration count for the articulation\n\nThe solver iteration count determines how accurately contacts, drives, and limits are resolved.\nSearch for *Solver Iteration Count* in for more details.\n\n*Warning:*\nSetting a higher number of iterations may improve the fidelity of the simulation, although it may affect its performance.\n\n**Args:**\n\n * `count` (int): position iteration count\n\n---\n**Example:**\n\n```python\n>>> prim.set_solver_position_iteration_count(64)\n```\n",
"snippet":"articulation.set_solver_position_iteration_count(count=count)\n",
"category":"method"
},
{
"title":"set_solver_velocity_iteration_count",
"description":"Set the solver (velocity) iteration count for the articulation\n\nThe solver iteration count determines how accurately contacts, drives, and limits are resolved.\nSearch for *Solver Iteration Count* in for more details.\n\n*Warning:*\nSetting a higher number of iterations may improve the fidelity of the simulation, although it may affect its performance.\n\n**Args:**\n\n * `count` (int): velocity iteration count\n\n---\n**Example:**\n\n```python\n>>> prim.set_solver_velocity_iteration_count(64)\n```\n",
"snippet":"articulation.set_solver_velocity_iteration_count(count=count)\n",
"category":"method"
},
{
"title":"set_stabilization_threshold",
"description":"Set the mass-normalized kinetic energy below which the articulation may participate in stabilization\n\nSearch for *Stabilization Threshold* in for more details\n\n**Args:**\n\n * `threshold` (float): stabilization threshold\n\n---\n**Example:**\n\n```python\n>>> prim.set_stabilization_threshold(0.005)\n```\n",
"snippet":"articulation.set_stabilization_threshold(threshold=threshold)\n",
"category":"method"
},
{
"title":"set_visibility",
"description":"Set the visibility of the prim in stage\n\n**Args:**\n\n * `visible` (bool): flag to set the visibility of the usd prim in stage.\n\n---\n**Example:**\n\n```python\n>>> # make prim not visible in the stage\n>>> prim.set_visibility(visible=False)\n```\n",
"snippet":"articulation.set_visibility(visible=visible)\n",
"category":"method"
},
{
"title":"set_world_pose",
"description":"Ses prim's pose with respect to the world's frame\n\n*Warning:*\nThis method will change (teleport) the prim pose immediately to the indicated value\n\n**Args:**\n\n * `position` (Optional\\[Sequence\\[float\\]\\], optional): position in the world frame of the prim. shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the world frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n\n*Hint:*\nThis method belongs to the methods used to set the prim state\n\n---\n**Example:**\n\n```python\n>>> prim.set_world_pose(position=np.array([1.0, 0.5, 0.0]), orientation=np.array([1., 0., 0., 0.]))\n```\n",
"snippet":"articulation.set_world_pose()\n",
"category":"method"
}
]
},
{
"title":"ArticulationGripper",
"snippets":[
{
"title":"import ...",
"description":"Import class",
"snippet":"from omni.isaac.core.articulations import ArticulationGripper\n",
"category":"import"
},
{
"title":"ArticulationGripper",
"description":"\\[summary\\]\n\n**Args:**\n\n * `gripper_dof_names` (list): \\[description\\]\n * `gripper_open_position` (Optional\\[np.ndarray\\], optional): \\[description\\]. Defaults to None.\n * `gripper_closed_position` (Optional\\[np.ndarray\\], optional): \\[description\\]. Defaults to None.\n",
"snippet":"articulation_gripper = ArticulationGripper(gripper_dof_names=gripper_dof_names)\n",
"category":"class"
},
{
"title":"apply_action",
"description":"\\[summary\\]\n\n**Args:**\n\n * `action` (ArticulationAction): \\[description\\]\n",
"snippet":"articulation_gripper.apply_action(action=action)\n",
"category":"method"
},
{
"title":"closed_position",
"description":"\\[summary\\]\n\n**Returns:**\n\n * np.ndarray: \\[description\\]\n",
"snippet":"closed_position = articulation_gripper.closed_position\n",
"category":"property"
},
{
"title":"dof_indices",
"description":"\\[summary\\]\n\n**Returns:**\n\n * np.ndarray: \\[description\\]\n",
"snippet":"dof_indices = articulation_gripper.dof_indices\n",
"category":"property"
},
{
"title":"get_positions",
"description":"\\[summary\\]\n\n**Returns:**\n\n * np.ndarray: \\[description\\]\n",
"snippet":"positions = articulation_gripper.get_positions()\n",
"category":"method"
},
{
"title":"get_velocities",
"description":"\\[summary\\]\n\n**Returns:**\n\n * np.ndarray: \\[description\\]\n",
"snippet":"velocities = articulation_gripper.get_velocities()\n",
"category":"method"
},
{
"title":"initialize",
"description":"\\[summary\\]\n\n**Args:**\n\n * `root_prim_path` (str): \\[description\\]\n * `articulation_controller` (ArticulationController): \\[description\\]\n\n**Raises:**\n\n * Exception: \\[description\\]\n",
"snippet":"articulation_gripper.initialize(root_prim_path=root_prim_path, articulation_controller=articulation_controller)\n",
"category":"method"
},
{
"title":"open_position",
"description":"\\[summary\\]\n\n**Returns:**\n\n * np.ndarray: \\[description\\]\n",
"snippet":"open_position = articulation_gripper.open_position\n",
"category":"property"
},
{
"title":"set_positions",
"description":"\\[summary\\]\n\n**Args:**\n\n * `positions` (np.ndarray): \\[description\\]\n",
"snippet":"articulation_gripper.set_positions(positions=positions)\n",
"category":"method"
},
{
"title":"set_velocities",
"description":"\\[summary\\]\n\n**Args:**\n\n * `velocities` (np.ndarray): \\[description\\]\n",
"snippet":"articulation_gripper.set_velocities(velocities=velocities)\n",
"category":"method"
}
]
},
{
"title":"ArticulationSubset",
"snippets":[
{
"title":"import ...",
"description":"Import class",
"snippet":"from omni.isaac.core.articulations import ArticulationSubset\n",
"category":"import"
},
{
"title":"ArticulationSubset",
"description":"A utility class for viewing a subset of the joints in a robot Articulation object.\n\nThis class can be helpful in two ways:\n\n1.  The order of joints returned by a robot Articulation may not match the order of joints\n    expected by a function\n2.  A function may only care about a subset of the joint states that are returned by a robot\n    Articulation.\n\n---\n**Example:**\n\n> Suppose the robot Articulation returns positions \\[0,1,2\\] for joints \\[\"A\",\"B\",\"C\"\\], and\n> suppose that we pass joint\\_names = \\[\"B\",\"A\"\\].\n>\n> ArticulationSubset.get\\_joint\\_positions() -\\> \\[1,0\\]\n> ArticulationSubset.map\\_to\\_articulation\\_order(\\[1,0\\]) -\\> \\[0,1,None\\]\n\n**Args:**\n\n * `articulation` (Articulation): An initialized Articulation object representing the simulated robot\n * `joint_names` (List\\[str\\]): A list of joint names whose order determines the order of the joints returned by functions like get\\_joint\\_positions()\n",
"snippet":"articulation_subset = ArticulationSubset(articulation=articulation, joint_names=joint_names)\n",
"category":"class"
},
{
"title":"apply_action",
"description":"Apply the specified control actions to this views joints.\n\n**Args:**\n\n    joint\\_positions: Target joint positions for this subset's joints.\n    joint\\_velocities: Target joint velocities for this subset's joints.\n",
"snippet":"articulation_subset.apply_action()\n",
"category":"method"
},
{
"title":"get_applied_action",
"description":"Retrieves the latest applied action for this subset.\n\nReturns: The ArticulationAction for this subset. Each commanded entry is either None or\ncontains one value for each of the subset's joints. The joint\\_indices is set to this\nsubset's joint indices.\n",
"snippet":"applied_action = articulation_subset.get_applied_action()\n",
"category":"method"
},
{
"title":"get_joint_efforts",
"description":"Get joint efforts for the joint names that were passed into this articulation view on\ninitialization. The indices of the joint efforts returned correspond to the indices of the\njoint names.\n\n**Returns:**\n\n * np.array: joint efforts\n",
"snippet":"joint_efforts = articulation_subset.get_joint_efforts()\n",
"category":"method"
},
{
"title":"get_joint_positions",
"description":"Get joint positions for the joint names that were passed into this articulation view on\ninitialization. The indices of the joint positions returned correspond to the indices of\nthe joint names.\n\n**Returns:**\n\n * np.array: joint positions\n",
"snippet":"joint_positions = articulation_subset.get_joint_positions()\n",
"category":"method"
},
{
"title":"get_joint_subset_indices",
"description":"Accessor for the joint indices for this subset. These are the indices into the full\narticulation degrees of freedom corresponding to this subset of joints.\n\n**Returns:**\n\n * np.array: An array of joint indices defining the subset.\n",
"snippet":"joint_subset_indices = articulation_subset.get_joint_subset_indices()\n",
"category":"method"
},
{
"title":"get_joint_velocities",
"description":"Get joint velocities for the joint names that were passed into this articulation view on\ninitialization. The indices of the joint velocities returned correspond to the indices of\nthe joint names.\n\n**Returns:**\n\n * np.array: joint velocities\n",
"snippet":"joint_velocities = articulation_subset.get_joint_velocities()\n",
"category":"method"
},
{
"title":"get_joints_state",
"description":"",
"snippet":"joints_state = articulation_subset.get_joints_state()\n",
"category":"method"
},
{
"title":"is_initialized",
"description":"Returns whether or not the underlying articulation object has been initialized.\n",
"snippet":"is_initialized = articulation_subset.is_initialized\n",
"category":"property"
},
{
"title":"joint_indices",
"description":"",
"snippet":"joint_indices = articulation_subset.joint_indices\n",
"category":"property"
},
{
"title":"make_articulation_action",
"description":"Make an articulation action for only this subset's joints using the given target\nposition and velocity values.\n\n**Args:**\n\n    joint\\_positions: Target joint positions for this subset's joints.\n    joint\\_velocities: Target joint velocities for this subset's joints.\n\nReturns: An ArticulationAction object specifying the action for this subset's joints.\n",
"snippet":"value = articulation_subset.make_articulation_action(joint_positions=joint_positions, joint_velocities=joint_velocities)\n",
"category":"method"
},
{
"title":"map_to_articulation_order",
"description":"Map a set of joint values to a format consumable by the robot Articulation.\n\n**Args:**\n\n    \\* `joint_values` (np.array): a set of joint values corresponding to the joint\\_names used to initialize this class. joint\\_values may be either one or two dimensional.\n    If one dimensional with shape (k,): A vector will be returned with length (self.articulation.num\\_dof) that may be consumed by the robot Articulation in an ArticulationAction.\n    If two dimensional with shape (N, k): A matrix will be returned with shape (N, self.articulation.num\\_dof) that may be converted to N ArticulationActions\n\n**Returns:**\n\n * np.array: a set of joint values that is padded with None to match the shape and order expected by the robot Articulation.\n",
"snippet":"value = articulation_subset.map_to_articulation_order(joint_values=joint_values)\n",
"category":"method"
},
{
"title":"num_joints",
"description":"",
"snippet":"num_joints = articulation_subset.num_joints\n",
"category":"property"
},
{
"title":"set_joint_efforts",
"description":"Set the joint efforts for this view.\n\n**Args:**\n\n    efforts: The effort values, one for each view joint in the order specified on\n    construction.\n",
"snippet":"articulation_subset.set_joint_efforts(efforts=efforts)\n",
"category":"method"
},
{
"title":"set_joint_positions",
"description":"Set the joint positions for this view.\n\n**Args:**\n\n    positions: The position values, one for each view joint in the order specified on\n    construction.\n",
"snippet":"articulation_subset.set_joint_positions(positions=positions)\n",
"category":"method"
},
{
"title":"set_joint_velocities",
"description":"Set the joint velocities for this view.\n\n**Args:**\n\n    velocities: The velocity values, one for each view joint in the order specified on\n    construction.\n",
"snippet":"articulation_subset.set_joint_velocities(velocities=velocities)\n",
"category":"method"
}
]
},
{
"title":"ArticulationView",
"snippets":[
{
"title":"import ...",
"description":"Import class",
"snippet":"from omni.isaac.core.articulations import ArticulationView\n",
"category":"import"
},
{
"title":"ArticulationView",
"description":"High level wrapper to deal with prims (one or many) that have the Root Articulation API applied\nand their attributes/properties\n\nThis class wraps all matching articulations found at the regex provided at the `prim_paths_expr` argument\n\n*Note:*\nEach prim will have `xformOp:orient`, `xformOp:translate` and `xformOp:scale` only post-init,\nunless it is a non-root articulation link.\n\n*Warning:*\nThe articulation view object must be initialized in order to be able to operate on it.\nSee the `initialize` method for more details.\n\n**Args:**\n\n * `prim_paths_expr` (str): prim paths regex to encapsulate all prims that match it. example: \"/World/Env\\[1-5\\]/Franka\" will match /World/Env1/Franka, /World/Env2/Franka..etc. (a non regex prim path can also be used to encapsulate one rigid prim).\n * `name` (str, optional): shortname to be used as a key by Scene class. Note: needs to be unique if the object is added to the Scene. Defaults to \"articulation\\_prim\\_view\".\n * `positions` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): default positions in the world frame of the prims. shape is (N, 3). Defaults to None, which means left unchanged.\n * `translations` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): default translations in the local frame of the prims (with respect to its parent prims). shape is (N, 3). Defaults to None, which means left unchanged.\n * `orientations` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): default quaternion orientations in the world/ local frame of the prims (depends if translation or position is specified). quaternion is scalar-first (w, x, y, z). shape is (N, 4).\n * `scales` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): local scales to be applied to the prim's dimensions in the view. shape is (N, 3). Defaults to None, which means left unchanged.\n * `visibilities` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): set to false for an invisible prim in the stage while rendering. shape is (N,). Defaults to None.\n * `reset_xform_properties` (bool, optional): True if the prims don't have the right set of xform properties (i.e: translate, orient and scale) ONLY and in that order. Set this parameter to False if the object were cloned using using the cloner api in omni.isaac.cloner. Defaults to True.\n * `enable_dof_force_sensors` (bool, optional): enables the solver computed dof force sensors on articulation joints. Defaults to False.\n\n---\n**Example:**\n\n```python\n>>> import omni.isaac.core.utils.stage as stage_utils\n>>> from omni.isaac.cloner import GridCloner\n>>> from omni.isaac.core.articulations import ArticulationView\n>>> from pxr import UsdGeom\n>>>\n>>> usd_path = \"/home/<user>/Documents/Assets/Robots/Franka/franka_alt_fingers.usd\"\n>>> env_zero_path = \"/World/envs/env_0\"\n>>> num_envs = 5\n>>>\n>>> # load the Franka Panda robot USD file\n>>> stage_utils.add_reference_to_stage(usd_path, prim_path=f\"{env_zero_path}/panda\")  # /World/envs/env_0/panda\n>>>\n>>> # clone the environment (num_envs)\n>>> cloner = GridCloner(spacing=1.5)\n>>> cloner.define_base_env(env_zero_path)\n>>> UsdGeom.Xform.Define(stage_utils.get_current_stage(), env_zero_path)\n>>> cloner.clone(source_prim_path=env_zero_path, prim_paths=cloner.generate_paths(\"/World/envs/env\", num_envs))\n>>>\n>>> # wrap all articulations\n>>> prims = ArticulationView(prim_paths_expr=\"/World/envs/env.*/panda\", name=\"franka_panda_view\")\n>>> prims\n<omni.isaac.core.articulations.articulation_view.ArticulationView object at 0x7ff174054b20>\n```\n",
"snippet":"articulation_view = ArticulationView(prim_paths_expr=prim_paths_expr)\n",
"category":"class"
},
{
"title":"apply_action",
"description":"Apply joint positions (targets), velocities (targets) and/or efforts to control an articulation\n\n*Note:*\nThis method can be used instead of the separate `set_joint_position_targets`,\n`set_joint_velocity_targets` and `set_joint_efforts`\n\n**Args:**\n\n * `control_actions` (ArticulationActions): actions to be applied for next physics step.\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n*Hint:*\nHigh stiffness makes the joints snap faster and harder to the desired target,\nand higher damping smoothes but also slows down the joint's movement to target\n\n * For position control, set relatively high stiffness and low damping (to reduce vibrations)\n * For velocity control, stiffness must be set to zero with a non-zero damping\n * For effort control, stiffness and damping must be set to zero\n\n---\n**Example:**\n\n```python\n>>> from omni.isaac.core.utils.types import ArticulationActions\n>>>\n>>> # move all the articulation joints to the indicated position.\n>>> # Since there are 5 envs, the joint positions are repeated 5 times\n>>> positions = np.tile(np.array([0.0, -1.0, 0.0, -2.2, 0.0, 2.4, 0.8, 0.04, 0.04]), (num_envs, 1))\n>>> action = ArticulationActions(joint_positions=positions)\n>>> prims.apply_action(action)\n>>>\n>>> # close the robot fingers: panda_finger_joint1 (7) and panda_finger_joint2 (8) to 0.0\n>>> # for the first, middle and last of the 5 envs\n>>> positions = np.tile(np.array([0.0, 0.0]), (3, 1))\n>>> action = ArticulationActions(joint_positions=positions, joint_indices=np.array([7, 8]))\n>>> prims.apply_action(action, indices=np.array([0, 2, 4]))\n```\n",
"snippet":"articulation_view.apply_action(control_actions=control_actions)\n",
"category":"method"
},
{
"title":"apply_visual_materials",
"description":"Apply visual material to the prims and optionally their prim descendants.\n\n**Args:**\n\n * `visual_materials` (Union\\[VisualMaterial, List\\[VisualMaterial\\]\\]): visual materials to be applied to the prims. Currently supports PreviewSurface, OmniPBR and OmniGlass. If a list is provided then its size has to be equal the view's size or indices size. If one material is provided it will be applied to all prims in the view.\n * `weaker_than_descendants` (Optional\\[Union\\[bool, List\\[bool\\]\\]\\], optional): True if the material shouldn't override the descendants materials, otherwise False. Defaults to False. If a list of visual materials is provided then a list has to be provided with the same size for this arg as well.\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Raises:**\n\n * Exception: length of visual materials != length of prims indexed\n    Exception: length of visual materials != length of weaker descendants bools arg\n\n---\n**Example:**\n\n```python\n>>> from omni.isaac.core.materials import OmniGlass\n>>>\n>>> # create a dark-red glass visual material\n>>> material = OmniGlass(\n...     prim_path=\"/World/material/glass\",  # path to the material prim to create\n...     ior=1.25,\n...     depth=0.001,\n...     thin_walled=False,\n...     color=np.array([0.5, 0.0, 0.0])\n... )\n>>> prims.apply_visual_materials(material)\n```\n",
"snippet":"articulation_view.apply_visual_materials(visual_materials=visual_materials)\n",
"category":"method"
},
{
"title":"body_names",
"description":"List of prim names for each rigid body (link) of the articulations\n\n**Returns:**\n\n * List\\[str\\]: ordered names of bodies that corresponds to links for the articulations in the view\n\n---\n**Example:**\n\n```python\n>>> prims.body_names\n['panda_link0', 'panda_link1', 'panda_link2', 'panda_link3', 'panda_link4', 'panda_link5',\n 'panda_link6', 'panda_link7', 'panda_link8', 'panda_hand', 'panda_leftfinger', 'panda_rightfinger']\n```\n",
"snippet":"body_names = articulation_view.body_names\n",
"category":"property"
},
{
"title":"dof_names",
"description":"List of prim names for each DOF of the articulations\n\n**Returns:**\n\n * List\\[str\\]: ordered names of joints that corresponds to degrees of freedom for the articulations in the view\n\n---\n**Example:**\n\n```python\n>>> prims.dof_names\n['panda_joint1', 'panda_joint2', 'panda_joint3', 'panda_joint4', 'panda_joint5',\n 'panda_joint6', 'panda_joint7', 'panda_finger_joint1', 'panda_finger_joint2']\n```\n",
"snippet":"dof_names = articulation_view.dof_names\n",
"category":"property"
},
{
"title":"get_angular_velocities",
"description":"Get the angular velocities of prims in the view.\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view)\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: angular velocities of the prims in the view. shape is (M, 3).\n\n---\n**Example:**\n\n```python\n>>> # get all articulation angular velocities. Returned shape is (5, 3) for the example: 5 envs, angular (3)\n>>> prims.get_angular_velocities()\n[[0. 0. 0.]\n [0. 0. 0.]\n [0. 0. 0.]\n [0. 0. 0.]\n [0. 0. 0.]]\n>>>\n>>> # get only the articulation angular velocities for the first, middle and last of the 5 envs\n>>> # Returned shape is (5, 3) for the example: 3 envs selected, angular (3)\n>>> prims.get_angular_velocities(indices=np.array([0, 2, 4]))\n[[0. 0. 0.]\n [0. 0. 0.]\n [0. 0. 0.]]\n```\n",
"snippet":"angular_velocities = articulation_view.get_angular_velocities()\n",
"category":"method"
},
{
"title":"get_applied_actions",
"description":"Get the last applied actions\n\n**Args:**\n\n * `clone` (bool, optional): True to return clones of the internal buffers. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * ArticulationActions: current applied actions (i.e: current position targets and velocity targets)\n\n---\n**Example:**\n\n```python\n>>> # last applied action: joint_positions -> [0.0, -1.0, 0.0, -2.2, 0.0, 2.4, 0.8, 0.04, 0.04].\n>>> # Returned shape is (5, 9) for the example: 5 envs, 9 DOFs\n>>> actions = prims.get_applied_actions()\n>>> actions\n<omni.isaac.core.utils.types.ArticulationActions object at 0x7f28af31d870>\n>>> actions.joint_positions\n[[ 0.   -1.    0.   -2.2   0.    2.4   0.8   0.04  0.04]\n [ 0.   -1.    0.   -2.2   0.    2.4   0.8   0.04  0.04]\n [ 0.   -1.    0.   -2.2   0.    2.4   0.8   0.04  0.04]\n [ 0.   -1.    0.   -2.2   0.    2.4   0.8   0.04  0.04]\n [ 0.   -1.    0.   -2.2   0.    2.4   0.8   0.04  0.04]]\n>>> actions.joint_velocities\n[[0. 0. 0. 0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0. 0. 0. 0.]]\n>>> actions.joint_efforts\n[[0. 0. 0. 0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0. 0. 0. 0.]]\n```\n",
"snippet":"applied_actions = articulation_view.get_applied_actions()\n",
"category":"method"
},
{
"title":"get_applied_joint_efforts",
"description":"Get the joint efforts of articulations in the view\n\nThis method will return the efforts set by the `set_joint_efforts` method\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `joint_indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): joint indices to specify which joints to query. Shape (K,). Where K \\<= num of dofs. Defaults to None (i.e: all dofs).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: joint efforts of articulations in the view. Shape is (M, K).\n\n---\n**Example:**\n\n```python\n>>> # get all applied joint efforts. Returned shape is (5, 9) for the example: 5 envs, 9 DOFs\n>>> prims.get_applied_joint_efforts()\n[[0. 0. 0. 0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0. 0. 0. 0.]]\n>>>\n>>> # get finger applied efforts: panda_finger_joint1 (7) and panda_finger_joint2 (8)\n>>> # for the first, middle and last of the 5 envs. Returned shape is (3, 2)\n>>> prims.get_applied_joint_efforts(indices=np.array([0, 2, 4]), joint_indices=np.array([7, 8]))\n[[0. 0.]\n [0. 0.]\n [0. 0.]]\n```\n",
"snippet":"applied_joint_efforts = articulation_view.get_applied_joint_efforts()\n",
"category":"method"
},
{
"title":"get_applied_visual_materials",
"description":"Get the current applied visual materials\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Returns:**\n\n * List\\[VisualMaterial\\]: a list of the current applied visual materials to the prims if its type is currently supported.\n\n---\n**Example:**\n\n```python\n>>> # get all applied visual materials. Returned size is 5 for the example: 5 envs\n>>> prims.get_applied_visual_materials()\n[<omni.isaac.core.materials.omni_glass.OmniGlass object at 0x7f829c165de0>,\n <omni.isaac.core.materials.omni_glass.OmniGlass object at 0x7f829c165de0>,\n <omni.isaac.core.materials.omni_glass.OmniGlass object at 0x7f829c165de0>,\n <omni.isaac.core.materials.omni_glass.OmniGlass object at 0x7f829c165de0>,\n <omni.isaac.core.materials.omni_glass.OmniGlass object at 0x7f829c165de0>]\n>>>\n>>> # get the applied visual materials for the first, middle and last of the 5 envs. Returned size is 3\n>>> prims.get_applied_visual_materials(indices=np.array([0, 2, 4]))\n[<omni.isaac.core.materials.omni_glass.OmniGlass object at 0x7f829c165de0>,\n <omni.isaac.core.materials.omni_glass.OmniGlass object at 0x7f829c165de0>,\n <omni.isaac.core.materials.omni_glass.OmniGlass object at 0x7f829c165de0>]\n```\n",
"snippet":"applied_visual_materials = articulation_view.get_applied_visual_materials()\n",
"category":"method"
},
{
"title":"get_armatures",
"description":"Get armatures for articulation joints in the view\n\nSearch for *\"Joint Armature\"* in for more details.\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `joint_indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): joint indices to specify which joints to query. Shape (K,). Where K \\<= num of dofs. Defaults to None (i.e: all dofs).\n * `clone` (Optional\\[bool\\]): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: joint armatures for articulations in the view. shape (M, K).\n\n---\n**Example:**\n\n```python\n>>> # get joint armatures. Returned shape is (5, 9) for the example: 5 envs, 9 DOFs\n>>> prims.get_armatures()\n[[0. 0. 0. 0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0. 0. 0. 0.]]\n>>>\n>>> # get only the finger joint (panda_finger_joint1 (7) and panda_finger_joint2 (8)) armatures\n>>> # for the first, middle and last of the 5 envs. Returned shape is (3, 2)\n>>> prims.get_armatures(indices=np.array([0,2,4]), joint_indices=np.array([7,8]))\n[[0. 0.]\n [0. 0.]\n [0. 0.]]\n```\n",
"snippet":"armatures = articulation_view.get_armatures()\n",
"category":"method"
},
{
"title":"get_articulation_body_count",
"description":"Get the number of rigid bodies (links) of the articulations\n\n**Returns:**\n\n * int: maximum number of rigid bodies (links) in the articulation\n\n---\n**Example:**\n\n```python\n>>> prims.get_articulation_body_count()\n12\n```\n",
"snippet":"articulation_body_count = articulation_view.get_articulation_body_count()\n",
"category":"method"
},
{
"title":"get_body_coms",
"description":"Get rigid body center of mass (COM) of articulations in the view.\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `body_indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): body indices to specify which bodies to query. Shape (K,). Where K \\<= num of bodies. Defaults to None (i.e: all bodies).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: rigid body center of mass positions and orientations\n    of articulations in the view. Position shape is (M, K, 3), orientation shape is (M, k, 4).\n\n---\n**Example:**\n\n```python\n>>> # get all body center of mass. Returned shape is (5, 12, 3) for positions and (5, 12, 4) for orientations\n>>> # for the example: 5 envs, 12 rigid bodies\n>>> positions, orientations = prims.get_body_coms()\n>>> positions\n[[[0. 0. 0.]\n  [0. 0. 0.]\n  ...\n  [0. 0. 0.]\n  [0. 0. 0.]]]\n>>> orientations\n[[[1. 0. 0. 0.]\n  [1. 0. 0. 0.]\n  ...\n  [1. 0. 0. 0.]\n  [1. 0. 0. 0.]]]\n>>>\n>>> # get finger body center of mass: panda_leftfinger (10) and panda_rightfinger (11) for the first,\n>>> # middle and last of the 5 envs. Returned shape is (3, 2, 3) for positions and (3, 2, 4) for orientations\n>>> positions, orientations = prims.get_body_coms(indices=np.array([0, 2, 4]), body_indices=np.array([10, 11]))\n>>> positions\n[[[0. 0. 0.]\n  [0. 0. 0.]]\n [[0. 0. 0.]\n  [0. 0. 0.]]\n [[0. 0. 0.]\n  [0. 0. 0.]]]\n>>> orientations\n[[[1. 0. 0. 0.]\n  [1. 0. 0. 0.]]\n [[1. 0. 0. 0.]\n  [1. 0. 0. 0.]]\n [[1. 0. 0. 0.]\n  [1. 0. 0. 0.]]]\n```\n",
"snippet":"body_coms = articulation_view.get_body_coms()\n",
"category":"method"
},
{
"title":"get_body_index",
"description":"Get a ridig body (link) index in the articulation view given its name\n\n**Args:**\n\n * `body_name` (str): name of the ridig body to query\n\n**Returns:**\n\n * int: index of the rigid body in the articulation buffers\n\n---\n**Example:**\n\n```python\n>>> # get the index of the left finger: panda_leftfinger\n>>> prims.get_body_index(\"panda_leftfinger\")\n10\n```\n",
"snippet":"body_index = articulation_view.get_body_index(body_name=body_name)\n",
"category":"method"
},
{
"title":"get_body_inertias",
"description":"Get rigid body inertias of articulations in the view\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `body_indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): body indices to specify which bodies to query. Shape (K,). Where K \\<= num of bodies. Defaults to None (i.e: all bodies).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: rigid body inertias of articulations in the view. Shape is (M, K, 9).\n\n---\n**Example:**\n\n```python\n>>> # get all body inertias. Returned shape is (5, 12, 9) for the example: 5 envs, 12 rigid bodies\n>>> prims.get_body_inertias()\n[[[1.2988697e-06  0.0  0.0  0.0  1.6535528e-06  0.0  0.0  0.0  2.0331163e-06]\n  [1.8686389e-06  0.0  0.0  0.0  1.4378986e-06  0.0  0.0  0.0  9.0681192e-07]\n  ...\n  [4.2041304e-10  0.0  0.0  0.0  3.9026365e-10  0.0  0.0  0.0  1.3347495e-10]\n  [4.2041304e-10  0.0  0.0  0.0  3.9026365e-10  0.0  0.0  0.0  1.3347495e-10]]]\n>>>\n>>> # get finger body inertias: panda_leftfinger (10) and panda_rightfinger (11)\n>>> # for the first, middle and last of the 5 envs. Returned shape is (3, 2, 9)\n>>> prims.get_body_inertias(indices=np.array([0, 2, 4]), body_indices=np.array([10, 11]))\n[[[4.2041304e-10  0.0  0.0  0.0  3.9026365e-10  0.0  0.0  0.0  1.3347495e-10]\n  [4.2041304e-10  0.0  0.0  0.0  3.9026365e-10  0.0  0.0  0.0  1.3347495e-10]]\n ...\n [[4.2041304e-10  0.0  0.0  0.0  3.9026365e-10  0.0  0.0  0.0  1.3347495e-10]\n  [4.2041304e-10  0.0  0.0  0.0  3.9026365e-10  0.0  0.0  0.0  1.3347495e-10]]]\n```\n",
"snippet":"body_inertias = articulation_view.get_body_inertias()\n",
"category":"method"
},
{
"title":"get_body_inv_inertias",
"description":"Get rigid body inverse inertias of articulations in the view\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `body_indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): body indices to specify which bodies to query. Shape (K,). Where K \\<= num of bodies. Defaults to None (i.e: all bodies).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: rigid body inverse inertias of articulations in the view.\n    Shape is (M, K, 9).\n\n---\n**Example:**\n\n```python\n>>> # get all body inverse inertias. Returned shape is (5, 12, 9) for the example: 5 envs, 12 rigid bodies\n>>> prims.get_body_inv_inertias()\n[[[7.6990012e+05  0.0  0.0  0.0  6.0475844e+05  0.0  0.0  0.0  4.9185578e+05]\n  [5.3514888e+05  0.0  0.0  0.0  6.9545931e+05  0.0  0.0  0.0  1.1027645e+06]\n  ...\n  [2.3786132e+09  0.0  0.0  0.0  2.5623703e+09  0.0  0.0  0.0  7.4920422e+09]\n  [2.3786132e+09  0.0  0.0  0.0  2.5623703e+09  0.0  0.0  0.0  7.4920422e+09]]]\n>>>\n>>> # get finger body inverse inertias: panda_leftfinger (10) and panda_rightfinger (11)\n>>> # for the first, middle and last of the 5 envs. Returned shape is (3, 2, 9)\n>>> prims.get_body_inv_inertias(indices=np.array([0, 2, 4]), body_indices=np.array([10, 11]))\n[[[2.3786132e+09  0.0  0.0  0.0  2.5623703e+09  0.0  0.0  0.0  7.4920422e+09]\n  [2.3786132e+09  0.0  0.0  0.0  2.5623703e+09  0.0  0.0  0.0  7.4920422e+09]]\n ...\n [[2.3786132e+09  0.0  0.0  0.0  2.5623703e+09  0.0  0.0  0.0  7.4920422e+09]\n  [2.3786132e+09  0.0  0.0  0.0  2.5623703e+09  0.0  0.0  0.0  7.4920422e+09]]]\n```\n",
"snippet":"body_inv_inertias = articulation_view.get_body_inv_inertias()\n",
"category":"method"
},
{
"title":"get_body_inv_masses",
"description":"Get rigid body inverse masses of articulations in the view\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `body_indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): body indices to specify which bodies to query. Shape (K,). Where K \\<= num of bodies. Defaults to None (i.e: all bodies).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: rigid body inverse masses of articulations in the view.\n    Shape is (M, K).\n\n---\n**Example:**\n\n```python\n>>> # get all body inverse masses. Returned shape is (5, 12) for the example: 5 envs, 12 rigid bodies\n>>> prims.get_body_inv_masses()\n[[ 0.35534042  0.42372888  0.42025304  0.37737525  0.3710848  0.33542618  0.8860687\n   2.4673615  10. 1.7910539  71.14793  71.14793]\n [ 0.35534042  0.42372888  0.42025304  0.37737525  0.3710848  0.33542618  0.8860687\n   2.4673615  10. 1.7910539  71.14793  71.14793]\n [ 0.35534042  0.42372888  0.42025304  0.37737525  0.3710848  0.33542618  0.8860687\n   2.4673615  10. 1.7910539  71.14793  71.14793]\n [ 0.35534042  0.42372888  0.42025304  0.37737525  0.3710848  0.33542618  0.8860687\n   2.4673615  10. 1.7910539  71.14793  71.14793]\n [ 0.35534042  0.42372888  0.42025304  0.37737525  0.3710848  0.33542618  0.8860687\n   2.4673615  10. 1.7910539  71.14793  71.14793]]\n>>>\n>>> # get finger body inverse masses: panda_leftfinger (10) and panda_rightfinger (11)\n>>> # for the first, middle and last of the 5 envs. Returned shape is (3, 2)\n>>> prims.get_body_inv_masses(indices=np.array([0, 2, 4]), body_indices=np.array([10, 11]))\n[[71.14793 71.14793]\n [71.14793 71.14793]\n [71.14793 71.14793]]\n```\n",
"snippet":"body_inv_masses = articulation_view.get_body_inv_masses()\n",
"category":"method"
},
{
"title":"get_body_masses",
"description":"Get rigid body masses of articulations in the view\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `body_indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): body indices to specify which bodies to query. Shape (K,). Where K \\<= num of bodies. Defaults to None (i.e: all bodies).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: rigid body masses of articulations in the view.\n    Shape is (M, K).\n\n---\n**Example:**\n\n```python\n>>> # get all body masses. Returned shape is (5, 12) for the example: 5 envs, 12 rigid bodies\n>>> prims.get_body_masses()\n[[2.8142028  2.3599997  2.3795187  2.6498823  2.6948018  2.981282\n  1.1285807  0.40529126 0.1  0.5583305  0.01405522 0.01405522]\n [2.8142028  2.3599997  2.3795187  2.6498823  2.6948018  2.981282\n  1.1285807  0.40529126 0.1  0.5583305  0.01405522 0.01405522]\n [2.8142028  2.3599997  2.3795187  2.6498823  2.6948018  2.981282\n  1.1285807  0.40529126 0.1  0.5583305  0.01405522 0.01405522]\n [2.8142028  2.3599997  2.3795187  2.6498823  2.6948018  2.981282\n  1.1285807  0.40529126 0.1  0.5583305  0.01405522 0.01405522]\n [2.8142028  2.3599997  2.3795187  2.6498823  2.6948018  2.981282\n  1.1285807  0.40529126 0.1  0.5583305  0.01405522 0.01405522]]\n>>>\n>>> # get finger body masses: panda_leftfinger (10) and panda_rightfinger (11)\n>>> # for the first, middle and last of the 5 envs. Returned shape is (3, 2)\n>>> prims.get_body_masses(indices=np.array([0, 2, 4]), body_indices=np.array([10, 11]))\n[[0.01405522 0.01405522]\n [0.01405522 0.01405522]\n [0.01405522 0.01405522]]\n```\n",
"snippet":"body_masses = articulation_view.get_body_masses()\n",
"category":"method"
},
{
"title":"get_coriolis_and_centrifugal_forces",
"description":"Get the Coriolis and centrifugal forces (joint DOF forces required to counteract Coriolis and\ncentrifugal forces for the given articulation state) of articulations in the view\n\nSearch for *Coriolis and Centrifugal Forces* in for more details\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `joint_indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): joint indices to specify which joints to query. Shape (K,). Where K \\<= num of dofs. Defaults to None (i.e: all dofs).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: Coriolis and centrifugal forces of articulations in the view.\n    Shape is (M, K).\n\n---\n**Example:**\n\n```python\n>>> # get all coriolis and centrifugal forces. Returned shape is (5, 9) for the example: 5 envs, 9 DOFs\n>>> prims.get_coriolis_and_centrifugal_forces()\n[[ 1.6842524e-06 -1.8269569e-04  5.2162073e-07 -9.7677548e-05  3.0365106e-07\n   6.7375149e-06  6.1105780e-08 -4.6237556e-06 -4.1627968e-06]\n [ 1.6842524e-06 -1.8269569e-04  5.2162073e-07 -9.7677548e-05  3.0365106e-07\n   6.7375149e-06  6.1105780e-08 -4.6237556e-06 -4.1627968e-06]\n [ 1.6842561e-06 -1.8269687e-04  5.2162375e-07 -9.7677454e-05  3.0365084e-07\n   6.7375931e-06  6.1106007e-08 -4.6237533e-06 -4.1627954e-06]\n [ 1.6842561e-06 -1.8269687e-04  5.2162375e-07 -9.7677454e-05  3.0365084e-07\n   6.7375931e-06  6.1106007e-08 -4.6237533e-06 -4.1627954e-06]\n [ 1.6842524e-06 -1.8269569e-04  5.2162073e-07 -9.7677548e-05  3.0365106e-07\n   6.7375149e-06  6.1105780e-08 -4.6237556e-06 -4.1627968e-06]]\n>>>\n>>> # get finger joint coriolis and centrifugal forces: panda_finger_joint1 (7) and panda_finger_joint2 (8)\n>>> # for the first, middle and last of the 5 envs. Returned shape is (3, 2)\n>>> prims.get_coriolis_and_centrifugal_forces(indices=np.array([0, 2, 4]), joint_indices=np.array([7, 8]))\n[[-4.6237556e-06 -4.1627968e-06]\n [-4.6237533e-06 -4.1627954e-06]\n [-4.6237556e-06 -4.1627968e-06]]\n```\n",
"snippet":"coriolis_and_centrifugal_forces = articulation_view.get_coriolis_and_centrifugal_forces()\n",
"category":"method"
},
{
"title":"get_default_state",
"description":"Get the default states (positions and orientations) defined with the `set_default_state` method\n\n**Returns:**\n\n * XFormPrimViewState: returns the default state of the prims that is used after each reset.\n\n---\n**Example:**\n\n```python\n>>> state = prims.get_default_state()\n>>> state\n<omni.isaac.core.utils.types.XFormPrimViewState object at 0x7f82f73e3070>\n>>> state.positions\n[[ 1.5  -0.75  0.  ]\n [ 1.5   0.75  0.  ]\n [ 0.   -0.75  0.  ]\n [ 0.    0.75  0.  ]\n [-1.5  -0.75  0.  ]]\n>>> state.orientations\n[[1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]]\n```\n",
"snippet":"default_state = articulation_view.get_default_state()\n",
"category":"method"
},
{
"title":"get_dof_index",
"description":"Get a DOF index in the joint buffers given its name\n\n**Args:**\n\n * `dof_name` (str): name of the joint that corresponds to the degree of freedom to query\n\n**Returns:**\n\n * int: index of the degree of freedom in the joint buffers\n\n---\n**Example:**\n\n```python\n>>> # get the index of the left finger joint: panda_finger_joint1\n>>> prims.get_dof_index(\"panda_finger_joint1\")\n7\n```\n",
"snippet":"dof_index = articulation_view.get_dof_index(dof_name=dof_name)\n",
"category":"method"
},
{
"title":"get_dof_limits",
"description":"Get the articulations DOFs limits (lower and upper)\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.array\\]: degrees of freedom position limits.\n    Shape is (N, num\\_dof, 2). For the last dimension, index 0 corresponds to lower limits and index 1 corresponds to upper limits\n\n---\n**Example:**\n\n```python\n>>> # get DOF limits. Returned shape is (5, 9, 2) for the example: 5 envs, 9 DOFs\n>>> prims.get_dof_limits()\n[[[-2.8973  2.8973]\n [-1.7628  1.7628]\n [-2.8973  2.8973]\n [-3.0718 -0.0698]\n [-2.8973  2.8973]\n [-0.0175  3.7525]\n [-2.8973  2.8973]\n [ 0.      0.04  ]\n [ 0.      0.04  ]]\n...\n[[-2.8973  2.8973]\n [-1.7628  1.7628]\n [-2.8973  2.8973]\n [-3.0718 -0.0698]\n [-2.8973  2.8973]\n [-0.0175  3.7525]\n [-2.8973  2.8973]\n [ 0.      0.04  ]\n [ 0.      0.04  ]]]\n```\n",
"snippet":"dof_limits = articulation_view.get_dof_limits()\n",
"category":"method"
},
{
"title":"get_dof_types",
"description":"Get the DOF types given the DOF names\n\n**Args:**\n\n * `dof_names` (List\\[str\\], optional): names of the joints that corresponds to the degrees of freedom to query. Defaults to None.\n\n**Returns:**\n\n * List\\[str\\]: types of the joints that corresponds to the degrees of freedom. Types can be invalid, translation or rotation.\n\n---\n**Example:**\n\n```python\n>>> # get all DOF types\n>>> prims.get_dof_types()\n[<DofType.Rotation: 0>, <DofType.Rotation: 0>, <DofType.Rotation: 0>,\n <DofType.Rotation: 0>, <DofType.Rotation: 0>, <DofType.Rotation: 0>,\n <DofType.Rotation: 0>, <DofType.Translation: 1>, <DofType.Translation: 1>]\n>>>\n>>> # get only the finger DOF types: panda_finger_joint1 and panda_finger_joint2\n>>> prims.get_dof_types(dof_names=[\"panda_finger_joint1\", \"panda_finger_joint2\"])\n[<DofType.Translation: 1>, <DofType.Translation: 1>]\n```\n",
"snippet":"dof_types = articulation_view.get_dof_types()\n",
"category":"method"
},
{
"title":"get_effort_modes",
"description":"Get effort modes for articulations in the view\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `joint_indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): joint indices to specify which joints to query. Shape (K,). Where K \\<= num of dofs. Defaults to None (i.e: all dofs).\n\n**Returns:**\n\n * List: Returns a List of size (M, K) indicating the effort modes: `acceleration` or `force`\n\n---\n**Example:**\n\n```python\n>>> # get the effort mode for all joints\n>>> prims.get_effort_modes()\n[['acceleration', 'acceleration', 'acceleration', 'acceleration', 'acceleration', 'acceleration', 'acceleration', 'acceleration', 'acceleration'],\n ['acceleration', 'acceleration', 'acceleration', 'acceleration', 'acceleration', 'acceleration', 'acceleration', 'acceleration', 'acceleration'],\n ['acceleration', 'acceleration', 'acceleration', 'acceleration', 'acceleration', 'acceleration', 'acceleration', 'acceleration', 'acceleration'],\n ['acceleration', 'acceleration', 'acceleration', 'acceleration', 'acceleration', 'acceleration', 'acceleration', 'acceleration', 'acceleration'],\n ['acceleration', 'acceleration', 'acceleration', 'acceleration', 'acceleration', 'acceleration', 'acceleration', 'acceleration', 'acceleration']]\n>>>\n>>> # get only the finger joints effort modes for the first, middle and last of the 5 envs\n>>> prims.get_effort_modes(indices=np.array([0, 2, 4]), joint_indices=np.array([7, 8]))\n[['acceleration', 'acceleration'], ['acceleration', 'acceleration'], ['acceleration', 'acceleration']]\n```\n",
"snippet":"effort_modes = articulation_view.get_effort_modes()\n",
"category":"method"
},
{
"title":"get_enabled_self_collisions",
"description":"Get the enable self collisions flag (`physxArticulation:enabledSelfCollisions`) for all articulations\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: self collisions flags (boolean interpreted as int). shape (M,)\n\n---\n**Example:**\n\n```python\n>>> # get all self collisions flags. Returned shape is (5,) for the example: 5 envs\n>>> prims.get_enabled_self_collisions()\n[0 0 0 0 0]\n>>>\n>>> # get the self collisions flags for the first, middle and last of the 5 envs. Returned shape is (3,)\n>>> prims.get_enabled_self_collisions(indices=np.array([0, 2, 4]))\n[0 0 0]\n```\n",
"snippet":"enabled_self_collisions = articulation_view.get_enabled_self_collisions()\n",
"category":"method"
},
{
"title":"get_fixed_tendon_dampings",
"description":"Get the dampings of fixed tendons for articulations in the view\n\nSearch for *Fixed Tendon* in for more details\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: fixed tendon dampings of articulations in the view.\n    Shape is (M, K).\n\n---\n**Example:**\n\n```python\n>>> # get the fixed tendon dampings\n>>> # for the ShadowHand articulation that has 4 fixed tendons (prims.num_fixed_tendons)\n>>> prims.get_fixed_tendon_dampings()\n[[0. 0. 0. 0.]\n [0. 0. 0. 0.]\n [0. 0. 0. 0.]\n [0. 0. 0. 0.]\n [0. 0. 0. 0.]]\n```\n",
"snippet":"fixed_tendon_dampings = articulation_view.get_fixed_tendon_dampings()\n",
"category":"method"
},
{
"title":"get_fixed_tendon_limit_stiffnesses",
"description":"Get the limit stiffness of fixed tendons for articulations in the view\n\nSearch for *Fixed Tendon* in for more details\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: fixed tendon stiffnesses of articulations in the view.\n    Shape is (M, K).\n\n---\n**Example:**\n\n```python\n>>> # get the fixed tendon limit stiffnesses\n>>> # for the ShadowHand articulation that has 4 fixed tendons (prims.num_fixed_tendons)\n>>> prims.get_fixed_tendon_limit_stiffnesses()\n[[0. 0. 0. 0.]\n [0. 0. 0. 0.]\n [0. 0. 0. 0.]\n [0. 0. 0. 0.]\n [0. 0. 0. 0.]]\n```\n",
"snippet":"fixed_tendon_limit_stiffnesses = articulation_view.get_fixed_tendon_limit_stiffnesses()\n",
"category":"method"
},
{
"title":"get_fixed_tendon_limits",
"description":"Get the limits of fixed tendons for articulations in the view\n\nSearch for *Fixed Tendon* in for more details\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: fixed tendon stiffnesses of articulations in the view.\n    Shape is (M, K, 2).\n\n---\n**Example:**\n\n```python\n>>> # get the fixed tendon limits\n>>> # for the ShadowHand articulation that has 4 fixed tendons (prims.num_fixed_tendons)\n>>> prims.get_fixed_tendon_limits()\n[[[-0.001  0.001] [-0.001  0.001] [-0.001  0.001] [-0.001  0.001]]\n [[-0.001  0.001] [-0.001  0.001] [-0.001  0.001] [-0.001  0.001]]\n [[-0.001  0.001] [-0.001  0.001] [-0.001  0.001] [-0.001  0.001]]\n [[-0.001  0.001] [-0.001  0.001] [-0.001  0.001] [-0.001  0.001]]\n [[-0.001  0.001] [-0.001  0.001] [-0.001  0.001] [-0.001  0.001]]]\n```\n",
"snippet":"fixed_tendon_limits = articulation_view.get_fixed_tendon_limits()\n",
"category":"method"
},
{
"title":"get_fixed_tendon_offsets",
"description":"Get the offsets of fixed tendons for articulations in the view\n\nSearch for *Fixed Tendon* in for more details\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: fixed tendon stiffnesses of articulations in the view.\n    Shape is (M, K).\n\n---\n**Example:**\n\n```python\n>>> # get the fixed tendon offsets\n>>> # for the ShadowHand articulation that has 4 fixed tendons (prims.num_fixed_tendons)\n>>> prims.get_fixed_tendon_offsets()\n[[0. 0. 0. 0.]\n [0. 0. 0. 0.]\n [0. 0. 0. 0.]\n [0. 0. 0. 0.]\n [0. 0. 0. 0.]]\n```\n",
"snippet":"fixed_tendon_offsets = articulation_view.get_fixed_tendon_offsets()\n",
"category":"method"
},
{
"title":"get_fixed_tendon_rest_lengths",
"description":"Get the rest length of fixed tendons for articulations in the view\n\nSearch for *Fixed Tendon* in for more details\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: fixed tendon stiffnesses of articulations in the view.\n    Shape is (M, K).\n\n---\n**Example:**\n\n```python\n>>> # get the fixed tendon rest lengths\n>>> # for the ShadowHand articulation that has 4 fixed tendons (prims.num_fixed_tendons)\n>>> prims.get_fixed_tendon_rest_lengths()\n[[0. 0. 0. 0.]\n [0. 0. 0. 0.]\n [0. 0. 0. 0.]\n [0. 0. 0. 0.]\n [0. 0. 0. 0.]]\n```\n",
"snippet":"fixed_tendon_rest_lengths = articulation_view.get_fixed_tendon_rest_lengths()\n",
"category":"method"
},
{
"title":"get_fixed_tendon_stiffnesses",
"description":"Get the stiffness of fixed tendons for articulations in the view\n\nSearch for *Fixed Tendon* in for more details\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: fixed tendon stiffnesses of articulations in the view.\n    Shape is (M, K).\n\n---\n**Example:**\n\n```python\n>>> # get the fixed tendon stiffnesses\n>>> # for the ShadowHand articulation that has 4 fixed tendons (prims.num_fixed_tendons)\n>>> prims.get_fixed_tendon_stiffnesses()\n[[0. 0. 0. 0.]\n [0. 0. 0. 0.]\n [0. 0. 0. 0.]\n [0. 0. 0. 0.]\n [0. 0. 0. 0.]]\n```\n",
"snippet":"fixed_tendon_stiffnesses = articulation_view.get_fixed_tendon_stiffnesses()\n",
"category":"method"
},
{
"title":"get_friction_coefficients",
"description":"Get the friction coefficients for the articulation joints in the view\n\nSearch for *\"Joint Friction Coefficient\"* in for more details.\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `joint_indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): joint indices to specify which joints to query. Shape (K,). Where K \\<= num of dofs. Defaults to None (i.e: all dofs).\n * `clone` (Optional\\[bool\\]): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: joint friction coefficients for articulations in the view. shape (M, K).\n\n---\n**Example:**\n\n```python\n>>> # get joint friction coefficients. Returned shape is (5, 9) for the example: 5 envs, 9 DOFs\n>>> prims.get_friction_coefficients()\n[[0. 0. 0. 0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0. 0. 0. 0.]]\n>>>\n>>> # get only the finger joint (panda_finger_joint1 (7) and panda_finger_joint2 (8)) friction coefficients\n>>> # for the first, middle and last of the 5 envs. Returned shape is (3, 2)\n>>> prims.get_friction_coefficients(indices=np.array([0,2,4]), joint_indices=np.array([7,8]))\n[[0. 0.]\n [0. 0.]\n [0. 0.]]\n```\n",
"snippet":"friction_coefficients = articulation_view.get_friction_coefficients()\n",
"category":"method"
},
{
"title":"get_gains",
"description":"Get the implicit Proportional-Derivative (PD) controller's Kps (stiffnesses) and Kds (dampings) of articulations in the view\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `joint_indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): joint indices to specify which joints to query. Shape (K,). Where K \\<= num of dofs. Defaults to None (i.e: all dofs).\n * `clone` (bool, optional): True to return clones of the internal buffers. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Tuple\\[Union\\[np.ndarray, torch.Tensor\\], Union\\[np.ndarray, torch.Tensor\\], Union\\[wp.indexedarray, wp.index\\]\\]:\n    stiffness and damping of articulations in the view respectively. shapes are (M, K).\n\n---\n**Example:**\n\n```python\n>>> # get all joint stiffness and damping. Returned shape is (5, 9) for the example: 5 envs, 9 DOFs\n>>> stiffnesses, dampings = prims.get_gains()\n>>> stiffnesses\n[[60000. 60000. 60000. 60000. 25000. 15000.  5000.  6000.  6000.]\n [60000. 60000. 60000. 60000. 25000. 15000.  5000.  6000.  6000.]\n [60000. 60000. 60000. 60000. 25000. 15000.  5000.  6000.  6000.]\n [60000. 60000. 60000. 60000. 25000. 15000.  5000.  6000.  6000.]\n [60000. 60000. 60000. 60000. 25000. 15000.  5000.  6000.  6000.]]\n>>> dampings\n[[3000. 3000. 3000. 3000. 3000. 3000. 3000. 1000. 1000.]\n [3000. 3000. 3000. 3000. 3000. 3000. 3000. 1000. 1000.]\n [3000. 3000. 3000. 3000. 3000. 3000. 3000. 1000. 1000.]\n [3000. 3000. 3000. 3000. 3000. 3000. 3000. 1000. 1000.]\n [3000. 3000. 3000. 3000. 3000. 3000. 3000. 1000. 1000.]]\n>>>\n>>> # get finger joints stiffness and damping: panda_finger_joint1 (7) and panda_finger_joint2 (8)\n>>> # for the first, middle and last of the 5 envs. Returned shape is (3, 2)\n>>> stiffnesses, dampings = prims.get_gains(indices=np.array([0, 2, 4]), joint_indices=np.array([7, 8]))\n>>> stiffnesses\n[[6000. 6000.]\n [6000. 6000.]\n [6000. 6000.]]\n>>> dampings\n[[1000. 1000.]\n [1000. 1000.]\n [1000. 1000.]]\n```\n",
"snippet":"gains = articulation_view.get_gains()\n",
"category":"method"
},
{
"title":"get_generalized_gravity_forces",
"description":"Get the generalized gravity forces (joint DOF forces required to counteract gravitational\nforces for the given articulation pose) of articulations in the view\n\nSearch for *Generalized Gravity Force* in for more details\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `joint_indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): joint indices to specify which joints to query. Shape (K,). Where K \\<= num of dofs. Defaults to None (i.e: all dofs).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: generalized gravity forces of articulations in the view.\n    Shape is (M, K).\n\n---\n**Example:**\n\n```python\n>>>\n\n>>> # get all generalized gravity forces. Returned shape is (5, 9) for the example: 5 envs, 9 DOFs\n>>> prims.get_generalized_gravity_forces()\n[[ 1.32438602e-08 -6.90832138e+00 -1.08629465e-05  1.91585541e+01  5.13810664e-06\n   1.18674076e+00  8.01788883e-06  5.18786255e-03 -5.18784765e-03]\n [ 1.32438602e-08 -6.90832138e+00 -1.08629465e-05  1.91585541e+01  5.13810664e-06\n   1.18674076e+00  8.01788883e-06  5.18786255e-03 -5.18784765e-03]\n [ 1.32438585e-08 -6.90830994e+00 -1.08778477e-05  1.91585541e+01  5.14090061e-06\n   1.18674052e+00  8.02161412e-06  5.18786255e-03 -5.18784765e-03]\n [ 1.32438585e-08 -6.90830994e+00 -1.08778477e-05  1.91585541e+01  5.14090061e-06\n   1.18674052e+00  8.02161412e-06  5.18786255e-03 -5.18784765e-03]\n [ 1.32438602e-08 -6.90832138e+00 -1.08629465e-05  1.91585541e+01  5.13810664e-06\n   1.18674076e+00  8.01788883e-06  5.18786255e-03 -5.18784765e-03]]\n>>>\n>>> # get finger joint generalized gravity forces: panda_finger_joint1 (7) and panda_finger_joint2 (8)\n>>> # for the first, middle and last of the 5 envs. Returned shape is (3, 2)\n>>> prims.get_generalized_gravity_forces(indices=np.array([0, 2, 4]), joint_indices=np.array([7, 8]))\n[[ 0.00518786 -0.00518785]\n [ 0.00518786 -0.00518785]\n [ 0.00518786 -0.00518785]]\n```\n",
"snippet":"generalized_gravity_forces = articulation_view.get_generalized_gravity_forces()\n",
"category":"method"
},
{
"title":"get_jacobian_shape",
"description":"Get the Jacobian matrix shape of a single articulation\n\nThe Jacobian matrix maps the joint space velocities of a DOF to it's cartesian and angular velocities\n\nThe shape of the Jacobian depends on the number of links (rigid bodies), DOFs,\nand whether the articulation base is fixed (e.g., robotic manipulators) or not (e.g,. mobile robots).\n\n-   Fixed articulation base: `(num_bodies - 1, 6, num_dof)`\n-   Non-fixed articulation base: `(num_bodies, 6, num_dof + 6)`\n\nEach body has 6 values in the Jacobian representing its linear and angular motion along the\nthree coordinate axes. The extra 6 DOFs in the last dimension, for non-fixed base cases,\ncorrespond to the linear and angular degrees of freedom of the free root link\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.array\\]: shape of jacobian for a single articulation.\n\n---\n**Example:**\n\n```python\n>>> # for the Franka Panda (a robotic manipulator with fixed base):\n>>> # - num_bodies: 12\n>>> # - num_dof: 9\n>>> prims.get_jacobian_shape()\n(11, 6, 9)\n```\n",
"snippet":"jacobian_shape = articulation_view.get_jacobian_shape()\n",
"category":"method"
},
{
"title":"get_jacobians",
"description":"Get the Jacobian matrices of articulations in the view\n\n*Note:*\nThe first dimension corresponds to the amount of wrapped articulations while the last 3 dimensions are the\nJacobian matrix shape. Refer to the `get_jacobian_shape` method for details about the Jacobian matrix shape\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: Jacobian matrices of articulations in the view.\n    Shape is (M, jacobian\\_shape).\n\n---\n**Example:**\n\n```python\n>>> # get the Jacobian matrices. Returned shape is (5, 11, 6, 9) for the example: 5 envs, 12 links, 9 DOFs\n>>> prims.get_jacobians()\n[[[[ 4.2254178e-09  0.0000000e+00  0.0000000e+00 ...  0.0000000e+00  0.0000000e+00  0.0000000e+00]\n   [ 1.2093576e-08  0.0000000e+00  0.0000000e+00 ...  0.0000000e+00  0.0000000e+00  0.0000000e+00]\n   [-6.0873992e-16  0.0000000e+00  0.0000000e+00 ...  0.0000000e+00  0.0000000e+00  0.0000000e+00]\n   [ 1.4458647e-07  0.0000000e+00  0.0000000e+00 ...  0.0000000e+00  0.0000000e+00  0.0000000e+00]\n   [-1.8178657e-10  0.0000000e+00  0.0000000e+00 ...  0.0000000e+00  0.0000000e+00  0.0000000e+00]\n   [ 9.9999976e-01  0.0000000e+00  0.0000000e+00 ...  0.0000000e+00  0.0000000e+00  0.0000000e+00]]\n  ...\n  [[-4.5089945e-02  8.1210062e-02 -3.8495898e-02 ...  2.8108317e-02  0.0000000e+00 -4.9317405e-02]\n   [ 4.2863289e-01  9.7436900e-04  4.0475106e-01 ...  2.4577195e-03  0.0000000e+00  9.9807423e-01]\n   [ 6.5973169e-09 -4.2914307e-01 -2.1542320e-02 ...  2.8352857e-02  0.0000000e+00 -3.7625343e-02]\n   [ 1.4458647e-07 -1.1999309e-02 -5.3927803e-01 ...  7.0976764e-01  0.0000000e+00  0.0000000e+00]\n   [-1.8178657e-10  9.9992776e-01 -6.4710006e-03 ...  8.5178167e-03  0.0000000e+00  0.0000000e+00]\n   [ 9.9999976e-01 -3.8743019e-07  8.4210289e-01 ... -7.0438433e-01  0.0000000e+00  0.0000000e+00]]]]\n```\n",
"snippet":"jacobians = articulation_view.get_jacobians()\n",
"category":"method"
},
{
"title":"get_joint_index",
"description":"Get a joint index in the joint buffers given its name\n\n**Args:**\n\n * `joint_name` (str): name of the joint that corresponds to the index of the joint in the articulation\n\n**Returns:**\n\n * int: index of the joint in the joint buffers\n",
"snippet":"joint_index = articulation_view.get_joint_index(joint_name=joint_name)\n",
"category":"method"
},
{
"title":"get_joint_positions",
"description":"Get the joint positions of articulations in the view\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `joint_indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): joint indices to specify which joints to query. Shape (K,). Where K \\<= num of dofs. Defaults to None (i.e: all dofs).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: joint positions of articulations in the view.\n    Shape is (M, K).\n\n---\n**Example:**\n\n```python\n>>> # get all joint positions. Returned shape is (5, 9) for the example: 5 envs, 9 DOFs\n>>> prims.get_joint_positions()\n[[ 1.1999921e-02 -5.6962633e-01  1.3219320e-08 -2.8105433e+00  6.8276213e-06\n   3.0301569e+00  7.3234755e-01  3.9912373e-02  3.9999999e-02]\n [ 1.1999921e-02 -5.6962633e-01  1.3219320e-08 -2.8105433e+00  6.8276213e-06\n   3.0301569e+00  7.3234755e-01  3.9912373e-02  3.9999999e-02]\n [ 1.1999921e-02 -5.6962633e-01  1.3220056e-08 -2.8105433e+00  6.8276104e-06\n   3.0301569e+00  7.3234755e-01  3.9912373e-02  3.9999999e-02]\n [ 1.1999921e-02 -5.6962633e-01  1.3220056e-08 -2.8105433e+00  6.8276104e-06\n   3.0301569e+00  7.3234755e-01  3.9912373e-02  3.9999999e-02]\n [ 1.1999921e-02 -5.6962633e-01  1.3219320e-08 -2.8105433e+00  6.8276213e-06\n   3.0301569e+00  7.3234755e-01  3.9912373e-02  3.9999999e-02]]\n>>>\n>>> # get finger joint positions: panda_finger_joint1 (7) and panda_finger_joint2 (8)\n>>> # for the first, middle and last of the 5 envs. Returned shape is (3, 2)\n>>> prims.get_joint_positions(indices=np.array([0, 2, 4]), joint_indices=np.array([7, 8]))\n[[0.03991237 0.04      ]\n [0.03991237 0.04      ]\n [0.03991237 0.04      ]]\n```\n",
"snippet":"joint_positions = articulation_view.get_joint_positions()\n",
"category":"method"
},
{
"title":"get_joint_velocities",
"description":"Get the joint velocities of articulations in the view\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `joint_indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): joint indices to specify which joints to query. Shape (K,). Where K \\<= num of dofs. Defaults to None (i.e: all dofs).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: joint velocities of articulations in the view.\n    Shape is (M, K).\n\n---\n**Example:**\n\n```python\n>>> # get all joint velocities. Returned shape is (5, 9) for the example: 5 envs, 9 DOFs\n>>> prims.get_joint_velocities()\n[[ 1.9010375e-06 -7.6763844e-03 -2.1396865e-07  1.1063669e-02 -4.6333633e-05\n   3.4824573e-02  8.8469200e-02  5.4033857e-04  1.0287426e-05]\n [ 1.9010375e-06 -7.6763844e-03 -2.1396865e-07  1.1063669e-02 -4.6333633e-05\n   3.4824573e-02  8.8469200e-02  5.4033857e-04  1.0287426e-05]\n [ 1.9010074e-06 -7.6763779e-03 -2.1403629e-07  1.1063648e-02 -4.6333400e-05\n   3.4824558e-02  8.8469170e-02  5.4033566e-04  1.0287110e-05]\n [ 1.9010074e-06 -7.6763779e-03 -2.1403629e-07  1.1063648e-02 -4.6333400e-05\n   3.4824558e-02  8.8469170e-02  5.4033566e-04  1.0287110e-05]\n [ 1.9010375e-06 -7.6763844e-03 -2.1396865e-07  1.1063669e-02 -4.6333633e-05\n   3.4824573e-02  8.8469200e-02  5.4033857e-04  1.0287426e-05]]\n>>>\n>>> # get finger joint velocities: panda_finger_joint1 (7) and panda_finger_joint2 (8)\n>>> # for the first, middle and last of the 5 envs. Returned shape is (3, 2)\n>>> prims.get_joint_velocities(indices=np.array([0, 2, 4]), joint_indices=np.array([7, 8]))\n[[5.4033857e-04 1.0287426e-05]\n [5.4033566e-04 1.0287110e-05]\n [5.4033857e-04 1.0287426e-05]]\n```\n",
"snippet":"joint_velocities = articulation_view.get_joint_velocities()\n",
"category":"method"
},
{
"title":"get_joints_default_state",
"description":"Get the default joint states defined with the `set_joints_default_state` method\n\n**Returns:**\n\n * JointsState: an object that contains the default joint states\n\n---\n**Example:**\n\n```python\n>>> # returned shape is (5, 9) for the example: 5 envs, 9 DOFs\n>>> states = prims.get_joints_default_state()\n>>> states\n<omni.isaac.core.utils.types.JointsState object at 0x7fc2c174fd90>\n>>> states.positions\n[[ 0.   -1.    0.   -2.2   0.    2.4   0.8   0.04  0.04]\n [ 0.   -1.    0.   -2.2   0.    2.4   0.8   0.04  0.04]\n [ 0.   -1.    0.   -2.2   0.    2.4   0.8   0.04  0.04]\n [ 0.   -1.    0.   -2.2   0.    2.4   0.8   0.04  0.04]\n [ 0.   -1.    0.   -2.2   0.    2.4   0.8   0.04  0.04]]\n>>> states.velocities\n[[0. 0. 0. 0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0. 0. 0. 0.]]\n>>> states.efforts\n[[0. 0. 0. 0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0. 0. 0. 0.]]\n```\n",
"snippet":"joints_default_state = articulation_view.get_joints_default_state()\n",
"category":"method"
},
{
"title":"get_joints_state",
"description":"Get the current joint states (positions and velocities)\n\n**Returns:**\n\n * JointsState: an object that contains the current joint positions and velocities\n\n---\n**Example:**\n\n```python\n>>> # returned shape is (5, 9) for the example: 5 envs, 9 DOFs\n>>> states = prims.get_joints_state()\n>>> states\n<omni.isaac.core.utils.types.JointsState object at 0x7fc1a23a82e0>\n>>> states.positions\n[[ 1.1999921e-02 -5.6962633e-01  1.3219320e-08 -2.8105433e+00  6.8276213e-06\n   3.0301569e+00  7.3234755e-01  3.9912373e-02  3.9999999e-02]\n [ 1.1999921e-02 -5.6962633e-01  1.3219320e-08 -2.8105433e+00  6.8276213e-06\n   3.0301569e+00  7.3234755e-01  3.9912373e-02  3.9999999e-02]\n [ 1.1999921e-02 -5.6962633e-01  1.3220056e-08 -2.8105433e+00  6.8276104e-06\n   3.0301569e+00  7.3234755e-01  3.9912373e-02  3.9999999e-02]\n [ 1.1999921e-02 -5.6962633e-01  1.3220056e-08 -2.8105433e+00  6.8276104e-06\n   3.0301569e+00  7.3234755e-01  3.9912373e-02  3.9999999e-02]\n [ 1.1999921e-02 -5.6962633e-01  1.3219320e-08 -2.8105433e+00  6.8276213e-06\n   3.0301569e+00  7.3234755e-01  3.9912373e-02  3.9999999e-02]]\n>>> states.velocities\n[[ 1.9010375e-06 -7.6763844e-03 -2.1396865e-07  1.1063669e-02 -4.6333633e-05\n   3.4824573e-02  8.8469200e-02  5.4033857e-04  1.0287426e-05]\n [ 1.9010375e-06 -7.6763844e-03 -2.1396865e-07  1.1063669e-02 -4.6333633e-05\n   3.4824573e-02  8.8469200e-02  5.4033857e-04  1.0287426e-05]\n [ 1.9010074e-06 -7.6763779e-03 -2.1403629e-07  1.1063648e-02 -4.6333400e-05\n   3.4824558e-02  8.8469170e-02  5.4033566e-04  1.0287110e-05]\n [ 1.9010074e-06 -7.6763779e-03 -2.1403629e-07  1.1063648e-02 -4.6333400e-05\n   3.4824558e-02  8.8469170e-02  5.4033566e-04  1.0287110e-05]\n [ 1.9010375e-06 -7.6763844e-03 -2.1396865e-07  1.1063669e-02 -4.6333633e-05\n   3.4824573e-02  8.8469200e-02  5.4033857e-04  1.0287426e-05]]\n```\n",
"snippet":"joints_state = articulation_view.get_joints_state()\n",
"category":"method"
},
{
"title":"get_linear_velocities",
"description":"Get the linear velocities of prims in the view.\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view)\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: linear velocities of the prims in the view. shape is (M, 3).\n\n---\n**Example:**\n\n```python\n>>> # get all articulation linear velocities. Returned shape is (5, 3) for the example: 5 envs, linear (3)\n>>> prims.get_linear_velocities()\n[[0. 0. 0.]\n [0. 0. 0.]\n [0. 0. 0.]\n [0. 0. 0.]\n [0. 0. 0.]]\n>>>\n>>> # get only the articulation linear velocities for the first, middle and last of the 5 envs.\n>>> # Returned shape is (3, 3) for the example: 3 envs selected, linear (3)\n>>> prims.get_linear_velocities(indices=np.array([0, 2, 4]))\n[[0. 0. 0.]\n [0. 0. 0.]\n [0. 0. 0.]]\n```\n",
"snippet":"linear_velocities = articulation_view.get_linear_velocities()\n",
"category":"method"
},
{
"title":"get_link_index",
"description":"Get a link index in the link buffers given its name\n\n**Args:**\n\n * `link_name` (str): name of the link that corresponds to the index of the link in the articulation\n\n**Returns:**\n\n * int: index of the link in the link buffers\n",
"snippet":"link_index = articulation_view.get_link_index(link_name=link_name)\n",
"category":"method"
},
{
"title":"get_local_poses",
"description":"Get prim poses in the view with respect to the local frame (the prim's parent frame).\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view)\n\n**Returns:**\n\n * Union\\[Tuple\\[np.ndarray, np.ndarray\\], Tuple\\[torch.Tensor, torch.Tensor\\], Tuple\\[wp.indexedarray, wp.indexedarray\\]\\]:\n    first index is positions in the local frame of the prims. shape is (M, 3). Second index is quaternion orientations\n    in the local frame of the prims. Quaternion is scalar-first (w, x, y, z). shape is (M, 4).\n\n---\n**Example:**\n\n```python\n>>> # get all articulation poses with respect to the local frame.\n>>> # Returned shape is position (5, 3) and orientation (5, 4) for the example: 5 envs\n>>> positions, orientations = prims.get_local_poses()\n>>> positions\n[[ 0.0000000e+00  0.0000000e+00 -2.8610229e-08]\n [ 0.0000000e+00  0.0000000e+00 -2.8610229e-08]\n [-4.5299529e-08  0.0000000e+00 -2.8610229e-08]\n [-4.5299529e-08  0.0000000e+00 -2.8610229e-08]\n [ 0.0000000e+00  0.0000000e+00 -2.8610229e-08]]\n>>> orientations\n[[1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]]\n>>>\n>>> # get only the articulation poses with respect to the local frame for the first, middle and last of the 5 envs.\n>>> # Returned shape is position (3, 3) and orientation (3, 4) for the example: 3 envs selected\n>>> positions, orientations = prims.get_local_poses(indices=np.array([0, 2, 4]))\n>>> positions\n[[ 0.0000000e+00  0.0000000e+00 -2.8610229e-08]\n [-4.5299529e-08  0.0000000e+00 -2.8610229e-08]\n [ 0.0000000e+00  0.0000000e+00 -2.8610229e-08]]\n>>> orientations\n[[1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]]\n```\n",
"snippet":"local_poses = articulation_view.get_local_poses()\n",
"category":"method"
},
{
"title":"get_local_poses",
"description":"Get prim poses in the view with respect to the local frame (the prim's parent frame)\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Returns:**\n\n * Union\\[Tuple\\[np.ndarray, np.ndarray\\], Tuple\\[torch.Tensor, torch.Tensor\\], Tuple\\[wp.indexedarray, wp.indexedarray\\]\\]: first index is translations in the local frame of the prims. shape is (M, 3). second index is quaternion orientations in the local frame of the prims. quaternion is scalar-first (w, x, y, z). shape is (M, 4).\n\n---\n**Example:**\n\n```python\n>>> # get all prims poses with respect to the local frame.\n>>> # Returned shape is position (5, 3) and orientation (5, 4) for the example: 5 envs\n>>> positions, orientations = prims.get_local_poses()\n>>> positions\n[[ 1.5  -0.75  0.  ]\n [ 1.5   0.75  0.  ]\n [ 0.   -0.75  0.  ]\n [ 0.    0.75  0.  ]\n [-1.5  -0.75  0.  ]]\n>>> orientations\n[[1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]]\n>>>\n>>> # get only the prims poses with respect to the local frame for the first, middle and last of the 5 envs.\n>>> # Returned shape is position (3, 3) and orientation (3, 4) for the example: 3 envs selected\n>>> positions, orientations = prims.get_local_poses(indices=np.array([0, 2, 4]))\n>>> positions\n[[ 1.5  -0.75  0.  ]\n [ 0.   -0.75  0.  ]\n [-1.5  -0.75  0.  ]]\n>>> orientations\n[[1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]]\n```\n",
"snippet":"local_poses = articulation_view.get_local_poses()\n",
"category":"method"
},
{
"title":"get_local_scales",
"description":"Get prim scales in the view with respect to the local frame (the parent's frame).\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: scales applied to the prim's dimensions in the local frame. shape is (M, 3).\n\n---\n**Example:**\n\n```python\n>>> # get all prims scales with respect to the local frame.\n>>> # Returned shape is (5, 3) for the example: 5 envs\n>>> prims.get_local_scales()\n[[1. 1. 1.]\n [1. 1. 1.]\n [1. 1. 1.]\n [1. 1. 1.]\n [1. 1. 1.]]\n>>>\n>>> # get only the prims scales with respect to the local frame for the first, middle and last of the 5 envs.\n>>> # Returned shape is (3, 3) for the example: 3 envs selected\n>>> prims.get_local_scales(indices=np.array([0, 2, 4]))\n[[1. 1. 1.]\n [1. 1. 1.]\n [1. 1. 1.]]\n```\n",
"snippet":"local_scales = articulation_view.get_local_scales()\n",
"category":"method"
},
{
"title":"get_mass_matrices",
"description":"Get the mass matrices of articulations in the view\n\n*Note:*\nThe first dimension corresponds to the amount of wrapped articulations while the last 2 dimensions are the\nmass matrix shape. Refer to the `get_mass_matrix_shape` method for details about the mass matrix shape\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: mass matrices of articulations in the view.\n    Shape is (M, mass\\_matrix\\_shape).\n\n---\n**Example:**\n\n```python\n>>> # get the mass matrices. Returned shape is (5, 9, 9) for the example: 5 envs, 9 DOFs\n>>> prims.get_mass_matrices()\n[[[ 5.0900602e-01  1.1794259e-06  4.2570841e-01 -1.6387942e-06 -3.1573933e-02\n   -1.9736715e-06 -3.1358242e-04 -6.0441834e-03  6.0441834e-03]\n  [ 1.1794259e-06  1.0598221e+00  7.4729815e-07 -4.2621672e-01  2.3612277e-08\n   -4.9647894e-02 -2.9080724e-07 -1.8432185e-04  1.8432130e-04]\n  ...\n  [-6.0441834e-03 -1.8432185e-04 -5.7159867e-03  4.0070520e-04  9.6930371e-04 1.2324301e-04  2.5264668e-10  1.4055224e-02  0.0000000e+00]\n  [ 6.0441834e-03  1.8432130e-04  5.7159867e-03 -4.0070404e-04 -9.6930366e-04\n   -1.2324269e-04 -3.6906206e-10  0.0000000e+00  1.4055224e-02]]]\n```\n",
"snippet":"mass_matrices = articulation_view.get_mass_matrices()\n",
"category":"method"
},
{
"title":"get_mass_matrix_shape",
"description":"Get the mass matrix shape of a single articulation\n\nThe mass matrix contains the generalized mass of the robot depending on the current configuration\n\nThe shape of the max matrix depends on the number of DOFs: `(num_dof, num_dof)`\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.array\\]: shape of mass matrix for a single articulation.\n\n---\n**Example:**\n\n```python\n>>> # for the Franka Panda:\n>>> # - num_dof: 9\n>>> prims.get_jacobian_shape()\n(9, 9)\n```\n",
"snippet":"mass_matrix_shape = articulation_view.get_mass_matrix_shape()\n",
"category":"method"
},
{
"title":"get_max_efforts",
"description":"Get the maximum efforts for articulation in the view\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `joint_indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): joint indices to specify which joints to query. Shape (K,). Where K \\<= num of dofs. Defaults to None (i.e: all dofs).\n * `clone` (Optional\\[bool\\]): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: maximum efforts for articulations in the view. shape (M, K).\n\n---\n**Example:**\n\n```python\n>>> # get all joint maximum efforts. Returned shape is (5, 9) for the example: 5 envs, 9 DOFs\n>>> prims.get_max_efforts()\n[[5220. 5220. 5220. 5220.  720.  720.  720.  720.  720.]\n [5220. 5220. 5220. 5220.  720.  720.  720.  720.  720.]\n [5220. 5220. 5220. 5220.  720.  720.  720.  720.  720.]\n [5220. 5220. 5220. 5220.  720.  720.  720.  720.  720.]\n [5220. 5220. 5220. 5220.  720.  720.  720.  720.  720.]]\n>>>\n>>> # get finger joint maximum efforts: panda_finger_joint1 (7) and panda_finger_joint2 (8)\n>>> # for the first, middle and last of the 5 envs. Returned shape is (3, 2)\n>>> prims.get_max_efforts(indices=np.array([0, 2, 4]), joint_indices=np.array([7, 8]))\n[[720. 720.]\n [720. 720.]\n [720. 720.]]\n```\n",
"snippet":"max_efforts = articulation_view.get_max_efforts()\n",
"category":"method"
},
{
"title":"get_measured_joint_efforts",
"description":"Returns the efforts computed/measured by the physics solver of the joint forces in the DOF motion direction\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `joint_indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor\\]\\], optional): joint indices to specify which joints to query. Shape (K,). Where K \\<= num of dofs. Defaults to None (i.e: all dofs).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor\\]: computed joint efforts of articulations in the view. shape is (M, K).\n\n---\n**Example:**\n\n```python\n>>> # get all measured joint efforts. Returned shape is (5, 9) for the example: 5 envs, 9 DOFs\n>>> prims.get_measured_joint_efforts()\n[[ 4.8250298e-05 -6.9073005e+00  5.3364405e-05  1.9157070e+01 -5.8759182e-05\n   1.1863427e+00 -5.6388220e-05  5.1680300e-03 -5.1910817e-03]\n [ 4.8250298e-05 -6.9073005e+00  5.3364405e-05  1.9157070e+01 -5.8759182e-05\n   1.1863427e+00 -5.6388220e-05  5.1680300e-03 -5.1910817e-03]\n [ 4.8254540e-05 -6.9072919e+00  5.3344327e-05  1.9157072e+01 -5.8761045e-05\n   1.1863427e+00 -5.6405144e-05  5.1680212e-03 -5.1910840e-03]\n [ 4.8254540e-05 -6.9072919e+00  5.3344327e-05  1.9157072e+01 -5.8761045e-05\n   1.1863427e+00 -5.6405144e-05  5.1680212e-03 -5.1910840e-03]\n [ 4.8250298e-05 -6.9073005e+00  5.3364405e-05  1.9157070e+01 -5.8759182e-05\n   1.1863427e+00 -5.6388220e-05  5.1680300e-03  -5.1910817e-03]]\n>>>\n>>> # get finger measured joint efforts: panda_finger_joint1 (7) and panda_finger_joint2 (8)\n>>> # for the first, middle and last of the 5 envs. Returned shape is (3, 2)\n>>> prims.get_measured_joint_efforts(indices=np.array([0, 2, 4]), joint_indices=np.array([7, 8]))\n[[ 0.00516803 -0.00519108]\n [ 0.00516802 -0.00519108]\n [ 0.00516803 -0.00519108]]\n```\n",
"snippet":"measured_joint_efforts = articulation_view.get_measured_joint_efforts()\n",
"category":"method"
},
{
"title":"get_measured_joint_forces",
"description":"Get the measured joint reaction forces and torques (link incoming joint forces and torques) to external loads\n\n*Note:*\nSince the *name-\\>index* map for joints has not been exposed yet,\nit is possible to access the joint names and their indices through the articulation metadata.\n\n> ```python\n> ```\n>\n> prims.\\_metadata.joint\\_names \\# list of names prims.\\_metadata.joint\\_indices \\# dict of name: index\n>\n> To retrieve a specific row for the link incoming joint force/torque use `joint_index + 1`\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `joint_indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor\\]\\], optional): link indices to specify which link's incoming joints to query. Shape (K,). Where K \\<= num of links/bodies. Defaults to None (i.e: all dofs).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor\\]: joint forces and torques of articulations in the view.\n    Shape is (M, num\\_joint + 1, 6). Column index 0 is the incoming joint of the base link.\n    For the last dimension the first 3 values are for forces and the last 3 for torques\n\n---\n**Example:**\n\n```python\n>>> # get all measured joint forces and torques. Returned shape is (5, 12, 6) for the example:\n>>> # 5 envs, 9 DOFs (but 12 joints including the fixed and root joints)\n>>> prims.get_measured_joint_forces()\n[[[ 0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00]\n  [ 1.49950760e+02  3.52353277e-06  5.62586996e-04  4.82502983e-05 -6.90729856e+00  2.69259126e-05]\n  [-2.60467059e-05 -1.06778236e+02 -6.83844986e+01 -6.90730047e+00 -5.27759657e-05 -1.24897576e-06]\n  [ 8.71209946e+01 -4.46646191e-05 -5.57951622e+01  5.33644052e-05 -2.45385647e+01  1.38957939e-05]\n  [ 5.18576926e-05 -4.81099091e+01  6.07092705e+01  1.91570702e+01 -5.81023924e-05  1.46875891e-06]\n  [-3.16910419e+01  2.31799815e-04  3.99901695e+01 -5.87591821e-05 -1.18634319e+00  2.24427877e-05]\n  [-1.07621672e-04  1.53405371e+01 -1.54584875e+01  1.18634272e+00  6.09036942e-05 -1.60679410e-05]\n  [-7.54189777e+00 -5.08146524e+00 -5.65130091e+00 -5.63882204e-05  3.88599992e-01 -3.49432468e-01]\n  [ 4.74214745e+00 -3.19458222e+00  3.55281782e+00  5.58562024e-05  8.47946014e-03  7.64050474e-03]\n  [ 4.07607269e+00  2.16406956e-01 -4.05131817e+00 -5.95658377e-04  1.14070829e-02  2.13965313e-06]\n  [ 5.16803004e-03 -9.77545828e-02 -9.70939621e-02 -8.41282599e-12 -1.29066744e-12 -1.93477560e-11]\n  [-5.19108167e-03  9.75882635e-02 -9.71064270e-02  8.41282859e-12  1.29066018e-12 -1.93477543e-11]]\n ...\n [[ 0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00]\n  [ 1.49950760e+02  3.52353277e-06  5.62586996e-04  4.82502983e-05 -6.90729856e+00  2.69259126e-05]\n  [-2.60467059e-05 -1.06778236e+02 -6.83844986e+01 -6.90730047e+00 -5.27759657e-05 -1.24897576e-06]\n  [ 8.71209946e+01 -4.46646191e-05 -5.57951622e+01  5.33644052e-05 -2.45385647e+01  1.38957939e-05]\n  [ 5.18576926e-05 -4.81099091e+01  6.07092705e+01  1.91570702e+01 -5.81023924e-05  1.46875891e-06]\n  [-3.16910419e+01  2.31799815e-04  3.99901695e+01 -5.87591821e-05 -1.18634319e+00  2.24427877e-05]\n  [-1.07621672e-04  1.53405371e+01 -1.54584875e+01  1.18634272e+00  6.09036942e-05 -1.60679410e-05]\n  [-7.54189777e+00 -5.08146524e+00 -5.65130091e+00 -5.63882204e-05  3.88599992e-01 -3.49432468e-01]\n  [ 4.74214745e+00 -3.19458222e+00  3.55281782e+00  5.58562024e-05  8.47946014e-03  7.64050474e-03]\n  [ 4.07607269e+00  2.16406956e-01 -4.05131817e+00 -5.95658377e-04  1.14070829e-02  2.13965313e-06]\n  [ 5.16803004e-03 -9.77545828e-02 -9.70939621e-02 -8.41282599e-12 -1.29066744e-12 -1.93477560e-11]\n  [-5.19108167e-03  9.75882635e-02 -9.71064270e-02  8.41282859e-12  1.29066018e-12 -1.93477543e-11]]]\n>>>\n>>> # get measured joint forces and torques for the fingers for the first, middle and last of the 5 envs.\n>>> # Returned shape is (3, 2, 6)\n>>> metadata = prims._metadata\n>>> joint_indices = 1 + np.array([\n>>>     metadata.joint_indices[\"panda_finger_joint1\"],\n>>>     metadata.joint_indices[\"panda_finger_joint2\"],\n>>> ])\n>>> joint_indices\n[10 11]\n>>> prims.get_measured_joint_forces(indices=np.array([0, 2, 4]), joint_indices=joint_indices)\n[[[ 5.1680300e-03 -9.7754583e-02 -9.7093962e-02 -8.4128260e-12 -1.2906674e-12 -1.9347756e-11]\n  [-5.1910817e-03  9.7588263e-02 -9.7106427e-02  8.4128286e-12  1.2906602e-12 -1.9347754e-11]]\n [[ 5.1680212e-03 -9.7754560e-02 -9.7093947e-02 -8.4141834e-12 -1.2907383e-12 -1.9348209e-11]\n  [-5.1910840e-03  9.7588278e-02 -9.7106412e-02  8.4141869e-12  1.2907335e-12 -1.9348207e-11]]\n [[ 5.1680300e-03 -9.7754583e-02 -9.7093962e-02 -8.4128260e-12 -1.2906674e-12 -1.9347756e-11]\n  [-5.1910817e-03  9.7588263e-02 -9.7106427e-02  8.4128286e-12  1.2906602e-12 -1.9347754e-11]]]\n```\n",
"snippet":"measured_joint_forces = articulation_view.get_measured_joint_forces()\n",
"category":"method"
},
{
"title":"get_sleep_thresholds",
"description":"Get the threshold for articulations to enter a sleep state\n\nSearch for *Articulations and Sleeping* in for more details\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: sleep thresholds. shape (M,).\n\n---\n**Example:**\n\n```python\n>>> # get all sleep thresholds. Returned shape is (5,) for the example: 5 envs\n>>> prims.get_sleep_thresholds()\n[0.005 0.005 0.005 0.005 0.005]\n>>>\n>>> # get the sleep thresholds for the first, middle and last of the 5 envs. Returned shape is (3,)\n>>> prims.get_sleep_thresholds(indices=np.array([0, 2, 4]))\n[0.005 0.005 0.005]\n```\n",
"snippet":"sleep_thresholds = articulation_view.get_sleep_thresholds()\n",
"category":"method"
},
{
"title":"get_solver_position_iteration_counts",
"description":"Get the solver (position) iteration count for the articulations\n\nThe solver iteration count determines how accurately contacts, drives, and limits are resolved.\nSearch for *Solver Iteration Count* in for more details.\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: position iteration count. Shape (M,).\n\n---\n**Example:**\n\n```python\n>>> # get all position iteration count. Returned shape is (5,) for the example: 5 envs\n>>> prims.get_solver_position_iteration_counts()\n[32 32 32 32 32]\n>>>\n>>> # get the position iteration count for the first, middle and last of the 5 envs. Returned shape is (3,)\n>>> prims.get_solver_position_iteration_counts(indices=np.array([0, 2, 4]))\n[32 32 32]\n```\n",
"snippet":"solver_position_iteration_counts = articulation_view.get_solver_position_iteration_counts()\n",
"category":"method"
},
{
"title":"get_solver_velocity_iteration_counts",
"description":"Get the solver (velocity) iteration count for the articulations\n\nThe solver iteration count determines how accurately contacts, drives, and limits are resolved.\nSearch for *Solver Iteration Count* in for more details.\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: velocity iteration count. Shape (M,).\n\n---\n**Example:**\n\n```python\n>>> # get all velocity iteration count. Returned shape is (5,) for the example: 5 envs\n>>> prims.get_solver_velocity_iteration_counts()\n[32 32 32 32 32]\n>>>\n>>> # get the velocity iteration count for the first, middle and last of the 5 envs. Returned shape is (3,)\n>>> prims.get_solver_velocity_iteration_counts(indices=np.array([0, 2, 4]))\n[32 32 32]\n```\n",
"snippet":"solver_velocity_iteration_counts = articulation_view.get_solver_velocity_iteration_counts()\n",
"category":"method"
},
{
"title":"get_stabilization_thresholds",
"description":"Get the mass-normalized kinetic energy below which the articulations may participate in stabilization\n\nSearch for *Stabilization Threshold* in for more details\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: stabilization threshold. Shape (M,).\n\n---\n**Example:**\n\n```python\n>>> # get all stabilization thresholds. Returned shape is (5,) for the example: 5 envs\n>>> prims.get_solver_velocity_iteration_counts()\n[0.001 0.001 0.001 0.001 0.001]\n>>>\n>>> # get the stabilization thresholds for the first, middle and last of the 5 envs. Returned shape is (3,)\n>>> prims.get_solver_velocity_iteration_counts(indices=np.array([0, 2, 4]))\n[0.001 0.001 0.001]\n```\n",
"snippet":"stabilization_thresholds = articulation_view.get_stabilization_thresholds()\n",
"category":"method"
},
{
"title":"get_velocities",
"description":"Get the linear and angular velocities of prims in the view.\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view)\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: linear and angular velocities of the prims in the view concatenated. shape is (M, 6).\n    For the last dimension the first 3 values are for linear velocities and the last 3 for angular velocities\n\n---\n**Example:**\n\n```python\n>>> # get all articulation velocities. Returned shape is (5, 6) for the example: 5 envs, linear (3) and angular (3)\n>>> prims.get_velocities()\n[[0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0.]]\n>>>\n>>> # get only the articulation velocities for the first, middle and last of the 5 envs.\n>>> # Returned shape is (3, 6) for the example: 3 envs selected, linear (3) and angular (3)\n>>> prims.get_velocities(indices=np.array([0, 2, 4]))\n[[0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0.]]\n```\n",
"snippet":"velocities = articulation_view.get_velocities()\n",
"category":"method"
},
{
"title":"get_visibilities",
"description":"Returns the current visibilities of the prims in stage.\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: Shape (M,) with type bool, where each item holds True if the prim is visible in stage. False otherwise.\n\n---\n**Example:**\n\n```python\n>>> # get all visibilities. Returned shape is (5,) for the example: 5 envs\n>>> prims.get_visibilities()\n[ True  True  True  True  True]\n>>>\n>>> # get the visibilities for the first, middle and last of the 5 envs. Returned shape is (3,)\n>>> prims.get_visibilities(indices=np.array([0, 2, 4]))\n[ True  True  True]\n```\n",
"snippet":"visibilities = articulation_view.get_visibilities()\n",
"category":"method"
},
{
"title":"get_world_poses",
"description":"Get the poses of the prims in the view with respect to the world's frame.\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[Tuple\\[np.ndarray, np.ndarray\\], Tuple\\[torch.Tensor, torch.Tensor\\], Tuple\\[wp.indexedarray, wp.indexedarray\\]\\]:\n    first index is positions in the world frame of the prims. shape is (M, 3). Second index is quaternion orientations\n    in the world frame of the prims. Quaternion is scalar-first (w, x, y, z). shape is (M, 4).\n\n---\n**Example:**\n\n```python\n>>> # get all articulation poses with respect to the world's frame.\n>>> # Returned shape is position (5, 3) and orientation (5, 4) for the example: 5 envs\n>>> positions, orientations = prims.get_world_poses()\n>>> positions\n[[ 1.5000000e+00 -7.5000000e-01 -2.8610229e-08]\n [ 1.5000000e+00  7.5000000e-01 -2.8610229e-08]\n [-4.5299529e-08 -7.5000000e-01 -2.8610229e-08]\n [-4.5299529e-08  7.5000000e-01 -2.8610229e-08]\n [-1.5000000e+00 -7.5000000e-01 -2.8610229e-08]]\n>>> orientations\n[[1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]]\n>>>\n>>> # get only the articulation poses with respect to the world's frame for the first, middle and last of the 5 envs.\n>>> # Returned shape is position (3, 3) and orientation (3, 4) for the example: 3 envs selected\n>>> positions, orientations = prims.get_world_poses(indices=np.array([0, 2, 4]))\n>>> positions\n[[ 1.5000000e+00 -7.5000000e-01 -2.8610229e-08]\n [-4.5299529e-08 -7.5000000e-01 -2.8610229e-08]\n [-1.5000000e+00 -7.5000000e-01 -2.8610229e-08]]\n>>> orientations\n[[1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]]\n```\n",
"snippet":"world_poses = articulation_view.get_world_poses()\n",
"category":"method"
},
{
"title":"get_world_poses",
"description":"Get the poses of the prims in the view with respect to the world's frame\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Returns:**\n\n * Union\\[Tuple\\[np.ndarray, np.ndarray\\], Tuple\\[torch.Tensor, torch.Tensor\\], Tuple\\[wp.indexedarray, wp.indexedarray\\]\\]: first index is positions in the world frame of the prims. shape is (M, 3). second index is quaternion orientations in the world frame of the prims. quaternion is scalar-first (w, x, y, z). shape is (M, 4).\n\n---\n**Example:**\n\n```python\n>>> # get all prims poses with respect to the world's frame.\n>>> # Returned shape is position (5, 3) and orientation (5, 4) for the example: 5 envs\n>>> positions, orientations = prims.get_world_poses()\n>>> positions\n[[ 1.5  -0.75  0.  ]\n [ 1.5   0.75  0.  ]\n [ 0.   -0.75  0.  ]\n [ 0.    0.75  0.  ]\n [-1.5  -0.75  0.  ]]\n>>> orientations\n[[1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]]\n>>>\n>>> # get only the prims poses with respect to the world's frame for the first, middle and last of the 5 envs.\n>>> # Returned shape is position (3, 3) and orientation (3, 4) for the example: 3 envs selected\n>>> positions, orientations = prims.get_world_poses(indices=np.array([0, 2, 4]))\n>>> positions\n[[ 1.5  -0.75  0.  ]\n [ 0.   -0.75  0.  ]\n [-1.5  -0.75  0.  ]]\n>>> orientations\n[[1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]]\n```\n",
"snippet":"world_poses = articulation_view.get_world_poses()\n",
"category":"method"
},
{
"title":"get_world_scales",
"description":"Get prim scales in the view with respect to the world's frame\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: scales applied to the prim's dimensions in the world frame. shape is (M, 3).\n\n---\n**Example:**\n\n```python\n>>> # get all prims scales with respect to the world's frame.\n>>> # Returned shape is (5, 3) for the example: 5 envs\n>>> prims.get_world_scales()\n[[1. 1. 1.]\n [1. 1. 1.]\n [1. 1. 1.]\n [1. 1. 1.]\n [1. 1. 1.]]\n>>>\n>>> # get only the prims scales with respect to the world's frame for the first, middle and last of the 5 envs.\n>>> # Returned shape is (3, 3) for the example: 3 envs selected\n>>> prims.get_world_scales(indices=np.array([0, 2, 4]))\n[[1. 1. 1.]\n [1. 1. 1.]\n [1. 1. 1.]]\n```\n",
"snippet":"world_scales = articulation_view.get_world_scales()\n",
"category":"method"
},
{
"title":"initialize",
"description":"Create a physics simulation view if not passed and set other properties using the PhysX tensor API\n\n*Note:*\nIf the articulation view has been added to the world scene (e.g., `world.scene.add(prims)`),\nit will be automatically initialized when the world is reset (e.g., `world.reset()`).\n\n*Warning:*\nThis method needs to be called after each hard reset (e.g., Stop + Play on the timeline)\nbefore interacting with any other class method.\n\n**Args:**\n\n * `physics_sim_view` (omni.physics.tensors.SimulationView, optional): current physics simulation view. Defaults to None.\n\n---\n**Example:**\n\n```python\n>>> prims.initialize()\n```\n",
"snippet":"articulation_view.initialize()\n",
"category":"method"
},
{
"title":"initialize",
"description":"Create a physics simulation view if not passed and set other properties using the PhysX tensor API\n\n*Note:*\nFor this particular class, calling this method will do nothing\n\n**Args:**\n\n * `physics_sim_view` (omni.physics.tensors.SimulationView, optional): current physics simulation view. Defaults to None.\n\n---\n**Example:**\n\n```python\n>>> prims.initialize()\n```\n",
"snippet":"articulation_view.initialize()\n",
"category":"method"
},
{
"title":"initialized",
"description":"Check if articulation view is initialized\n\n**Returns:**\n\n * bool: True if the view object was initialized (after the first call of .initialize()). False otherwise.\n\n---\n**Example:**\n\n```python\n>>> # given an initialized articulation view\n>>> prims.initialized\nTrue\n```\n",
"snippet":"initialized = articulation_view.initialized\n",
"category":"property"
},
{
"title":"is_physics_handle_valid",
"description":"Check if articulation view's physics handler is initialized\n\n*Warning:*\nIf the physics handler is not valid many of the methods that requires PhysX will return None.\n\n**Returns:**\n\n * bool: False if .initialize() needs to be called again for the physics handle to be valid. Otherwise True\n\n---\n**Example:**\n\n```python\n>>> prims.is_physics_handle_valid()\nTrue\n```\n",
"snippet":"value = articulation_view.is_physics_handle_valid()\n",
"category":"method"
},
{
"title":"is_valid",
"description":"Check that all prims have a valid USD Prim\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Returns:**\n\n * bool: True if all prim paths specified in the view correspond to a valid prim in stage. False otherwise.\n\n---\n**Example:**\n\n```python\n>>> prims.is_valid()\nTrue\n```\n",
"snippet":"value = articulation_view.is_valid()\n",
"category":"method"
},
{
"title":"is_visual_material_applied",
"description":"Check if there is a visual material applied\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Returns:**\n\n * List\\[bool\\]: True if there is a visual material applied is applied to the corresponding prim in the view. False otherwise.\n\n---\n**Example:**\n\n```python\n>>> # given a visual material that is applied only to the first and the last environment\n>>> prims.is_visual_material_applied()\n[True, False, False, False, True]\n>>>\n>>> # check for the first, middle and last of the 5 envs\n>>> prims.is_visual_material_applied(indices=np.array([0, 2, 4]))\n[True, False, True]\n```\n",
"snippet":"value = articulation_view.is_visual_material_applied()\n",
"category":"method"
},
{
"title":"joint_names",
"description":"List of prim names for each joint of the articulations\n\n**Returns:**\n\n * List\\[str\\]: ordered names of joints that corresponds to degrees of freedom for the articulations in the view\n",
"snippet":"joint_names = articulation_view.joint_names\n",
"category":"property"
},
{
"title":"num_bodies",
"description":"Number of rigid bodies (links) of the articulations\n\n**Returns:**\n\n * int: maximum number of rigid bodies for the articulations in the view\n\n---\n**Example:**\n\n```python\n>>> prims.num_bodies\n12\n```\n",
"snippet":"num_bodies = articulation_view.num_bodies\n",
"category":"property"
},
{
"title":"num_dof",
"description":"Number of DOF of the articulations\n\n**Returns:**\n\n * int: maximum number of DOFs for the articulations in the view\n\n---\n**Example:**\n\n```python\n>>> prims.num_dof\n9\n```\n",
"snippet":"num_dof = articulation_view.num_dof\n",
"category":"property"
},
{
"title":"num_fixed_tendons",
"description":"Number of fixed tendons of the articulations\n\n**Returns:**\n\n * int: maximum number of fixed tendons for the articulations in the view\n\n---\n**Example:**\n\n```python\n>>> prims.num_fixed_tendons\n0\n```\n",
"snippet":"num_fixed_tendons = articulation_view.num_fixed_tendons\n",
"category":"property"
},
{
"title":"num_joints",
"description":"Number of joints of the articulations\n\n**Returns:**\n\n * int: number of joints of the articulations in the view\n",
"snippet":"num_joints = articulation_view.num_joints\n",
"category":"property"
},
{
"title":"num_shapes",
"description":"Number of rigid shapes of the articulations\n\n**Returns:**\n\n * int: maximum number of rigid shapes for the articulations in the view\n\n---\n**Example:**\n\n```python\n>>> prims.num_shapes\n17\n```\n",
"snippet":"num_shapes = articulation_view.num_shapes\n",
"category":"property"
},
{
"title":"post_reset",
"description":"Reset the articulations to their default states\n\n*Note:*\nFor the articulations, in addition to configuring the root prim's default positions and spatial orientations\n(defined via the `set_default_state` method), the joint's positions, velocities, and efforts\n(defined via the `set_joints_default_state` method) and the joint stiffnesses and dampings\n(defined via the `set_gains` method) are imposed\n\n---\n**Example:**\n\n```python\n>>> prims.post_reset()\n```\n",
"snippet":"articulation_view.post_reset()\n",
"category":"method"
},
{
"title":"post_reset",
"description":"Reset the prims to its default state (positions and orientations)\n\n---\n**Example:**\n\n```python\n>>> prims.post_reset()\n```\n",
"snippet":"articulation_view.post_reset()\n",
"category":"method"
},
{
"title":"set_angular_velocities",
"description":"Set the angular velocities of the prims in the view\n\nThe method does this through the physx API only. It has to be called after initialization.\nNote: This method is not supported for the gpu pipeline. `set_velocities` method should be used instead.\n\n*Warning:*\nThis method will immediately set the articulation state\n\n**Args:**\n\n * `velocities` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\]): angular velocities to set the rigid prims to. shape is (M, 3).\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n*Hint:*\nThis method belongs to the methods used to set the articulation kinematic state:\n\n> `set_velocities` (`set_linear_velocities`, `set_angular_velocities`),\n> `set_joint_positions`, `set_joint_velocities`, `set_joint_efforts`\n\n---\n**Example:**\n\n```python\n>>> # set each articulation linear velocity to (0.1, 0.1, 0.1)\n>>> velocities = np.full((num_envs, 3), fill_value=0.1)\n>>> prims.set_angular_velocities(velocities)\n>>>\n>>> # set only the articulation linear velocities for the first, middle and last of the 5 envs\n>>> velocities = np.full((3, 3), fill_value=0.1)\n>>> prims.set_angular_velocities(velocities, indices=np.array([0, 2, 4]))\n```\n",
"snippet":"articulation_view.set_angular_velocities()\n",
"category":"method"
},
{
"title":"set_armatures",
"description":"Set armatures for articulation joints in the view\n\nSearch for *\"Joint Armature\"* in for more details.\n\n**Args:**\n\n * `values` (Union\\[np.ndarray, torch.Tensor, wp.array\\]): armatures for articulation joints in the view. shape (M, K).\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `joint_indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): joint indices to specify which joints to manipulate. Shape (K,). Where K \\<= num of dofs. Defaults to None (i.e: all dofs).\n\n---\n**Example:**\n\n```python\n>>> # set all joint armatures to 0.05 for all envs\n>>> prims.set_armatures(np.full((num_envs, prims.num_dof), 0.05))\n>>>\n>>> # set only the finger joint (panda_finger_joint1 (7) and panda_finger_joint2 (8)) armatures\n>>> # for the first, middle and last of the 5 envs to 0.05\n>>> prims.set_armatures(np.full((3, 2), 0.05), indices=np.array([0,2,4]), joint_indices=np.array([7,8]))\n```\n",
"snippet":"articulation_view.set_armatures(values=values)\n",
"category":"method"
},
{
"title":"set_body_coms",
"description":"Set body center of mass (COM) positions and orientations for articulation bodies in the view.\n\n**Args:**\n\n * `positions` (Union\\[np.ndarray, torch.Tensor, wp.array\\]): body center of mass positions for articulations in the view. shape (M, K, 3).\n * `orientations` (Union\\[np.ndarray, torch.Tensor, wp.array\\]): body center of mass orientations for articulations in the view. shape (M, K, 4).\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `body_indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): body indices to specify which bodies to manipulate. Shape (K,). Where K \\<= num of bodies. Defaults to None (i.e: all bodies).\n\n---\n**Example:**\n\n```python\n>>> # set the center of mass for all the articulation rigid bodies to the indicated values.\n>>> # Since there are 5 envs, the inertias are repeated 5 times\n>>> positions = np.tile(np.array([0.01, 0.02, 0.03]), (num_envs, prims.num_bodies, 1))\n>>> orientations = np.tile(np.array([1.0, 0.0, 0.0, 0.0]), (num_envs, prims.num_bodies, 1))\n>>> prims.set_body_coms(positions, orientations)\n>>>\n>>> # set the fingers center of mass: panda_leftfinger (10) and panda_rightfinger (11) to 0.2\n>>> # for the first, middle and last of the 5 envs\n>>> positions = np.tile(np.array([0.01, 0.02, 0.03]), (3, 2, 1))\n>>> orientations = np.tile(np.array([1.0, 0.0, 0.0, 0.0]), (3, 2, 1))\n>>> prims.set_body_coms(positions, orientations, indices=np.array([0, 2, 4]), body_indices=np.array([10, 11]))\n```\n",
"snippet":"articulation_view.set_body_coms()\n",
"category":"method"
},
{
"title":"set_body_inertias",
"description":"Set body inertias for articulation bodies in the view.\n\n**Args:**\n\n * `values` (Union\\[np.ndarray, torch.Tensor, wp.array\\]): body inertias for articulations in the view. shape (M, K, 9).\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `body_indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): body indices to specify which bodies to manipulate. Shape (K,). Where K \\<= num of bodies. Defaults to None (i.e: all bodies).\n\n---\n**Example:**\n\n```python\n>>> # set the inertias for all the articulation rigid bodies to the indicated values.\n>>> # Since there are 5 envs, the inertias are repeated 5 times\n>>> inertias = np.tile(np.array([0.1, 0.0, 0.0, 0.0, 0.1, 0.0, 0.0, 0.0, 0.1]), (num_envs, prims.num_bodies, 1))\n>>> prims.set_body_inertias(inertias)\n>>>\n>>> # set the fingers inertias: panda_leftfinger (10) and panda_rightfinger (11) to 0.2\n>>> # for the first, middle and last of the 5 envs\n>>> inertias = np.tile(np.array([0.1, 0.0, 0.0, 0.0, 0.1, 0.0, 0.0, 0.0, 0.1]), (3, 2, 1))\n>>> prims.set_body_inertias(inertias, indices=np.array([0, 2, 4]), body_indices=np.array([10, 11]))\n```\n",
"snippet":"articulation_view.set_body_inertias(values=values)\n",
"category":"method"
},
{
"title":"set_body_masses",
"description":"Set body masses for articulation bodies in the view\n\n**Args:**\n\n * `values` (Union\\[np.ndarray, torch.Tensor, wp.array\\]): body masses for articulations in the view. shape (M, K).\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `body_indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): body indices to specify which bodies to manipulate. Shape (K,). Where K \\<= num of bodies. Defaults to None (i.e: all bodies).\n\n---\n**Example:**\n\n```python\n>>> # set the masses for all the articulation rigid bodies to the indicated values.\n>>> # Since there are 5 envs, the masses are repeated 5 times\n>>> masses = np.tile(np.array([1.2, 1.1, 1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.2]), (num_envs, 1))\n>>> prims.set_body_masses(masses)\n>>>\n>>> # set the fingers masses: panda_leftfinger (10) and panda_rightfinger (11) to 0.2\n>>> # for the first, middle and last of the 5 envs\n>>> masses = np.tile(np.array([0.2, 0.2]), (3, 1))\n>>> prims.set_body_masses(masses, indices=np.array([0, 2, 4]), body_indices=np.array([10, 11]))\n```\n",
"snippet":"articulation_view.set_body_masses(values=values)\n",
"category":"method"
},
{
"title":"set_default_state",
"description":"Set the default state of the prims (positions and orientations), that will be used after each reset.\n\n*Note:*\nThe default states will be set during post-reset (e.g., calling `.post_reset()` or `world.reset()` methods)\n\n**Args:**\n\n * `positions` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): positions in the world frame of the prim. shape is (M, 3). Defaults to None, which means left unchanged.\n * `orientations` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): quaternion orientations in the world frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (M, 4). Defaults to None, which means left unchanged.\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n---\n**Example:**\n\n```python\n>>> # configure default states for all prims\n>>> positions = np.zeros((num_envs, 3))\n>>> positions[:, 0] = np.arange(num_envs)\n>>> orientations = np.tile(np.array([1.0, 0.0, 0.0, 0.0]), (num_envs, 1))\n>>> prims.set_default_state(positions=positions, orientations=orientations)\n>>>\n>>> # set default states during post-reset\n>>> prims.post_reset()\n```\n",
"snippet":"articulation_view.set_default_state()\n",
"category":"method"
},
{
"title":"set_effort_modes",
"description":"Set effort modes for articulations in the view\n\n**Args:**\n\n * `mode` (str): effort mode to be applied to prims in the view: `acceleration` or `force`.\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `joint_indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): joint indices to specify which joints to manipulate. Shape (K,). Where K \\<= num of dofs. Defaults to None (i.e: all dofs).\n\n---\n**Example:**\n\n```python\n>>> # set the effort mode for all joints to 'force'\n>>> prims.set_effort_modes(\"force\")\n>>>\n>>> # set only the finger joints effort mode to 'force' for the first, middle and last of the 5 envs\n>>> prims.set_effort_modes(\"force\", indices=np.array([0, 2, 4]), joint_indices=np.array([7, 8]))\n```\n",
"snippet":"articulation_view.set_effort_modes(mode=mode)\n",
"category":"method"
},
{
"title":"set_enabled_self_collisions",
"description":"Set the enable self collisions flag (`physxArticulation:enabledSelfCollisions`)\n\n**Args:**\n\n * `flags` (Union\\[np.ndarray, torch.Tensor, wp.array\\]): true to enable self collision. otherwise false. shape (M,)\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n---\n**Example:**\n\n```python\n>>> # enable the self collisions flag for all envs\n>>> prims.set_enabled_self_collisions(np.full((num_envs,), True))\n>>>\n>>> # enable the self collisions flag only for the first, middle and last of the 5 envs\n>>> prims.set_enabled_self_collisions(np.full((3,), True), indices=np.array([0, 2, 4]))\n```\n",
"snippet":"articulation_view.set_enabled_self_collisions(flags=flags)\n",
"category":"method"
},
{
"title":"set_fixed_tendon_properties",
"description":"Set fixed tendon properties for articulations in the view\n\nSearch for *Fixed Tendon* in for more details\n\n**Args:**\n\n * `stiffnesses` (Union\\[np.ndarray, torch.Tensor, wp.array\\]): fixed tendon stiffnesses for articulations in the view. shape (M, K).\n * `dampings` (Union\\[np.ndarray, torch.Tensor, wp.array\\]): fixed tendon dampings for articulations in the view. shape (M, K).\n * `limit_stiffnesses` (Union\\[np.ndarray, torch.Tensor, wp.array\\]): fixed tendon limit stiffnesses for articulations in the view. shape (M, K).\n * `limits` (Union\\[np.ndarray, torch.Tensor, wp.array\\]): fixed tendon limits for articulations in the view. shape (M, K, 2).\n * `rest_lengths` (Union\\[np.ndarray, torch.Tensor, wp.array\\]): fixed tendon rest lengths for articulations in the view. shape (M, K).\n * `offsets` (Union\\[np.ndarray, torch.Tensor, wp.array\\]): fixed tendon offsets for articulations in the view. shape (M, K).\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n---\n**Example:**\n\n```python\n>>> # set the limit stiffnesses and dampings\n>>> # for the ShadowHand articulation that has 4 fixed tendons (prims.num_fixed_tendons)\n>>> limit_stiffnesses = np.full((num_envs, prims.num_fixed_tendons), fill_value=10.0)\n>>> dampings = np.full((num_envs, prims.num_fixed_tendons), fill_value=0.1)\n>>> prims.set_fixed_tendon_properties(dampings=dampings, limit_stiffnesses=limit_stiffnesses)\n```\n",
"snippet":"articulation_view.set_fixed_tendon_properties()\n",
"category":"method"
},
{
"title":"set_friction_coefficients",
"description":"Set the friction coefficients for articulation joints in the view\n\nSearch for *\"Joint Friction Coefficient\"* in for more details.\n\n**Args:**\n\n * `values` (Union\\[np.ndarray, torch.Tensor, wp.array\\]): friction coefficients for articulation joints in the view. shape (M, K).\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `joint_indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): joint indices to specify which joints to manipulate. Shape (K,). Where K \\<= num of dofs. Defaults to None (i.e: all dofs).\n\n---\n**Example:**\n\n```python\n>>> # set all joint friction coefficients to 0.05 for all envs\n>>> prims.set_friction_coefficients(np.full((num_envs, prims.num_dof), 0.05))\n>>>\n>>> # set only the finger joint (panda_finger_joint1 (7) and panda_finger_joint2 (8)) friction coefficients\n>>> # for the first, middle and last of the 5 envs to 0.05\n>>> prims.set_friction_coefficients(np.full((3, 2), 0.05), indices=np.array([0,2,4]), joint_indices=np.array([7,8]))\n```\n",
"snippet":"articulation_view.set_friction_coefficients(values=values)\n",
"category":"method"
},
{
"title":"set_gains",
"description":"Set the implicit Proportional-Derivative (PD) controller's Kps (stiffnesses) and Kds (dampings) of articulations in the view\n\n**Args:**\n\n * `kps` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): stiffness of the drives. shape is (M, K). Defaults to None.\n * `kds` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): damping of the drives. shape is (M, K).. Defaults to None.\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `joint_indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): joint indices to specify which joints to manipulate. Shape (K,). Where K \\<= num of dofs. Defaults to None (i.e: all dofs).\n * `save_to_usd` (bool, optional): True to save the gains in the usd. otherwise False.\n\n---\n**Example:**\n\n```python\n>>> # set the gains (stiffnesses and dampings) for all the articulation joints to the indicated values.\n>>> # Since there are 5 envs, the gains are repeated 5 times\n>>> stiffnesses = np.tile(np.array([100000, 100000, 100000, 100000, 80000, 80000, 80000, 50000, 50000]), (num_envs, 1))\n>>> dampings = np.tile(np.array([8000, 8000, 8000, 8000, 5000, 5000, 5000, 2000, 2000]), (num_envs, 1))\n>>> prims.set_gains(kps=stiffnesses, kds=dampings)\n>>>\n>>> # set the fingers gains (stiffnesses and dampings): panda_finger_joint1 (7) and panda_finger_joint2 (8)\n>>> # to 50000 and 2000 respectively for the first, middle and last of the 5 envs\n>>> stiffnesses = np.tile(np.array([50000, 50000]), (3, 1))\n>>> dampings = np.tile(np.array([2000, 2000]), (3, 1))\n>>> prims.set_gains(kps=stiffnesses, kds=dampings, indices=np.array([0, 2, 4]), joint_indices=np.array([7, 8]))\n```\n",
"snippet":"articulation_view.set_gains()\n",
"category":"method"
},
{
"title":"set_joint_efforts",
"description":"Set the joint efforts of articulations in the view\n\n*Note:*\nThis method can be used for effort control. For this purpose, there must be no joint drive\nor the stiffness and damping must be set to zero.\n\n**Args:**\n\n * `efforts` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\]): efforts of articulations in the view to be set to in the next frame. shape is (M, K).\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `joint_indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): joint indices to specify which joints to manipulate. Shape (K,). Where K \\<= num of dofs. Defaults to None (i.e: all dofs).\n\n*Hint:*\nThis method belongs to the methods used to set the articulation kinematic states:\n\n> `set_velocities` (`set_linear_velocities`, `set_angular_velocities`),\n> `set_joint_positions`, `set_joint_velocities`, `set_joint_efforts`\n\n---\n**Example:**\n\n```python\n>>> # set the efforts for all the articulation joints to the indicated values.\n>>> # Since there are 5 envs, the joint efforts are repeated 5 times\n>>> efforts = np.tile(np.array([10, 20, 30, 40, 50, 60, 70, 80, 90]), (num_envs, 1))\n>>> prims.set_joint_efforts(efforts)\n>>>\n>>> # set the fingers efforts: panda_finger_joint1 (7) and panda_finger_joint2 (8) to 10\n>>> # for the first, middle and last of the 5 envs\n>>> efforts = np.tile(np.array([10, 10]), (3, 1))\n>>> prims.set_joint_efforts(efforts, indices=np.array([0, 2, 4]), joint_indices=np.array([7, 8]))\n```\n",
"snippet":"articulation_view.set_joint_efforts(efforts=efforts)\n",
"category":"method"
},
{
"title":"set_joint_position_targets",
"description":"Set the joint position targets for the implicit Proportional-Derivative (PD) controllers\n\n*Note:*\nThis is an independent method for controlling joints. To apply multiple targets (position, velocity,\nand/or effort) in the same call, consider using the `apply_action` method\n\n**Args:**\n\n * `positions` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\]): joint position targets for the implicit PD controller. shape is (M, K).\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `joint_indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): joint indices to specify which joints to manipulate. Shape (K,). Where K \\<= num of dofs. Defaults to None (i.e: all dofs).\n\n*Hint:*\nHigh stiffness makes the joints snap faster and harder to the desired target,\nand higher damping smoothes but also slows down the joint's movement to target\n\n * For position control, set relatively high stiffness and low damping (to reduce vibrations)\n\n---\n**Example:**\n\n```python\n>>> # apply the target positions (to move all the robot joints) to the indicated values.\n>>> # Since there are 5 envs, the joint positions are repeated 5 times\n>>> positions = np.tile(np.array([0.0, -1.0, 0.0, -2.2, 0.0, 2.4, 0.8, 0.04, 0.04]), (num_envs, 1))\n>>> prims.set_joint_position_targets(positions)\n>>>\n>>> # close the robot fingers: panda_finger_joint1 (7) and panda_finger_joint2 (8) to 0.0\n>>> # for the first, middle and last of the 5 envs\n>>> positions = np.tile(np.array([0.0, 0.0]), (3, 1))\n>>> prims.set_joint_position_targets(positions, indices=np.array([0, 2, 4]), joint_indices=np.array([7, 8]))\n```\n",
"snippet":"articulation_view.set_joint_position_targets(positions=positions)\n",
"category":"method"
},
{
"title":"set_joint_positions",
"description":"Set the joint positions of articulations in the view\n\n*Warning:*\nThis method will immediately set (teleport) the affected joints to the indicated value.\nUse the `set_joint_position_targets` or the `apply_action` methods to control the articulation joints.\n\n**Args:**\n\n * `positions` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\]): joint positions of articulations in the view to be set to in the next frame. shape is (M, K).\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `joint_indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): joint indices to specify which joints to manipulate. Shape (K,). Where K \\<= num of dofs. Defaults to None (i.e: all dofs).\n\n*Hint:*\nThis method belongs to the methods used to set the articulation kinematic states:\n\n> `set_velocities` (`set_linear_velocities`, `set_angular_velocities`),\n> `set_joint_positions`, `set_joint_velocities`, `set_joint_efforts`\n\n---\n**Example:**\n\n```python\n>>> # set all the articulation joints.\n>>> # Since there are 5 envs, the joint positions are repeated 5 times\n>>> positions = np.tile(np.array([0.0, -1.0, 0.0, -2.2, 0.0, 2.4, 0.8, 0.04, 0.04]), (num_envs, 1))\n>>> prims.set_joint_positions(positions)\n>>>\n>>> # set only the fingers in closed position: panda_finger_joint1 (7) and panda_finger_joint2 (8) to 0.0\n>>> # for the first, middle and last of the 5 envs\n>>> positions = np.tile(np.array([0.0, 0.0]), (3, 1))\n>>> prims.set_joint_positions(positions, indices=np.array([0, 2, 4]), joint_indices=np.array([7, 8]))\n```\n",
"snippet":"articulation_view.set_joint_positions(positions=positions)\n",
"category":"method"
},
{
"title":"set_joint_velocities",
"description":"Set the joint velocities of articulations in the view\n\n*Warning:*\nThis method will immediately set the affected joints to the indicated value.\nUse the `set_joint_velocity_targets` or the `apply_action` methods to control the articulation joints.\n\n**Args:**\n\n * `velocities` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\]): joint velocities of articulations in the view to be set to in the next frame. shape is (M, K).\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `joint_indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): joint indices to specify which joints to manipulate. Shape (K,). Where K \\<= num of dofs. Defaults to None (i.e: all dofs).\n\n*Hint:*\nThis method belongs to the methods used to set the articulation kinematic states:\n\n> `set_velocities` (`set_linear_velocities`, `set_angular_velocities`),\n> `set_joint_positions`, `set_joint_velocities`, `set_joint_efforts`\n\n---\n**Example:**\n\n```python\n>>> # set the velocities for all the articulation joints to the indicated values.\n>>> # Since there are 5 envs, the joint velocities are repeated 5 times\n>>> velocities = np.tile(np.array([0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9]), (num_envs, 1))\n>>> prims.set_joint_velocities(velocities)\n>>>\n>>> # set the fingers velocities: panda_finger_joint1 (7) and panda_finger_joint2 (8) to -0.1\n>>> # for the first, middle and last of the 5 envs\n>>> velocities = np.tile(np.array([-0.1, -0.1]), (3, 1))\n>>> prims.set_joint_velocities(velocities, indices=np.array([0, 2, 4]), joint_indices=np.array([7, 8]))\n```\n",
"snippet":"articulation_view.set_joint_velocities(velocities=velocities)\n",
"category":"method"
},
{
"title":"set_joint_velocity_targets",
"description":"Set the joint velocity targets for the implicit Proportional-Derivative (PD) controllers\n\n*Note:*\nThis is an independent method for controlling joints. To apply multiple targets (position, velocity,\nand/or effort) in the same call, consider using the `apply_action` method\n\n**Args:**\n\n * `velocities` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\]): joint velocity targets for the implicit PD controller. shape is (M, K).\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `joint_indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): joint indices to specify which joints to manipulate. Shape (K,). Where K \\<= num of dofs. Defaults to None (i.e: all dofs).\n\n*Hint:*\nHigh stiffness makes the joints snap faster and harder to the desired target,\nand higher damping smoothes but also slows down the joint's movement to target\n\n * For velocity control, stiffness must be set to zero with a non-zero damping\n\n---\n**Example:**\n\n```python\n>>> # apply the target velocities for all the articulation joints to the indicated values.\n>>> # Since there are 5 envs, the joint velocities are repeated 5 times\n>>> velocities = np.tile(np.array([0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9]), (num_envs, 1))\n>>> prims.set_joint_velocity_targets(velocities)\n>>>\n>>> # apply the fingers target velocities: panda_finger_joint1 (7) and panda_finger_joint2 (8) to -1.0\n>>> # for the first, middle and last of the 5 envs\n>>> velocities = np.tile(np.array([-0.1, -0.1]), (3, 1))\n>>> prims.set_joint_velocity_targets(velocities, indices=np.array([0, 2, 4]), joint_indices=np.array([7, 8]))\n```\n",
"snippet":"articulation_view.set_joint_velocity_targets(velocities=velocities)\n",
"category":"method"
},
{
"title":"set_joints_default_state",
"description":"Set the joints default state (joint positions, velocities and efforts) to be applied after each reset.\n\n*Note:*\nThe default states will be set during post-reset (e.g., calling `.post_reset()` or `world.reset()` methods)\n\n**Args:**\n\n * `positions` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): default joint positions. shape is (N, num of dofs). Defaults to None.\n * `velocities` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): default joint velocities. shape is (N, num of dofs). Defaults to None.\n * `efforts` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): default joint efforts. shape is (N, num of dofs). Defaults to None.\n\n---\n**Example:**\n\n```python\n>>> # configure default joint states for all articulations\n>>> positions = np.tile(np.array([0.0, -1.0, 0.0, -2.2, 0.0, 2.4, 0.8, 0.04, 0.04]), (num_envs, 1))\n>>> prims.set_joints_default_state(\n...     positions=positions,\n...     velocities=np.zeros((num_envs, prims.num_dof)),\n...     efforts=np.zeros((num_envs, prims.num_dof))\n... )\n>>>\n>>> # set default states during post-reset\n>>> prims.post_reset()\n```\n",
"snippet":"articulation_view.set_joints_default_state()\n",
"category":"method"
},
{
"title":"set_linear_velocities",
"description":"Set the linear velocities of the prims in the view\n\nThe method does this through the PhysX API only. It has to be called after initialization.\nNote: This method is not supported for the gpu pipeline. `set_velocities` method should be used instead.\n\n*Warning:*\nThis method will immediately set the articulation state\n\n**Args:**\n\n * `velocities` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\]): linear velocities to set the rigid prims to. shape is (M, 3).\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n*Hint:*\nThis method belongs to the methods used to set the articulation kinematic state:\n\n> `set_velocities` (`set_linear_velocities`, `set_angular_velocities`),\n> `set_joint_positions`, `set_joint_velocities`, `set_joint_efforts`\n\n---\n**Example:**\n\n```python\n>>> # set each articulation linear velocity to (1.0, 1.0, 1.0)\n>>> velocities = np.ones((num_envs, 3))\n>>> prims.set_linear_velocities(velocities)\n>>>\n>>> # set only the articulation linear velocities for the first, middle and last of the 5 envs\n>>> velocities = np.ones((3, 3))\n>>> prims.set_linear_velocities(velocities, indices=np.array([0, 2, 4]))\n```\n",
"snippet":"articulation_view.set_linear_velocities()\n",
"category":"method"
},
{
"title":"set_local_poses",
"description":"Set prim poses in the view with respect to the local frame (the prim's parent frame).\n\n*Warning:*\nThis method will change (teleport) the prim poses immediately to the indicated value\n\n**Args:**\n\n * `translations` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): translations in the local frame of the prims (with respect to its parent prim). shape is (M, 3). Defaults to None, which means left unchanged.\n * `orientations` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): quaternion orientations in the local frame of the prims. quaternion is scalar-first (w, x, y, z). shape is (M, 4). Defaults to None, which means left unchanged.\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n*Hint:*\nThis method belongs to the methods used to set the prim state\n\n---\n**Example:**\n\n```python\n>>> # reposition all articulations\n>>> positions = np.zeros((num_envs, 3))\n>>> positions[:,0] = np.arange(num_envs)\n>>> orientations = np.tile(np.array([1.0, 0.0, 0.0, 0.0]), (num_envs, 1))\n>>> prims.set_local_poses(positions, orientations)\n>>>\n>>> # reposition only the articulations for the first, middle and last of the 5 envs\n>>> positions = np.zeros((3, 3))\n>>> positions[:,1] = np.arange(3)\n>>> orientations = np.tile(np.array([1.0, 0.0, 0.0, 0.0]), (3, 1))\n>>> prims.set_local_poses(positions, orientations, indices=np.array([0, 2, 4]))\n```\n",
"snippet":"articulation_view.set_local_poses()\n",
"category":"method"
},
{
"title":"set_local_poses",
"description":"Set prim poses in the view with respect to the local frame (the prim's parent frame)\n\n*Warning:*\nThis method will change (teleport) the prim poses immediately to the indicated value\n\n**Args:**\n\n * `translations` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): translations in the local frame of the prims (with respect to its parent prim). shape is (M, 3). Defaults to None, which means left unchanged.\n * `orientations` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): quaternion orientations in the local frame of the prims. quaternion is scalar-first (w, x, y, z). shape is (M, 4). Defaults to None, which means left unchanged.\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n*Hint:*\nThis method belongs to the methods used to set the prim state\n\n---\n**Example:**\n\n```python\n>>> # reposition all prims\n>>> positions = np.zeros((num_envs, 3))\n>>> positions[:,0] = np.arange(num_envs)\n>>> orientations = np.tile(np.array([1.0, 0.0, 0.0, 0.0]), (num_envs, 1))\n>>> prims.set_local_poses(positions, orientations)\n>>>\n>>> # reposition only the prims for the first, middle and last of the 5 envs\n>>> positions = np.zeros((3, 3))\n>>> positions[:,1] = np.arange(3)\n>>> orientations = np.tile(np.array([1.0, 0.0, 0.0, 0.0]), (3, 1))\n>>> prims.set_local_poses(positions, orientations, indices=np.array([0, 2, 4]))\n```\n",
"snippet":"articulation_view.set_local_poses()\n",
"category":"method"
},
{
"title":"set_local_scales",
"description":"Set prim scales in the view with respect to the local frame (the prim's parent frame)\n\n**Args:**\n\n * `scales` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\]): scales to be applied to the prim's dimensions in the view. shape is (M, 3).\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n---\n**Example:**\n\n```python\n>>> # set the scale for all prims. Since there are 5 envs, the scale is repeated 5 times\n>>> scales = np.tile(np.array([1.0, 0.75, 0.5]), (num_envs, 1))\n>>> prims.set_local_scales(scales)\n>>>\n>>> # set the scale for the first, middle and last of the 5 envs\n>>> scales = np.tile(np.array([1.0, 0.75, 0.5]), (3, 1))\n>>> prims.set_local_scales(scales, indices=np.array([0, 2, 4]))\n```\n",
"snippet":"articulation_view.set_local_scales(scales=scales)\n",
"category":"method"
},
{
"title":"set_max_efforts",
"description":"Set maximum efforts for articulation in the view\n\n**Args:**\n\n * `values` (Union\\[np.ndarray, torch.Tensor, wp.array\\]): maximum efforts for articulations in the view. shape (M, K).\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `joint_indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): joint indices to specify which joints to manipulate. Shape (K,). Where K \\<= num of dofs. Defaults to None (i.e: all dofs).\n\n---\n**Example:**\n\n```python\n>>> # set the max efforts for all the articulation joints to the indicated values.\n>>> # Since there are 5 envs, the joint efforts are repeated 5 times\n>>> max_efforts = np.tile(np.array([10000, 9000, 8000, 7000, 6000, 5000, 4000, 1000, 1000]), (num_envs, 1))\n>>> prims.set_max_efforts(max_efforts)\n>>>\n>>> # set the fingers max efforts: panda_finger_joint1 (7) and panda_finger_joint2 (8) to 1000\n>>> # for the first, middle and last of the 5 envs\n>>> max_efforts = np.tile(np.array([1000, 1000]), (3, 1))\n>>> prims.set_max_efforts(max_efforts, indices=np.array([0, 2, 4]), joint_indices=np.array([7, 8]))\n```\n",
"snippet":"articulation_view.set_max_efforts(values=values)\n",
"category":"method"
},
{
"title":"set_sleep_thresholds",
"description":"Set the threshold for articulations to enter a sleep state\n\nSearch for *Articulations and Sleeping* in for more details\n\n**Args:**\n\n * `thresholds` (Union\\[np.ndarray, torch.Tensor, wp.array\\]): sleep thresholds to be applied. shape (M,).\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n---\n**Example:**\n\n```python\n>>> # set the sleep threshold for all envs\n>>> prims.set_sleep_thresholds(np.full((num_envs,), 0.01))\n>>>\n>>> # set only the sleep threshold for the first, middle and last of the 5 envs\n>>> prims.set_sleep_thresholds(np.full((3,), 0.01), indices=np.array([0, 2, 4]))\n```\n",
"snippet":"articulation_view.set_sleep_thresholds(thresholds=thresholds)\n",
"category":"method"
},
{
"title":"set_solver_position_iteration_counts",
"description":"Set the solver (position) iteration count for the articulations\n\nThe solver iteration count determines how accurately contacts, drives, and limits are resolved.\nSearch for *Solver Iteration Count* in for more details.\n\n*Warning:*\nSetting a higher number of iterations may improve the fidelity of the simulation, although it may affect its performance.\n\n**Args:**\n\n * `counts` (Union\\[np.ndarray, torch.Tensor, wp.array\\]): number of iterations for the solver. Shape (M,).\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n---\n**Example:**\n\n```python\n>>> # set the position iteration count for all envs\n>>> prims.set_solver_position_iteration_counts(np.full((num_envs,), 64))\n>>>\n>>> # set only the position iteration count for the first, middle and last of the 5 envs\n>>> prims.set_solver_position_iteration_counts(np.full((3,), 64), indices=np.array([0, 2, 4]))\n```\n",
"snippet":"articulation_view.set_solver_position_iteration_counts(counts=counts)\n",
"category":"method"
},
{
"title":"set_solver_velocity_iteration_counts",
"description":"Set the solver (velocity) iteration count for the articulations\n\nThe solver iteration count determines how accurately contacts, drives, and limits are resolved.\nSearch for *Solver Iteration Count* in for more details.\n\n*Warning:*\nSetting a higher number of iterations may improve the fidelity of the simulation, although it may affect its performance.\n\n**Args:**\n\n * `counts` (Union\\[np.ndarray, torch.Tensor, wp.array\\]): number of iterations for the solver. Shape (M,).\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n---\n**Example:**\n\n```python\n>>> # set the velocity iteration count for all envs\n>>> prims.set_solver_velocity_iteration_counts(np.full((num_envs,), 64))\n>>>\n>>> # set only the velocity iteration count for the first, middle and last of the 5 envs\n>>> prims.set_solver_velocity_iteration_counts(np.full((3,), 64), indices=np.array([0, 2, 4]))\n```\n",
"snippet":"articulation_view.set_solver_velocity_iteration_counts(counts=counts)\n",
"category":"method"
},
{
"title":"set_stabilization_thresholds",
"description":"Set the mass-normalized kinetic energy below which the articulation may participate in stabilization\n\nSearch for *Stabilization Threshold* in for more details\n\n**Args:**\n\n * `thresholds` (Union\\[np.ndarray, torch.Tensor, wp.array\\]): stabilization thresholds to be applied. Shape (M,).\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n---\n**Example:**\n\n```python\n>>> # set the stabilization threshold for all envs\n>>> prims.set_stabilization_thresholds(np.full((num_envs,), 0.005))\n>>>\n>>> # set only the stabilization threshold for the first, middle and last of the 5 envs\n>>> prims.set_stabilization_thresholds(np.full((3,), 0.0051), indices=np.array([0, 2, 4]))\n```\n",
"snippet":"articulation_view.set_stabilization_thresholds(thresholds=thresholds)\n",
"category":"method"
},
{
"title":"set_velocities",
"description":"Set the linear and angular velocities of the prims in the view at once.\n\nThe method does this through the PhysX API only. It has to be called after initialization\n\n*Warning:*\nThis method will immediately set the articulation state\n\n**Args:**\n\n * `velocities` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\]): linear and angular velocities respectively to set the rigid prims to. shape is (M, 6).\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n*Hint:*\nThis method belongs to the methods used to set the articulation kinematic state:\n\n> `set_velocities` (`set_linear_velocities`, `set_angular_velocities`),\n> `set_joint_positions`, `set_joint_velocities`, `set_joint_efforts`\n\n---\n**Example:**\n\n```python\n>>> # set each articulation linear velocity to (1., 1., 1.) and angular velocity to (.1, .1, .1)\n>>> velocities = np.ones((num_envs, 6))\n>>> velocities[:,3:] = 0.1\n>>> prims.set_velocities(velocities)\n>>>\n>>> # set only the articulation velocities for the first, middle and last of the 5 envs\n>>> velocities = np.ones((3, 6))\n>>> velocities[:,3:] = 0.1\n>>> prims.set_velocities(velocities, indices=np.array([0, 2, 4]))\n```\n",
"snippet":"articulation_view.set_velocities()\n",
"category":"method"
},
{
"title":"set_visibilities",
"description":"Set the visibilities of the prims in stage\n\n**Args:**\n\n * `visibilities` (Union\\[np.ndarray, torch.Tensor, wp.array\\]): flag to set the visibilities of the usd prims in stage. Shape (M,). Where M \\<= size of the encapsulated prims in the view.\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Defaults to None (i.e: all prims in the view).\n\n---\n**Example:**\n\n```python\n>>> # make all prims not visible in the stage\n>>> prims.set_visibilities(visibilities=[False] * num_envs)\n```\n",
"snippet":"articulation_view.set_visibilities(visibilities=visibilities)\n",
"category":"method"
},
{
"title":"set_world_poses",
"description":"Set poses of prims in the view with respect to the world's frame.\n\n*Warning:*\nThis method will change (teleport) the prim poses immediately to the indicated value\n\n**Args:**\n\n * `positions` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): positions in the world frame of the prim. shape is (M, 3). Defaults to None, which means left unchanged.\n * `orientations` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): quaternion orientations in the world frame of the prims. quaternion is scalar-first (w, x, y, z). shape is (M, 4). Defaults to None, which means left unchanged.\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n*Hint:*\nThis method belongs to the methods used to set the prim state\n\n---\n**Example:**\n\n```python\n>>> # reposition all articulations in row (x-axis)\n>>> positions = np.zeros((num_envs, 3))\n>>> positions[:,0] = np.arange(num_envs)\n>>> orientations = np.tile(np.array([1.0, 0.0, 0.0, 0.0]), (num_envs, 1))\n>>> prims.set_world_poses(positions, orientations)\n>>>\n>>> # reposition only the articulations for the first, middle and last of the 5 envs in column (y-axis)\n>>> positions = np.zeros((3, 3))\n>>> positions[:,1] = np.arange(3)\n>>> orientations = np.tile(np.array([1.0, 0.0, 0.0, 0.0]), (3, 1))\n>>> prims.set_world_poses(positions, orientations, indices=np.array([0, 2, 4]))\n```\n",
"snippet":"articulation_view.set_world_poses()\n",
"category":"method"
},
{
"title":"set_world_poses",
"description":"Set prim poses in the view with respect to the world's frame\n\n*Warning:*\nThis method will change (teleport) the prim poses immediately to the indicated value\n\n**Args:**\n\n * `positions` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): positions in the world frame of the prims. shape is (M, 3). Defaults to None, which means left unchanged.\n * `orientations` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): quaternion orientations in the world frame of the prims. quaternion is scalar-first (w, x, y, z). shape is (M, 4). Defaults to None, which means left unchanged.\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n*Hint:*\nThis method belongs to the methods used to set the prim state\n\n---\n**Example:**\n\n```python\n>>> # reposition all prims in row (x-axis)\n>>> positions = np.zeros((num_envs, 3))\n>>> positions[:,0] = np.arange(num_envs)\n>>> orientations = np.tile(np.array([1.0, 0.0, 0.0, 0.0]), (num_envs, 1))\n>>> prims.set_world_poses(positions, orientations)\n>>>\n>>> # reposition only the prims for the first, middle and last of the 5 envs in column (y-axis)\n>>> positions = np.zeros((3, 3))\n>>> positions[:,1] = np.arange(3)\n>>> orientations = np.tile(np.array([1.0, 0.0, 0.0, 0.0]), (3, 1))\n>>> prims.set_world_poses(positions, orientations, indices=np.array([0, 2, 4]))\n```\n",
"snippet":"articulation_view.set_world_poses()\n",
"category":"method"
},
{
"title":"switch_control_mode",
"description":"Switch control mode between `\"position\"`, `\"velocity\"`, or `\"effort\"` for all joints\n\nThis method will set the implicit Proportional-Derivative (PD) controller's Kps (stiffnesses) and Kds (dampings),\ndefined via the `set_gains` method, of the selected articulations and joints according to the following rule:\n\n| Control mode | Stiffnesses | Dampings |\n|--------------|-------------|----------|\n| `\"position\"` | Kps         | Kds      |\n| `\"velocity\"` | 0           | Kds      |\n| `\"effort\"`   | 0           | 0        |\n\n**Args:**\n\n * `mode` (str): control mode to switch the articulations specified to. It can be `\"position\"`, `\"velocity\"`, or `\"effort\"`\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `joint_indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): joint indices to specify which joints to manipulate. Shape (K,). Where K \\<= num of dofs. Defaults to None (i.e: all dofs).\n\n---\n**Example:**\n\n```python\n>>> # set 'velocity' as control mode for all joints\n>>> prims.switch_control_mode(\"velocity\")\n>>>\n>>> # set 'effort' as control mode only for the fingers: panda_finger_joint1 (7) and panda_finger_joint2 (8)\n>>> # for the first, middle and last of the 5 envs\n>>> prims.switch_control_mode(\"effort\", indices=np.array([0, 2, 4]), joint_indices=np.array([7, 8]))\n```\n",
"snippet":"articulation_view.switch_control_mode(mode=mode)\n",
"category":"method"
},
{
"title":"switch_dof_control_mode",
"description":"Switch control mode between `\"position\"`, `\"velocity\"`, or `\"effort\"` for the specified DOF\n\nThis method will set the implicit Proportional-Derivative (PD) controller's Kps (stiffnesses) and Kds (dampings),\ndefined via the `set_gains` method, of the selected DOF according to the following rule:\n\n| Control mode | Stiffnesses | Dampings |\n|--------------|-------------|----------|\n| `\"position\"` | Kps         | Kds      |\n| `\"velocity\"` | 0           | Kds      |\n| `\"effort\"`   | 0           | 0        |\n\n**Args:**\n\n * `mode` (str): control mode to switch the DOF specified to. It can be `\"position\"`, `\"velocity\"` or `\"effort\"`\n * `dof_index` (int): dof index to switch the control mode of.\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n---\n**Example:**\n\n```python\n>>> # set 'velocity' as control mode for the panda_joint1 (0) joint for all envs\n>>> prims.switch_dof_control_mode(\"velocity\", dof_index=0)\n>>>\n>>> # set 'effort' as control mode for the panda_joint1 (0) for the first, middle and last of the 5 envs\n>>> prims.switch_dof_control_mode(\"effort\", dof_index=0, indices=np.array([0, 2, 4]))\n```\n",
"snippet":"articulation_view.switch_dof_control_mode(mode=mode, dof_index=dof_index)\n",
"category":"method"
}
]
}
]
},
{
"title":"Controllers",
"snippets":[
{
"title":"ArticulationController",
"snippets":[
{
"title":"import ...",
"description":"Import class",
"snippet":"from omni.isaac.core.controllers import ArticulationController\n",
"category":"import"
},
{
"title":"ArticulationController",
"description":"PD Controller of all degrees of freedom of an articulation, can apply position targets, velocity targets and efforts.\n\nCheckout the required tutorials at\n\n:   <https://docs.omniverse.nvidia.com/app_isaacsim/app_isaacsim/overview.html>\n",
"snippet":"articulation_controller = ArticulationController()\n",
"category":"class"
},
{
"title":"apply_action",
"description":"\\[summary\\]\n\n**Args:**\n\n * `control_actions` (ArticulationAction): actions to be applied for next physics step.\n * `indices` (Optional\\[Union\\[list, np.ndarray\\]\\], optional): degree of freedom indices to apply actions to. Defaults to all degrees of freedom.\n\n**Raises:**\n\n * Exception: \\[description\\]\n",
"snippet":"articulation_controller.apply_action(control_actions=control_actions)\n",
"category":"method"
},
{
"title":"get_applied_action",
"description":"**Raises:**\n\n * Exception: \\[description\\]\n\n**Returns:**\n\n * ArticulationAction: Gets last applied action.\n",
"snippet":"applied_action = articulation_controller.get_applied_action()\n",
"category":"method"
},
{
"title":"get_effort_modes",
"description":"\\[summary\\]\n\n**Raises:**\n\n * Exception: \\[description\\]\n    NotImplementedError: \\[description\\]\n\n**Returns:**\n\n * np.ndarray: \\[description\\]\n",
"snippet":"effort_modes = articulation_controller.get_effort_modes()\n",
"category":"method"
},
{
"title":"get_gains",
"description":"\\[summary\\]\n\n**Raises:**\n\n * Exception: \\[description\\]\n\n**Returns:**\n\n * Tuple\\[np.ndarray, np.ndarray\\]: \\[description\\]\n",
"snippet":"gains = articulation_controller.get_gains()\n",
"category":"method"
},
{
"title":"get_joint_limits",
"description":"\\[summary\\]\n\n**Raises:**\n\n * Exception: \\[description\\]\n\n**Returns:**\n\n * Tuple\\[np.ndarray, np.ndarray\\]: \\[description\\]\n",
"snippet":"joint_limits = articulation_controller.get_joint_limits()\n",
"category":"method"
},
{
"title":"get_max_efforts",
"description":"\\[summary\\]\n\n**Raises:**\n\n * Exception: \\[description\\]\n\n**Returns:**\n\n * np.ndarray: \\[description\\]\n",
"snippet":"max_efforts = articulation_controller.get_max_efforts()\n",
"category":"method"
},
{
"title":"initialize",
"description":"\\[summary\\]\n\n**Args:**\n\n * `handle` (\\[type\\]): \\[description\\]\n * `dof_infos` (\\[type\\]): \\[description\\]\n",
"snippet":"articulation_controller.initialize(handle=handle, articulation_view=articulation_view)\n",
"category":"method"
},
{
"title":"set_effort_modes",
"description":"\\[summary\\]\n\n**Args:**\n\n * `mode` (str): \\[description\\]\n * `indices` (Optional\\[Union\\[np.ndarray, list\\]\\], optional): \\[description\\]. Defaults to None.\n\n**Raises:**\n\n * Exception: \\[description\\]\n    Exception: \\[description\\]\n",
"snippet":"articulation_controller.set_effort_modes(mode=mode)\n",
"category":"method"
},
{
"title":"set_gains",
"description":"\\[summary\\]\n\n**Args:**\n\n * `kps` (Optional\\[np.ndarray\\], optional): \\[description\\]. Defaults to None.\n * `kds` (Optional\\[np.ndarray\\], optional): \\[description\\]. Defaults to None.\n\n**Raises:**\n\n * Exception: \\[description\\]\n",
"snippet":"articulation_controller.set_gains()\n",
"category":"method"
},
{
"title":"set_max_efforts",
"description":"\\[summary\\]\n\n**Args:**\n\n * `value` (float, optional): \\[description\\]. Defaults to None.\n * `indices` (Optional\\[Union\\[np.ndarray, list\\]\\], optional): \\[description\\]. Defaults to None.\n\n**Raises:**\n\n * Exception: \\[description\\]\n",
"snippet":"articulation_controller.set_max_efforts(values=values)\n",
"category":"method"
},
{
"title":"switch_control_mode",
"description":"\\[summary\\]\n\n**Args:**\n\n * `mode` (str): \\[description\\]\n\n**Raises:**\n\n * Exception: \\[description\\]\n",
"snippet":"articulation_controller.switch_control_mode(mode=mode)\n",
"category":"method"
},
{
"title":"switch_dof_control_mode",
"description":"\\[summary\\]\n\n**Args:**\n\n * `dof_index` (int): \\[description\\]\n * `mode` (str): \\[description\\]\n\n**Raises:**\n\n * Exception: \\[description\\]\n",
"snippet":"articulation_controller.switch_dof_control_mode(dof_index=dof_index, mode=mode)\n",
"category":"method"
}
]
},
{
"title":"BaseController",
"snippets":[
{
"title":"import ...",
"description":"Import class",
"snippet":"from omni.isaac.core.controllers import BaseController\n",
"category":"import"
},
{
"title":"BaseController",
"description":"\\[summary\\]\n\n**Args:**\n\n * `name` (str): \\[description\\]\n",
"snippet":"base_controller = BaseController(name=name)\n",
"category":"class"
},
{
"title":"forward",
"description":"A controller should take inputs and returns an ArticulationAction to be then passed to the\nArticulationController.\nArgs:\nobservations (dict): \\[description\\]\nRaises:\nNotImplementedError: \\[description\\]\nReturns:\nArticulationAction: \\[description\\]\n",
"snippet":"value = base_controller.forward()\n",
"category":"method"
},
{
"title":"reset",
"description":"Resets state of the controller.\n",
"snippet":"base_controller.reset()\n",
"category":"method"
}
]
},
{
"title":"BaseGripperController",
"snippets":[
{
"title":"import ...",
"description":"Import class",
"snippet":"from omni.isaac.core.controllers import BaseGripperController\n",
"category":"import"
},
{
"title":"BaseGripperController",
"description":"\\[summary\\]\n\n**Args:**\n\n * `name` (str): \\[description\\]\n",
"snippet":"base_gripper_controller = BaseGripperController(name=name)\n",
"category":"class"
},
{
"title":"close",
"description":"\\[summary\\]\n\n**Args:**\n\n * `current_joint_positions` (np.ndarray): \\[description\\]\n\n**Raises:**\n\n * NotImplementedError: \\[description\\]\n\n**Returns:**\n\n * ArticulationAction: \\[description\\]\n",
"snippet":"value = base_gripper_controller.close(current_joint_positions=current_joint_positions)\n",
"category":"method"
},
{
"title":"forward",
"description":"Action has be \"open\" or \"close\"\n\n**Args:**\n\n * `action` (str): \"open\" or \"close\"\n * `current_joint_positions` (np.ndarray): \\[description\\]\n\n**Raises:**\n\n * Exception: \\[description\\]\n\n**Returns:**\n\n * ArticulationAction: \\[description\\]\n",
"snippet":"value = base_gripper_controller.forward(action=action, current_joint_positions=current_joint_positions)\n",
"category":"method"
},
{
"title":"forward",
"description":"A controller should take inputs and returns an ArticulationAction to be then passed to the\nArticulationController.\nArgs:\nobservations (dict): \\[description\\]\nRaises:\nNotImplementedError: \\[description\\]\nReturns:\nArticulationAction: \\[description\\]\n",
"snippet":"value = base_gripper_controller.forward()\n",
"category":"method"
},
{
"title":"open",
"description":"\\[summary\\]\n\n**Args:**\n\n * `current_joint_positions` (np.ndarray): \\[description\\]\n\n**Raises:**\n\n * NotImplementedError: \\[description\\]\n\n**Returns:**\n\n * ArticulationAction: \\[description\\]\n",
"snippet":"value = base_gripper_controller.open(current_joint_positions=current_joint_positions)\n",
"category":"method"
},
{
"title":"reset",
"description":"\\[summary\\]\n",
"snippet":"base_gripper_controller.reset()\n",
"category":"method"
},
{
"title":"reset",
"description":"Resets state of the controller.\n",
"snippet":"base_gripper_controller.reset()\n",
"category":"method"
}
]
}
]
},
{
"title":"DataLogger",
"snippets":[
{
"title":"import ...",
"description":"Import class",
"snippet":"from omni.isaac.core.loggers import DataLogger\n",
"category":"import"
},
{
"title":"DataLogger",
"description":"This class takes care of collecting data as well as reading already saved data in order to replay it for instance.\n",
"snippet":"data_logger = DataLogger()\n",
"category":"class"
},
{
"title":"add_data",
"description":"Adds data to the log\n\n**Args:**\n\n * `data` (dict): Dictionary representing the data to be logged at this time index.\n * `current_time_step` (float): time step corresponding to the data collected.\n * `current_time` (float): time in seconds corresponding to the data collected.\n",
"snippet":"data_logger.add_data(data=data, current_time_step=current_time_step, current_time=current_time)\n",
"category":"method"
},
{
"title":"add_data_frame_logging_func",
"description":"**Args:**\n\n    \\* `func` (Callable\\[\\[list\\[BaseTask\\], Scene\\], None\\]): function to be called at every step when the logger is started. should follow:\n    def dummy\\_data\\_collection\\_fn(tasks, scene): return {\"data 1\": \\[data\\]}\n",
"snippet":"data_logger.add_data_frame_logging_func(func=func)\n",
"category":"method"
},
{
"title":"get_data_frame",
"description":"**Args:**\n\n * `data_frame_index` (int): index of the data frame to retrieve.\n\n**Returns:**\n\n * DataFrame: Data Frame collected/ retrieved at the specified data frame index.\n",
"snippet":"data_frame = data_logger.get_data_frame(data_frame_index=data_frame_index)\n",
"category":"method"
},
{
"title":"get_num_of_data_frames",
"description":"**Returns:**\n\n * int: the number of data frames collected/ retrieved in the data logger.\n",
"snippet":"num_of_data_frames = data_logger.get_num_of_data_frames()\n",
"category":"method"
},
{
"title":"is_started",
"description":"**Returns:**\n\n * bool: True if data collection is started/ resumed. False otherwise.\n",
"snippet":"value = data_logger.is_started()\n",
"category":"method"
},
{
"title":"load",
"description":"Loads data from a json file to read back a previous saved data or to resume recording data from another time step.\n\n**Args:**\n\n * `log_path` (str): path of the json file to be used to load the data.\n",
"snippet":"data_logger.load(log_path=log_path)\n",
"category":"method"
},
{
"title":"pause",
"description":"Pauses data collection.\n",
"snippet":"data_logger.pause()\n",
"category":"method"
},
{
"title":"reset",
"description":"Clears the data in the logger.\n",
"snippet":"data_logger.reset()\n",
"category":"method"
},
{
"title":"save",
"description":"Saves the current data in the logger to a json file\n\n**Args:**\n\n * `log_path` (str): path of the json file to be used to save the data.\n",
"snippet":"data_logger.save(log_path=log_path)\n",
"category":"method"
},
{
"title":"start",
"description":"Resumes/ starts data collection.\n",
"snippet":"data_logger.start()\n",
"category":"method"
}
]
},
{
"title":"Materials",
"snippets":[
{
"title":"DeformableMaterial",
"snippets":[
{
"title":"import ...",
"description":"Import class",
"snippet":"from omni.isaac.core.materials import DeformableMaterial\n",
"category":"import"
},
{
"title":"DeformableMaterial",
"description":"A wrapper around deformable material used to simulate soft bodies.\n",
"snippet":"deformable_material = DeformableMaterial(prim_path=prim_path)\n",
"category":"class"
},
{
"title":"get_damping_scale",
"description":"**Returns:**\n\n * float: The damping scale coefficient.\n",
"snippet":"damping_scale = deformable_material.get_damping_scale()\n",
"category":"method"
},
{
"title":"get_dynamic_friction",
"description":"**Returns:**\n\n * float: The dynamic friction coefficient.\n",
"snippet":"dynamic_friction = deformable_material.get_dynamic_friction()\n",
"category":"method"
},
{
"title":"get_elasticity_damping",
"description":"**Returns:**\n\n * float: The elasticity damping coefficient.\n",
"snippet":"elasticity_damping = deformable_material.get_elasticity_damping()\n",
"category":"method"
},
{
"title":"get_poissons_ratio",
"description":"**Returns:**\n\n * float: The poissons ratio.\n",
"snippet":"poissons_ratio = deformable_material.get_poissons_ratio()\n",
"category":"method"
},
{
"title":"get_youngs_modululs",
"description":"**Returns:**\n\n * float: The youngs modululs coefficient.\n",
"snippet":"youngs_modululs = deformable_material.get_youngs_modululs()\n",
"category":"method"
},
{
"title":"initialize",
"description":"",
"snippet":"deformable_material.initialize()\n",
"category":"method"
},
{
"title":"is_valid",
"description":"**Returns:**\n\n * bool: True is the current prim path corresponds to a valid prim in stage. False otherwise.\n",
"snippet":"value = deformable_material.is_valid()\n",
"category":"method"
},
{
"title":"material",
"description":"**Returns:**\n\n * UsdShade.Material: The USD Material object.\n",
"snippet":"material = deformable_material.material\n",
"category":"property"
},
{
"title":"name",
"description":"**Returns:**\n\n * str: name given to the prim when instantiating it. Otherwise None.\n",
"snippet":"name = deformable_material.name\n",
"category":"property"
},
{
"title":"post_reset",
"description":"Resets the prim to its default state.\n",
"snippet":"deformable_material.post_reset()\n",
"category":"method"
},
{
"title":"prim",
"description":"**Returns:**\n\n * Usd.Prim: The USD prim present.\n",
"snippet":"prim = deformable_material.prim\n",
"category":"property"
},
{
"title":"prim_path",
"description":"**Returns:**\n\n * str: The stage path to the material.\n",
"snippet":"prim_path = deformable_material.prim_path\n",
"category":"property"
},
{
"title":"set_damping_scale",
"description":"Sets the damping scale coefficient.\n\n**Args:**\n\n * `value` (float): The damping scale coefficient Range: \\[0, inf)\n",
"snippet":"deformable_material.set_damping_scale(value=value)\n",
"category":"method"
},
{
"title":"set_dynamic_friction",
"description":"Sets the dynamic\\_friction coefficient.\n\nThe dynamic\\_friction takes effect in all interactions between particles and rigids or deformables.\nFor solid particle-particle interactions it is multiplied by the particle dynamic\\_friction scale.\n\n**Args:**\n\n * `value` (float): The dynamic\\_friction coefficient. Range: \\[0, inf), Units: dimensionless\n",
"snippet":"deformable_material.set_dynamic_friction(value=value)\n",
"category":"method"
},
{
"title":"set_elasticity_damping",
"description":"Sets the global velocity elasticity damping coefficient.\n\n**Args:**\n\n * `value` (float): The elasticity damping coefficient. Range: \\[0, inf), Units: dimensionless\n",
"snippet":"deformable_material.set_elasticity_damping(value=value)\n",
"category":"method"
},
{
"title":"set_poissons_ratio",
"description":"Sets the poissons ratio coefficient\n\n**Args:**\n\n * `value` (float): The poissons ratio. Range: (0 , 0.5)\n",
"snippet":"deformable_material.set_poissons_ratio(value=value)\n",
"category":"method"
},
{
"title":"set_youngs_modululs",
"description":"Sets the youngs\\_modululs for fluid particles.\n\n**Args:**\n\n * `value` (float): The youngs\\_modululs. Range: \\[0, inf)\n",
"snippet":"deformable_material.set_youngs_modululs(value=value)\n",
"category":"method"
}
]
},
{
"title":"DeformableMaterialView",
"snippets":[
{
"title":"import ...",
"description":"Import class",
"snippet":"from omni.isaac.core.materials import DeformableMaterialView\n",
"category":"import"
},
{
"title":"DeformableMaterialView",
"description":"The view class to deal with deformableMaterial prims.\nProvides high level functions to deal with deformable material (1 or more deformable materials)\nas well as its attributes/ properties. This object wraps all matching materials found at the regex provided at the prim\\_paths\\_expr.\nThis object wraps all matching materials Prims found at the regex provided at the prim\\_paths\\_expr.\n",
"snippet":"deformable_material_view = DeformableMaterialView(prim_paths_expr=prim_paths_expr)\n",
"category":"class"
},
{
"title":"count",
"description":"**Returns:**\n\n * int: number of rigid shapes for the prims in the view.\n",
"snippet":"count = deformable_material_view.count\n",
"category":"property"
},
{
"title":"get_damping_scales",
"description":"Gets the damping scale of materials indicated by the indices.\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which material prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor\\]: damping scale tensor with shape (M, )\n",
"snippet":"damping_scales = deformable_material_view.get_damping_scales()\n",
"category":"method"
},
{
"title":"get_dynamic_frictions",
"description":"Gets the dynamic friction of materials indicated by the indices.\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which material prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor\\]: dynamic friction tensor with shape (M, )\n",
"snippet":"dynamic_frictions = deformable_material_view.get_dynamic_frictions()\n",
"category":"method"
},
{
"title":"get_elasticity_dampings",
"description":"Gets the elasticity dampings of materials indicated by the indices.\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which material prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor\\]: elasticity dampings tensor with shape (M, )\n",
"snippet":"elasticity_dampings = deformable_material_view.get_elasticity_dampings()\n",
"category":"method"
},
{
"title":"get_poissons_ratios",
"description":"Gets the poissons ratios of materials indicated by the indices.\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which material prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor\\]: poissons ratio tensor with shape (M, )\n",
"snippet":"poissons_ratios = deformable_material_view.get_poissons_ratios()\n",
"category":"method"
},
{
"title":"get_youngs_moduli",
"description":"Gets the Youngs moduli of materials indicated by the indices.\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which material prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor\\]: Youngs moduli tensor with shape (M, )\n",
"snippet":"youngs_moduli = deformable_material_view.get_youngs_moduli()\n",
"category":"method"
},
{
"title":"initialize",
"description":"Create a physics simulation view if not passed and creates a rigid body view in physX.\n\n**Args:**\n\n * `physics_sim_view` (omni.physics.tensors.SimulationView, optional): current physics simulation view. Defaults to None.\n",
"snippet":"deformable_material_view.initialize()\n",
"category":"method"
},
{
"title":"is_physics_handle_valid",
"description":"**Returns:**\n\n * bool: True if the physics handle of the view is valid (i.e physics is initialized for the view). Otherwise False.\n",
"snippet":"value = deformable_material_view.is_physics_handle_valid()\n",
"category":"method"
},
{
"title":"is_valid",
"description":"**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Returns:**\n\n * bool: True if all prim paths specified in the view correspond to a valid prim in stage. False otherwise.\n",
"snippet":"value = deformable_material_view.is_valid()\n",
"category":"method"
},
{
"title":"name",
"description":"**Returns:**\n\n * str: name given to the view when instantiating it.\n",
"snippet":"name = deformable_material_view.name\n",
"category":"property"
},
{
"title":"post_reset",
"description":"Resets the deformables to their initial states.\n",
"snippet":"deformable_material_view.post_reset()\n",
"category":"method"
},
{
"title":"set_damping_scales",
"description":"Sets the damping scale for the material prims indicated by the indices.\n\n**Args:**\n\n * `values` (Optional\\[Union\\[np.ndarray, torch.Tensor\\]\\], optional): material damping scale tensor with the shape (M, ).\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which material prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n",
"snippet":"deformable_material_view.set_damping_scales(values=values)\n",
"category":"method"
},
{
"title":"set_dynamic_frictions",
"description":"Sets the dynamic friction for the material prims indicated by the indices.\n\n**Args:**\n\n * `values` (Optional\\[Union\\[np.ndarray, torch.Tensor\\]\\], optional): material dynamic friction tensor with the shape (M, ).\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which material prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n",
"snippet":"deformable_material_view.set_dynamic_frictions(values=values)\n",
"category":"method"
},
{
"title":"set_elasticity_dampings",
"description":"Sets the elasticity\\_dampings for the material prims indicated by the indices.\n\n**Args:**\n\n * `values` (Optional\\[Union\\[np.ndarray, torch.Tensor\\]\\], optional): material damping tensor with the shape (M, ).\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which material prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n",
"snippet":"deformable_material_view.set_elasticity_dampings(values=values)\n",
"category":"method"
},
{
"title":"set_poissons_ratios",
"description":"Sets the poissons ratios for the material prims indicated by the indices.\n\n**Args:**\n\n * `values` (Optional\\[Union\\[np.ndarray, torch.Tensor\\]\\], optional): material poissons ratio tensor with the shape (M, ).\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which material prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n",
"snippet":"deformable_material_view.set_poissons_ratios(values=values)\n",
"category":"method"
},
{
"title":"set_youngs_moduli",
"description":"Sets the youngs moduli for the material prims indicated by the indices.\n\n**Args:**\n\n * `values` (Optional\\[Union\\[np.ndarray, torch.Tensor\\]\\], optional): material drag tensor with the shape (M, ).\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which material prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n",
"snippet":"deformable_material_view.set_youngs_moduli(values=values)\n",
"category":"method"
}
]
},
{
"title":"OmniGlass",
"snippets":[
{
"title":"import ...",
"description":"Import class",
"snippet":"from omni.isaac.core.materials import OmniGlass\n",
"category":"import"
},
{
"title":"OmniGlass",
"description":"\\[summary\\]\n\n**Args:**\n\n * `prim_path` (str): \\[description\\]\n * `name` (str, optional): \\[description\\]. Defaults to \"omni\\_glass\".\n * `shader` (Optional\\[UsdShade.Shader\\], optional): \\[description\\]. Defaults to None.\n * `color` (Optional\\[np.ndarray\\], optional): \\[description\\]. Defaults to None.\n * `ior` (Optional\\[float\\], optional): \\[description\\]. Defaults to None.\n * `depth` (Optional\\[float\\], optional): \\[description\\]. Defaults to None.\n * `thin_walled` (Optional\\[bool\\], optional): \\[description\\]. Defaults to None.\n\n**Raises:**\n\n * Exception: \\[description\\]\n",
"snippet":"omni_glass = OmniGlass(prim_path=prim_path)\n",
"category":"class"
},
{
"title":"get_color",
"description":"\\[summary\\]\n\n**Returns:**\n\n * np.ndarray: \\[description\\]\n",
"snippet":"color = omni_glass.get_color()\n",
"category":"method"
},
{
"title":"get_depth",
"description":"",
"snippet":"depth = omni_glass.get_depth()\n",
"category":"method"
},
{
"title":"get_ior",
"description":"",
"snippet":"ior = omni_glass.get_ior()\n",
"category":"method"
},
{
"title":"get_thin_walled",
"description":"",
"snippet":"thin_walled = omni_glass.get_thin_walled()\n",
"category":"method"
},
{
"title":"set_color",
"description":"\\[summary\\]\n\n**Args:**\n\n * `color` (np.ndarray): \\[description\\]\n",
"snippet":"omni_glass.set_color(color=color)\n",
"category":"method"
},
{
"title":"set_depth",
"description":"",
"snippet":"omni_glass.set_depth(depth=depth)\n",
"category":"method"
},
{
"title":"set_ior",
"description":"",
"snippet":"omni_glass.set_ior(ior=ior)\n",
"category":"method"
},
{
"title":"set_thin_walled",
"description":"",
"snippet":"omni_glass.set_thin_walled(thin_walled=thin_walled)\n",
"category":"method"
}
]
},
{
"title":"OmniPBR",
"snippets":[
{
"title":"import ...",
"description":"Import class",
"snippet":"from omni.isaac.core.materials import OmniPBR\n",
"category":"import"
},
{
"title":"OmniPBR",
"description":"\\[summary\\]\n\n**Args:**\n\n * `prim_path` (str): \\[description\\]\n * `name` (str, optional): \\[description\\]. Defaults to \"omni\\_pbr\".\n * `shader` (Optional\\[UsdShade.Shader\\], optional): \\[description\\]. Defaults to None.\n * `texture_path` (Optional\\[str\\], optional): \\[description\\]. Defaults to None.\n * `texture_scale` (Optional\\[np.ndarray\\], optional): \\[description\\]. Defaults to None.\n * `texture_translate` (Optional\\[np.ndarray, optional): \\[description\\]. Defaults to None.\n * `color` (Optional\\[np.ndarray\\], optional): \\[description\\]. Defaults to None.\n",
"snippet":"omni_p_b_r = OmniPBR(prim_path=prim_path)\n",
"category":"class"
},
{
"title":"get_color",
"description":"\\[summary\\]\n\n**Returns:**\n\n * np.ndarray: \\[description\\]\n",
"snippet":"color = omni_p_b_r.get_color()\n",
"category":"method"
},
{
"title":"get_metallic_constant",
"description":"\\[summary\\]\n\n**Returns:**\n\n * float: \\[description\\]\n",
"snippet":"metallic_constant = omni_p_b_r.get_metallic_constant()\n",
"category":"method"
},
{
"title":"get_project_uvw",
"description":"\\[summary\\]\n\n**Returns:**\n\n * bool: \\[description\\]\n",
"snippet":"project_uvw = omni_p_b_r.get_project_uvw()\n",
"category":"method"
},
{
"title":"get_reflection_roughness",
"description":"\\[summary\\]\n\n**Returns:**\n\n * float: \\[description\\]\n",
"snippet":"reflection_roughness = omni_p_b_r.get_reflection_roughness()\n",
"category":"method"
},
{
"title":"get_texture",
"description":"\\[summary\\]\n\n**Returns:**\n\n * str: \\[description\\]\n",
"snippet":"texture = omni_p_b_r.get_texture()\n",
"category":"method"
},
{
"title":"get_texture_scale",
"description":"\\[summary\\]\n\n**Returns:**\n\n * np.ndarray: \\[description\\]\n",
"snippet":"texture_scale = omni_p_b_r.get_texture_scale()\n",
"category":"method"
},
{
"title":"get_texture_translate",
"description":"\\[summary\\]\n\n**Returns:**\n\n * np.ndarray: \\[description\\]\n",
"snippet":"texture_translate = omni_p_b_r.get_texture_translate()\n",
"category":"method"
},
{
"title":"set_color",
"description":"\\[summary\\]\n\n**Args:**\n\n * `color` (np.ndarray): \\[description\\]\n",
"snippet":"omni_p_b_r.set_color(color=color)\n",
"category":"method"
},
{
"title":"set_metallic_constant",
"description":"\\[summary\\]\n\n**Args:**\n\n * `amount` (float): \\[description\\]\n",
"snippet":"omni_p_b_r.set_metallic_constant(amount=amount)\n",
"category":"method"
},
{
"title":"set_project_uvw",
"description":"\\[summary\\]\n\n**Args:**\n\n * `flag` (bool): \\[description\\]\n",
"snippet":"omni_p_b_r.set_project_uvw(flag=flag)\n",
"category":"method"
},
{
"title":"set_reflection_roughness",
"description":"\\[summary\\]\n\n**Args:**\n\n * `amount` (float): \\[description\\]\n",
"snippet":"omni_p_b_r.set_reflection_roughness(amount=amount)\n",
"category":"method"
},
{
"title":"set_texture",
"description":"\\[summary\\]\n\n**Args:**\n\n * `path` (str): \\[description\\]\n",
"snippet":"omni_p_b_r.set_texture(path=path)\n",
"category":"method"
},
{
"title":"set_texture_scale",
"description":"\\[summary\\]\n\n**Args:**\n\n * `x` (float): \\[description\\]\n * `y` (float): \\[description\\]\n",
"snippet":"omni_p_b_r.set_texture_scale(x=x, y=y)\n",
"category":"method"
},
{
"title":"set_texture_translate",
"description":"\\[summary\\]\n\n**Args:**\n\n * `x` (float): \\[description\\]\n * `y` (float): \\[description\\]\n",
"snippet":"omni_p_b_r.set_texture_translate(x=x, y=y)\n",
"category":"method"
}
]
},
{
"title":"ParticleMaterial",
"snippets":[
{
"title":"import ...",
"description":"Import class",
"snippet":"from omni.isaac.core.materials import ParticleMaterial\n",
"category":"import"
},
{
"title":"ParticleMaterial",
"description":"A wrapper around position-based-dynamics (PBD) material for particles used to\nsimulate fluids, cloth and inflatables.\n\nNote:\n\n:   Currently, only a single material per particle system is supported which applies\n    to all objects that are associated with the system.\n",
"snippet":"particle_material = ParticleMaterial(prim_path=prim_path)\n",
"category":"class"
},
{
"title":"get_adhesion",
"description":"**Returns:**\n\n * float: The adhesion for interaction between particles (solid or fluid), and rigids or deformables.\n",
"snippet":"adhesion = particle_material.get_adhesion()\n",
"category":"method"
},
{
"title":"get_adhesion_offset_scale",
"description":"**Returns:**\n\n * float: The adhesion offset scale.\n",
"snippet":"adhesion_offset_scale = particle_material.get_adhesion_offset_scale()\n",
"category":"method"
},
{
"title":"get_cohesion",
"description":"**Returns:**\n\n * float: The cohesion for interaction between fluid particles.\n",
"snippet":"cohesion = particle_material.get_cohesion()\n",
"category":"method"
},
{
"title":"get_damping",
"description":"**Returns:**\n\n * float: The global velocity damping coefficient.\n",
"snippet":"damping = particle_material.get_damping()\n",
"category":"method"
},
{
"title":"get_drag",
"description":"**Returns:**\n\n * float: The drag coefficient, basic aerodynamic drag model coefficient.\n",
"snippet":"drag = particle_material.get_drag()\n",
"category":"method"
},
{
"title":"get_friction",
"description":"**Returns:**\n\n * float: The friction coefficient.\n",
"snippet":"friction = particle_material.get_friction()\n",
"category":"method"
},
{
"title":"get_gravity_scale",
"description":"**Returns:**\n\n * float: The gravitational acceleration scaling factor.\n",
"snippet":"gravity_scale = particle_material.get_gravity_scale()\n",
"category":"method"
},
{
"title":"get_lift",
"description":"**Returns:**\n\n * float: The lift coefficient, basic aerodynamic lift model coefficient.\n",
"snippet":"lift = particle_material.get_lift()\n",
"category":"method"
},
{
"title":"get_particle_adhesion_scale",
"description":"**Returns:**\n\n * float: The particle adhesion scale.\n",
"snippet":"particle_adhesion_scale = particle_material.get_particle_adhesion_scale()\n",
"category":"method"
},
{
"title":"get_particle_friction_scale",
"description":"**Returns:**\n\n * float: The particle friction scale.\n",
"snippet":"particle_friction_scale = particle_material.get_particle_friction_scale()\n",
"category":"method"
},
{
"title":"get_surface_tension",
"description":"**Returns:**\n\n * float: The surface tension for fluid particles.\n",
"snippet":"surface_tension = particle_material.get_surface_tension()\n",
"category":"method"
},
{
"title":"get_viscosity",
"description":"**Returns:**\n\n * float: The viscosity.\n",
"snippet":"viscosity = particle_material.get_viscosity()\n",
"category":"method"
},
{
"title":"get_vorticity_confinement",
"description":"**Returns:**\n\n * float: The vorticity confinement for fluid particles.\n",
"snippet":"vorticity_confinement = particle_material.get_vorticity_confinement()\n",
"category":"method"
},
{
"title":"initialize",
"description":"",
"snippet":"particle_material.initialize()\n",
"category":"method"
},
{
"title":"is_valid",
"description":"**Returns:**\n\n * bool: True is the current prim path corresponds to a valid prim in stage. False otherwise.\n",
"snippet":"value = particle_material.is_valid()\n",
"category":"method"
},
{
"title":"material",
"description":"**Returns:**\n\n * UsdShade.Material: The USD Material object.\n",
"snippet":"material = particle_material.material\n",
"category":"property"
},
{
"title":"name",
"description":"**Returns:**\n\n * str: name given to the prim when instantiating it. Otherwise None.\n",
"snippet":"name = particle_material.name\n",
"category":"property"
},
{
"title":"post_reset",
"description":"Resets the prim to its default state.\n",
"snippet":"particle_material.post_reset()\n",
"category":"method"
},
{
"title":"prim",
"description":"**Returns:**\n\n * Usd.Prim: The USD prim present.\n",
"snippet":"prim = particle_material.prim\n",
"category":"property"
},
{
"title":"prim_path",
"description":"**Returns:**\n\n * str: The stage path to the material.\n",
"snippet":"prim_path = particle_material.prim_path\n",
"category":"property"
},
{
"title":"set_adhesion",
"description":"Sets the adhesion for interaction between particles (solid or fluid), and rigid or deformable objects.\n\nNote:\n\n:   Adhesion also applies to solid-solid particle interactions, but is multiplied with the\n    particle adhesion scale.\n\n**Args:**\n\n * `value` (float): The adhesion. Range: \\[0, inf), Units: dimensionless\n",
"snippet":"particle_material.set_adhesion(value=value)\n",
"category":"method"
},
{
"title":"set_adhesion_offset_scale",
"description":"Sets the adhesion offset scale.\n\nIt defines the offset at which adhesion ceases to take effect. For interactions between\nparticles (fluid or solid), and rigids or deformables, the adhesion offset is defined\nrelative to the rest offset. For solid particle-particle interactions, the adhesion\noffset is defined relative to the solid rest offset.\n\n**Args:**\n\n * `value` (float): The adhesion offset scale. Range: \\[0, inf), Units: dimensionless\n",
"snippet":"particle_material.set_adhesion_offset_scale(value=value)\n",
"category":"method"
},
{
"title":"set_cohesion",
"description":"Sets the cohesion for interaction between fluid particles.\n\n**Args:**\n\n * `value` (float): The cohesion. Range: \\[0, inf), Units: dimensionless\n",
"snippet":"particle_material.set_cohesion(value=value)\n",
"category":"method"
},
{
"title":"set_damping",
"description":"Sets the global velocity damping coefficient.\n\n**Args:**\n\n * `value` (float): The damping coefficient. Range: \\[0, inf), Units: dimensionless\n",
"snippet":"particle_material.set_damping(value=value)\n",
"category":"method"
},
{
"title":"set_drag",
"description":"Sets the drag coefficient, i.e. basic aerodynamic drag model coefficient.\n\nIt is useful for cloth and inflatable particle objects.\n\n**Args:**\n\n * `value` (float): The drag coefficient. Range: \\[0, inf), Units: dimensionless\n",
"snippet":"particle_material.set_drag(value=value)\n",
"category":"method"
},
{
"title":"set_friction",
"description":"Sets the friction coefficient.\n\nThe friction takes effect in all interactions between particles and rigids or deformables.\nFor solid particle-particle interactions it is multiplied by the particle friction scale.\n\n**Args:**\n\n * `value` (float): The friction coefficient. Range: \\[0, inf), Units: dimensionless\n",
"snippet":"particle_material.set_friction(value=value)\n",
"category":"method"
},
{
"title":"set_gravity_scale",
"description":"Sets the gravitational acceleration scaling factor.\n\nIt can be used to approximate lighter-than-air inflatable.\nFor example (-1.0 would invert gravity).\n\n**Args:**\n\n * `value` (float): The gravity scale. Range: (-inf , inf), Units: dimensionless\n",
"snippet":"particle_material.set_gravity_scale(value=value)\n",
"category":"method"
},
{
"title":"set_lift",
"description":"Sets the lift coefficient, i.e. basic aerodynamic lift model coefficient.\n\nIt is useful for cloth and inflatable particle objects.\n\n**Args:**\n\n * `value` (float): The lift coefficient. Range: \\[0, inf), Units: dimensionless\n",
"snippet":"particle_material.set_lift(value=value)\n",
"category":"method"
},
{
"title":"set_particle_adhesion_scale",
"description":"Sets the particle adhesion scale.\n\nThis coefficient scales the adhesion for solid particle-particle interaction.\n\n**Args:**\n\n * `value` (float): The adhesion scale. Range: \\[0, inf), Units: dimensionless\n",
"snippet":"particle_material.set_particle_adhesion_scale(value=value)\n",
"category":"method"
},
{
"title":"set_particle_friction_scale",
"description":"Sets the particle friction scale.\n\nThe coefficient that scales friction for solid particle-particle interaction.\n\n**Args:**\n\n * `value` (float): The particle friction scale. Range: \\[0, inf), Units: dimensionless\n",
"snippet":"particle_material.set_particle_friction_scale(value=value)\n",
"category":"method"
},
{
"title":"set_surface_tension",
"description":"Sets the surface tension for fluid particles.\n\n**Args:**\n\n * `value` (float): The surface tension. Range: \\[0, inf), Units: 1 / (distance \\* distance \\* distance)\n",
"snippet":"particle_material.set_surface_tension(value=value)\n",
"category":"method"
},
{
"title":"set_viscosity",
"description":"Sets the viscosity for fluid particles.\n\n**Args:**\n\n * `value` (float): The viscosity. Range: \\[0, inf), Units: dimensionless\n",
"snippet":"particle_material.set_viscosity(value=value)\n",
"category":"method"
},
{
"title":"set_vorticity_confinement",
"description":"Sets the vorticity confinement for fluid particles.\n\nThis helps prevent energy loss due to numerical solver by adding vortex-like\naccelerations to the particles.\n\n**Args:**\n\n * `value` (float): The vorticity confinement. Range: \\[0, inf), Units: dimensionless\n",
"snippet":"particle_material.set_vorticity_confinement(value=value)\n",
"category":"method"
}
]
},
{
"title":"ParticleMaterialView",
"snippets":[
{
"title":"import ...",
"description":"Import class",
"snippet":"from omni.isaac.core.materials import ParticleMaterialView\n",
"category":"import"
},
{
"title":"ParticleMaterialView",
"description":"The view class to deal with particleMaterial prims.\nProvides high level functions to deal with particle material (1 or more particle materials)\nas well as its attributes/ properties. This object wraps all matching materials found at the regex provided at the prim\\_paths\\_expr.\nThis object wraps all matching materials Prims found at the regex provided at the prim\\_paths\\_expr.\n",
"snippet":"particle_material_view = ParticleMaterialView(prim_paths_expr=prim_paths_expr)\n",
"category":"class"
},
{
"title":"count",
"description":"**Returns:**\n\n * int: number of rigid shapes for the prims in the view.\n",
"snippet":"count = particle_material_view.count\n",
"category":"property"
},
{
"title":"get_adhesion_offset_scales",
"description":"Gets the adhesion offset scale of materials indicated by the indices.\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which material prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor\\]: adhesion offset scale tensor with shape (M, )\n",
"snippet":"adhesion_offset_scales = particle_material_view.get_adhesion_offset_scales()\n",
"category":"method"
},
{
"title":"get_adhesions",
"description":"Gets the adhesion of materials indicated by the indices.\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which material prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor\\]: adhesion tensor with shape (M, )\n",
"snippet":"adhesions = particle_material_view.get_adhesions()\n",
"category":"method"
},
{
"title":"get_cohesions",
"description":"Gets the cohesion of materials indicated by the indices.\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which material prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor\\]: cohesion tensor with shape (M, )\n",
"snippet":"cohesions = particle_material_view.get_cohesions()\n",
"category":"method"
},
{
"title":"get_dampings",
"description":"Gets the dampings of materials indicated by the indices.\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which material prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor\\]: dampings tensor with shape (M, )\n",
"snippet":"dampings = particle_material_view.get_dampings()\n",
"category":"method"
},
{
"title":"get_drags",
"description":"Gets the drags of materials indicated by the indices.\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which material prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor\\]: drag tensor with shape (M, )\n",
"snippet":"drags = particle_material_view.get_drags()\n",
"category":"method"
},
{
"title":"get_frictions",
"description":"Gets the friction of materials indicated by the indices.\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which material prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor\\]: friction tensor with shape (M, )\n",
"snippet":"frictions = particle_material_view.get_frictions()\n",
"category":"method"
},
{
"title":"get_gravity_scales",
"description":"Gets the gravity scale of materials indicated by the indices.\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which material prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor\\]: gravity scale tensor with shape (M, )\n",
"snippet":"gravity_scales = particle_material_view.get_gravity_scales()\n",
"category":"method"
},
{
"title":"get_lifts",
"description":"Gets the lifts of materials indicated by the indices.\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which material prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor\\]: lift tensor with shape (M, )\n",
"snippet":"lifts = particle_material_view.get_lifts()\n",
"category":"method"
},
{
"title":"get_particle_adhesion_scales",
"description":"Gets the adhesion scale of materials indicated by the indices.\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which material prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor\\]: adhesion scale tensor with shape (M, )\n",
"snippet":"particle_adhesion_scales = particle_material_view.get_particle_adhesion_scales()\n",
"category":"method"
},
{
"title":"get_particle_friction_scales",
"description":"Gets the particle friction scale of materials indicated by the indices.\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which material prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor\\]: particle friction scale tensor with shape (M, )\n",
"snippet":"particle_friction_scales = particle_material_view.get_particle_friction_scales()\n",
"category":"method"
},
{
"title":"get_surface_tensions",
"description":"Gets the surface tension of materials indicated by the indices.\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which material prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor\\]: surface tension tensor with shape (M, )\n",
"snippet":"surface_tensions = particle_material_view.get_surface_tensions()\n",
"category":"method"
},
{
"title":"get_viscosities",
"description":"Gets the viscosity of materials indicated by the indices.\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which material prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor\\]: viscosity tensor with shape (M, )\n",
"snippet":"viscosities = particle_material_view.get_viscosities()\n",
"category":"method"
},
{
"title":"get_vorticity_confinements",
"description":"Gets the vorticity confinement of materials indicated by the indices.\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which material prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor\\]: vorticity confinement tensor with shape (M, )\n",
"snippet":"vorticity_confinements = particle_material_view.get_vorticity_confinements()\n",
"category":"method"
},
{
"title":"initialize",
"description":"Create a physics simulation view if not passed and creates a rigid body view in physX.\n\n**Args:**\n\n * `physics_sim_view` (omni.physics.tensors.SimulationView, optional): current physics simulation view. Defaults to None.\n",
"snippet":"particle_material_view.initialize()\n",
"category":"method"
},
{
"title":"is_physics_handle_valid",
"description":"**Returns:**\n\n * bool: True if the physics handle of the view is valid (i.e physics is initialized for the view). Otherwise False.\n",
"snippet":"value = particle_material_view.is_physics_handle_valid()\n",
"category":"method"
},
{
"title":"is_valid",
"description":"**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Returns:**\n\n * bool: True if all prim paths specified in the view correspond to a valid prim in stage. False otherwise.\n",
"snippet":"value = particle_material_view.is_valid()\n",
"category":"method"
},
{
"title":"name",
"description":"**Returns:**\n\n * str: name given to the view when instantiating it.\n",
"snippet":"name = particle_material_view.name\n",
"category":"property"
},
{
"title":"post_reset",
"description":"Resets the particles to their initial states.\n",
"snippet":"particle_material_view.post_reset()\n",
"category":"method"
},
{
"title":"set_adhesion_offset_scales",
"description":"Sets the adhesion offset scale for the material prims indicated by the indices.\n\n**Args:**\n\n * `values` (Optional\\[Union\\[np.ndarray, torch.Tensor\\]\\], optional): material adhesion offset scale tensor with the shape (M, ).\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which material prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n",
"snippet":"particle_material_view.set_adhesion_offset_scales(values=values)\n",
"category":"method"
},
{
"title":"set_adhesions",
"description":"Sets the particle adhesion for the material prims indicated by the indices.\n\n**Args:**\n\n * `values` (Optional\\[Union\\[np.ndarray, torch.Tensor\\]\\], optional): material particle adhesion scale tensor with the shape (M, ).\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which material prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n",
"snippet":"particle_material_view.set_adhesions(values=values)\n",
"category":"method"
},
{
"title":"set_cohesions",
"description":"Sets the particle cohesion for the material prims indicated by the indices.\n\n**Args:**\n\n * `values` (Optional\\[Union\\[np.ndarray, torch.Tensor\\]\\], optional): material particle cohesion scale tensor with the shape (M, ).\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which material prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n",
"snippet":"particle_material_view.set_cohesions(values=values)\n",
"category":"method"
},
{
"title":"set_dampings",
"description":"Sets the dampings for the material prims indicated by the indices.\n\n**Args:**\n\n * `values` (Optional\\[Union\\[np.ndarray, torch.Tensor\\]\\], optional): material damping tensor with the shape (M, ).\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which material prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n",
"snippet":"particle_material_view.set_dampings(values=values)\n",
"category":"method"
},
{
"title":"set_drags",
"description":"Sets the drags for the material prims indicated by the indices.\n\n**Args:**\n\n * `values` (Optional\\[Union\\[np.ndarray, torch.Tensor\\]\\], optional): material drag tensor with the shape (M, ).\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which material prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n",
"snippet":"particle_material_view.set_drags(values=values)\n",
"category":"method"
},
{
"title":"set_frictions",
"description":"Sets the friction for the material prims indicated by the indices.\n\n**Args:**\n\n * `values` (Optional\\[Union\\[np.ndarray, torch.Tensor\\]\\], optional): material friction tensor with the shape (M, ).\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which material prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n",
"snippet":"particle_material_view.set_frictions(values=values)\n",
"category":"method"
},
{
"title":"set_gravity_scales",
"description":"Sets the gravity scale for the material prims indicated by the indices.\n\n**Args:**\n\n * `values` (Optional\\[Union\\[np.ndarray, torch.Tensor\\]\\], optional): material gravity scale tensor with the shape (M, ).\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which material prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n",
"snippet":"particle_material_view.set_gravity_scales(values=values)\n",
"category":"method"
},
{
"title":"set_lifts",
"description":"Sets the lifts for the material prims indicated by the indices.\n\n**Args:**\n\n * `values` (Optional\\[Union\\[np.ndarray, torch.Tensor\\]\\], optional): material lift tensor with the shape (M, ).\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which material prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n",
"snippet":"particle_material_view.set_lifts(values=values)\n",
"category":"method"
},
{
"title":"set_particle_adhesion_scales",
"description":"Sets the particle adhesion for the material prims indicated by the indices.\n\n**Args:**\n\n * `values` (Optional\\[Union\\[np.ndarray, torch.Tensor\\]\\], optional): material particle adhesion scale tensor with the shape (M, ).\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which material prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n",
"snippet":"particle_material_view.set_particle_adhesion_scales(values=values)\n",
"category":"method"
},
{
"title":"set_particle_friction_scales",
"description":"Sets the particle friction scale for the material prims indicated by the indices.\n\n**Args:**\n\n * `values` (Optional\\[Union\\[np.ndarray, torch.Tensor\\]\\], optional): material particle friction scale tensor with the shape (M, ).\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which material prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n",
"snippet":"particle_material_view.set_particle_friction_scales(values=values)\n",
"category":"method"
},
{
"title":"set_surface_tensions",
"description":"Sets the particle surface tension for the material prims indicated by the indices.\n\n**Args:**\n\n * `values` (Optional\\[Union\\[np.ndarray, torch.Tensor\\]\\], optional): material particle surface tension scale tensor with the shape (M, ).\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which material prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n",
"snippet":"particle_material_view.set_surface_tensions(values=values)\n",
"category":"method"
},
{
"title":"set_viscosities",
"description":"Sets the particle viscosity for the material prims indicated by the indices.\n\n**Args:**\n\n * `values` (Optional\\[Union\\[np.ndarray, torch.Tensor\\]\\], optional): material particle viscosity scale tensor with the shape (M, ).\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which material prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n",
"snippet":"particle_material_view.set_viscosities(values=values)\n",
"category":"method"
},
{
"title":"set_vorticity_confinements",
"description":"Sets the vorticity confinement for the material prims indicated by the indices.\n\n**Args:**\n\n * `values` (Optional\\[Union\\[np.ndarray, torch.Tensor\\]\\], optional): material particle vorticity confinement scale tensor with the shape (M, ).\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which material prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n",
"snippet":"particle_material_view.set_vorticity_confinements(values=values)\n",
"category":"method"
}
]
},
{
"title":"PhysicsMaterial",
"snippets":[
{
"title":"import ...",
"description":"Import class",
"snippet":"from omni.isaac.core.materials import PhysicsMaterial\n",
"category":"import"
},
{
"title":"PhysicsMaterial",
"description":"\\[summary\\]\n\n**Args:**\n\n * `prim_path` (str): \\[description\\]\n * `name` (str, optional): \\[description\\]. Defaults to \"physics\\_material\".\n * `static_friction` (Optional\\[float\\], optional): \\[description\\]. Defaults to None.\n * `dynamic_friction` (Optional\\[float\\], optional): \\[description\\]. Defaults to None.\n * `restitution` (Optional\\[float\\], optional): \\[description\\]. Defaults to None.\n",
"snippet":"physics_material = PhysicsMaterial(prim_path=prim_path)\n",
"category":"class"
},
{
"title":"get_dynamic_friction",
"description":"\\[summary\\]\n\n**Returns:**\n\n * float: \\[description\\]\n",
"snippet":"dynamic_friction = physics_material.get_dynamic_friction()\n",
"category":"method"
},
{
"title":"get_restitution",
"description":"\\[summary\\]\n\n**Returns:**\n\n * float: \\[description\\]\n",
"snippet":"restitution = physics_material.get_restitution()\n",
"category":"method"
},
{
"title":"get_static_friction",
"description":"\\[summary\\]\n\n**Returns:**\n\n * float: \\[description\\]\n",
"snippet":"static_friction = physics_material.get_static_friction()\n",
"category":"method"
},
{
"title":"material",
"description":"\\[summary\\]\n\n**Returns:**\n\n * UsdShade.Material: \\[description\\]\n",
"snippet":"material = physics_material.material\n",
"category":"property"
},
{
"title":"name",
"description":"\\[summary\\]\n\n**Returns:**\n\n * str: \\[description\\]\n",
"snippet":"name = physics_material.name\n",
"category":"property"
},
{
"title":"prim",
"description":"\\[summary\\]\n\n**Returns:**\n\n * Usd.Prim: \\[description\\]\n",
"snippet":"prim = physics_material.prim\n",
"category":"property"
},
{
"title":"prim_path",
"description":"\\[summary\\]\n\n**Returns:**\n\n * str: \\[description\\]\n",
"snippet":"prim_path = physics_material.prim_path\n",
"category":"property"
},
{
"title":"set_dynamic_friction",
"description":"\\[summary\\]\n\n**Args:**\n\n * `friction` (float): \\[description\\]\n",
"snippet":"physics_material.set_dynamic_friction(friction=friction)\n",
"category":"method"
},
{
"title":"set_restitution",
"description":"\\[summary\\]\n\n**Args:**\n\n * `restitution` (float): \\[description\\]\n",
"snippet":"physics_material.set_restitution(restitution=restitution)\n",
"category":"method"
},
{
"title":"set_static_friction",
"description":"\\[summary\\]\n\n**Args:**\n\n * `friction` (float): \\[description\\]\n",
"snippet":"physics_material.set_static_friction(friction=friction)\n",
"category":"method"
}
]
},
{
"title":"PreviewSurface",
"snippets":[
{
"title":"import ...",
"description":"Import class",
"snippet":"from omni.isaac.core.materials import PreviewSurface\n",
"category":"import"
},
{
"title":"PreviewSurface",
"description":"\\[summary\\]\n\n**Args:**\n\n * `prim_path` (str): \\[description\\]\n * `name` (str, optional): \\[description\\]. Defaults to \"preview\\_surface\".\n * `shader` (Optional\\[UsdShade.Shader\\], optional): \\[description\\]. Defaults to None.\n * `color` (Optional\\[np.ndarray\\], optional): \\[description\\]. Defaults to None.\n * `roughness` (Optional\\[float\\], optional): \\[description\\]. Defaults to None.\n * `metallic` (Optional\\[float\\], optional): \\[description\\]. Defaults to None.\n",
"snippet":"preview_surface = PreviewSurface(prim_path=prim_path)\n",
"category":"class"
},
{
"title":"get_color",
"description":"\\[summary\\]\n\n**Returns:**\n\n * np.ndarray: \\[description\\]\n",
"snippet":"color = preview_surface.get_color()\n",
"category":"method"
},
{
"title":"get_metallic",
"description":"\\[summary\\]\n\n**Returns:**\n\n * float: \\[description\\]\n",
"snippet":"metallic = preview_surface.get_metallic()\n",
"category":"method"
},
{
"title":"get_roughness",
"description":"\\[summary\\]\n\n**Returns:**\n\n * float: \\[description\\]\n",
"snippet":"roughness = preview_surface.get_roughness()\n",
"category":"method"
},
{
"title":"set_color",
"description":"\\[summary\\]\n\n**Args:**\n\n * `color` (np.ndarray): \\[description\\]\n",
"snippet":"preview_surface.set_color(color=color)\n",
"category":"method"
},
{
"title":"set_metallic",
"description":"\\[summary\\]\n\n**Args:**\n\n * `metallic` (float): \\[description\\]\n",
"snippet":"preview_surface.set_metallic(metallic=metallic)\n",
"category":"method"
},
{
"title":"set_roughness",
"description":"\\[summary\\]\n\n**Args:**\n\n * `roughness` (float): \\[description\\]\n",
"snippet":"preview_surface.set_roughness(roughness=roughness)\n",
"category":"method"
}
]
},
{
"title":"VisualMaterial",
"snippets":[
{
"title":"import ...",
"description":"Import class",
"snippet":"from omni.isaac.core.materials import VisualMaterial\n",
"category":"import"
},
{
"title":"VisualMaterial",
"description":"\\[summary\\]\n\n**Args:**\n\n * `name` (str): \\[description\\]\n * `prim_path` (str): \\[description\\]\n * `prim` (Usd.Prim): \\[description\\]\n * `shaders_list` (list\\[UsdShade.Shader\\]): \\[description\\]\n * `material` (UsdShade.Material): \\[description\\]\n",
"snippet":"visual_material = VisualMaterial(name=name, prim_path=prim_path, prim=prim, shaders_list=shaders_list, material=material)\n",
"category":"class"
},
{
"title":"material",
"description":"\\[summary\\]\n\n**Returns:**\n\n * UsdShade.Material: \\[description\\]\n",
"snippet":"material = visual_material.material\n",
"category":"property"
},
{
"title":"name",
"description":"\\[summary\\]\n\n**Returns:**\n\n * str: \\[description\\]\n",
"snippet":"name = visual_material.name\n",
"category":"property"
},
{
"title":"prim",
"description":"\\[summary\\]\n\n**Returns:**\n\n * Usd.Prim: \\[description\\]\n",
"snippet":"prim = visual_material.prim\n",
"category":"property"
},
{
"title":"prim_path",
"description":"\\[summary\\]\n\n**Returns:**\n\n * str: \\[description\\]\n",
"snippet":"prim_path = visual_material.prim_path\n",
"category":"property"
},
{
"title":"shaders_list",
"description":"\\[summary\\]\n\n**Returns:**\n\n * \\[type\\]: \\[description\\]\n",
"snippet":"shaders_list = visual_material.shaders_list\n",
"category":"property"
}
]
}
]
},
{
"title":"Objects",
"snippets":[
{
"title":"DynamicCapsule",
"snippets":[
{
"title":"import ...",
"description":"Import class",
"snippet":"from omni.isaac.core.objects import DynamicCapsule\n",
"category":"import"
},
{
"title":"DynamicCapsule",
"description":"High level wrapper to create/encapsulate a dynamic capsule\n\n*Note:*\nDynamic capsules (Capsule shape) have collisions (Collider API) and rigid body dynamics (Rigid Body API)\n\n**Args:**\n\n * `prim_path` (str): prim path of the Prim to encapsulate or create\n * `name` (str, optional): shortname to be used as a key by Scene class. Note: needs to be unique if the object is added to the Scene. Defaults to \"dynamic\\_capsule\".\n * `position` (Optional\\[Sequence\\[float\\]\\], optional): position in the world frame of the prim. shape is (3, ). Defaults to None, which means left unchanged.\n * `translation` (Optional\\[Sequence\\[float\\]\\], optional): translation in the local frame of the prim (with respect to its parent prim). shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the world/ local frame of the prim (depends if translation or position is specified). quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n * `scale` (Optional\\[Sequence\\[float\\]\\], optional): local scale to be applied to the prim's dimensions. shape is (3, ). Defaults to None, which means left unchanged.\n * `visible` (bool, optional): set to false for an invisible prim in the stage while rendering. Defaults to True.\n * `color` (Optional\\[np.ndarray\\], optional): color of the visual shape. Defaults to None, which means 50% gray\n * `radius` (Optional\\[float\\], optional): capsule radius. Defaults to None.\n * `height` (Optional\\[float\\], optional): capsule height. Defaults to None.\n * `visual_material` (Optional\\[VisualMaterial\\], optional): visual material to be applied to the held prim. Defaults to None. If not specified, a default visual material will be added.\n * `physics_material` (Optional\\[PhysicsMaterial\\], optional): physics material to be applied to the held prim. Defaults to None. If not specified, a default physics material will be added.\n * `mass` (Optional\\[float\\], optional): mass in kg. Defaults to None.\n * `density` (Optional\\[float\\], optional): density. Defaults to None.\n * `linear_velocity` (Optional\\[np.ndarray\\], optional): linear velocity in the world frame. Defaults to None.\n * `angular_velocity` (Optional\\[np.ndarray\\], optional): angular velocity in the world frame. Defaults to None.\n\n---\n**Example:**\n\n```python\n>>> from omni.isaac.core.objects import DynamicCapsule\n>>> import numpy as np\n>>>\n>>> # create a red fixed capsule of mass 1kg at the given path\n>>> prim = DynamicCapsule(\n...     prim_path=\"/World/Xform/Capsule\",\n...     radius=0.5,\n...     height=1.0,\n...     color=np.array([1.0, 0.0, 0.0]),\n...     mass=1.0\n... )\n>>> prim\n<omni.isaac.core.objects.capsule.DynamicCapsule object at 0x7f4ff915f8e0>\n```\n",
"snippet":"dynamic_capsule = DynamicCapsule(prim_path=prim_path)\n",
"category":"class"
},
{
"title":"apply_physics_material",
"description":"Used to apply physics material to the held prim and optionally its descendants.\n\n**Args:**\n\n * `physics_material` (PhysicsMaterial): physics material to be applied to the held prim. This where you want to define friction, restitution..etc. Note: if a physics material is not defined, the defaults will be used from PhysX.\n * `weaker_than_descendants` (bool, optional): True if the material shouldn't override the descendants materials, otherwise False. Defaults to False.\n\n---\n**Example:**\n\n```python\n>>> from omni.isaac.core.materials import PhysicsMaterial\n>>>\n>>> # create a rigid body physical material\n>>> material = PhysicsMaterial(\n...     prim_path=\"/World/physics_material/aluminum\",  # path to the material prim to create\n...     dynamic_friction=0.4,\n...     static_friction=1.1,\n...     restitution=0.1\n... )\n>>> prim.apply_physics_material(material)\n```\n",
"snippet":"dynamic_capsule.apply_physics_material(physics_material=physics_material)\n",
"category":"method"
},
{
"title":"apply_visual_material",
"description":"Apply visual material to the held prim and optionally its descendants.\n\n**Args:**\n\n * `visual_material` (VisualMaterial): visual material to be applied to the held prim. Currently supports PreviewSurface, OmniPBR and OmniGlass.\n * `weaker_than_descendants` (bool, optional): True if the material shouldn't override the descendants materials, otherwise False. Defaults to False.\n\n---\n**Example:**\n\n```python\n>>> from omni.isaac.core.materials import OmniGlass\n>>>\n>>> # create a dark-red glass visual material\n>>> material = OmniGlass(\n...     prim_path=\"/World/material/glass\",  # path to the material prim to create\n...     ior=1.25,\n...     depth=0.001,\n...     thin_walled=False,\n...     color=np.array([0.5, 0.0, 0.0])\n... )\n>>> prim.apply_visual_material(material)\n```\n",
"snippet":"dynamic_capsule.apply_visual_material(visual_material=visual_material)\n",
"category":"method"
},
{
"title":"disable_rigid_body_physics",
"description":"Disable the rigid body physics\n\nWhen disabled, the object will not be moved by external forces such as gravity and collisions\n\n---\n**Example:**\n\n```python\n>>> prim.disable_rigid_body_physics()\n```\n",
"snippet":"dynamic_capsule.disable_rigid_body_physics()\n",
"category":"method"
},
{
"title":"enable_rigid_body_physics",
"description":"Enable the rigid body physics\n\nWhen enabled, the object will be moved by external forces such as gravity and collisions\n\n---\n**Example:**\n\n```python\n>>> prim.enable_rigid_body_physics()\n```\n",
"snippet":"dynamic_capsule.enable_rigid_body_physics()\n",
"category":"method"
},
{
"title":"get_angular_velocity",
"description":"Get the angular velocity of the rigid body\n\n**Returns:**\n\n * np.ndarray: current angular velocity of the the rigid prim. Shape (3,).\n\n---\n**Example:**\n\n```python\n>>> prim.get_angular_velocity()]\n[-0.01727393  0.00827609 -0.00040014]\n```\n",
"snippet":"dynamic_capsule.get_angular_velocity()\n",
"category":"method"
},
{
"title":"get_applied_physics_material",
"description":"Return the current applied physics material in case it was applied using apply\\_physics\\_material or not.\n\n**Returns:**\n\n * PhysicsMaterial: the current applied physics material.\n\n---\n**Example:**\n\n```python\n>>> # given a physics material applied\n>>> prim.get_applied_physics_material()\n<omni.isaac.core.materials.physics_material.PhysicsMaterial object at 0x7fb66c30cd30>\n```\n",
"snippet":"applied_physics_material = dynamic_capsule.get_applied_physics_material()\n",
"category":"method"
},
{
"title":"get_applied_visual_material",
"description":"Return the current applied visual material in case it was applied using apply\\_visual\\_material\nor it's one of the following materials that was already applied before: PreviewSurface, OmniPBR and OmniGlass.\n\n**Returns:**\n\n * VisualMaterial: the current applied visual material if its type is currently supported.\n\n---\n**Example:**\n\n```python\n>>> # given a visual material applied\n>>> prim.get_applied_visual_material()\n<omni.isaac.core.materials.omni_glass.OmniGlass object at 0x7f36263106a0>\n```\n",
"snippet":"applied_visual_material = dynamic_capsule.get_applied_visual_material()\n",
"category":"method"
},
{
"title":"get_collision_approximation",
"description":"Get the collision approximation\n\n| Approximation           | Full name            | Description                                                                               |\n|-------------------------|----------------------|-------------------------------------------------------------------------------------------|\n| `\"none\"`                | Triangle Mesh        | The mesh geometry is used directly as a collider without any approximation                |\n| `\"convexDecomposition\"` | Convex Decomposition | A convex mesh decomposition is performed. This results in a set of convex mesh colliders  |\n| `\"convexHull\"`          | Convex Hull          | A convex hull of the mesh is generated and used as the collider                           |\n| `\"boundingSphere\"`      | Bounding Sphere      | A bounding sphere is computed around the mesh and used as a collider                      |\n| `\"boundingCube\"`        | Bounding Cube        | An optimally fitting box collider is computed around the mesh                             |\n| `\"meshSimplification\"`  | Mesh Simplification  | A mesh simplification step is performed, resulting in a simplified triangle mesh collider |\n| `\"sdf\"`                 | SDF Mesh             | SDF (Signed-Distance-Field) use high-detail triangle meshes as collision shape            |\n| `\"sphereFill\"`          | Sphere Approximation | A sphere mesh decomposition is performed. This results in a set of sphere colliders       |\n\n**Returns:**\n\n * str: approximation used for collision\n\n---\n**Example:**\n\n```python\n>>> prim.get_collision_approximation()\nnone\n```\n",
"snippet":"collision_approximation = dynamic_capsule.get_collision_approximation()\n",
"category":"method"
},
{
"title":"get_collision_enabled",
"description":"Check if the Collision API is enabled\n\n**Returns:**\n\n * bool: True if the Collision API is enabled. Otherwise False\n\n---\n**Example:**\n\n```python\n>>> prim.get_collision_enabled()\nTrue\n```\n",
"snippet":"collision_enabled = dynamic_capsule.get_collision_enabled()\n",
"category":"method"
},
{
"title":"get_contact_force_matrix",
"description":"If the object is initialized with filter\\_paths\\_expr list, this method returns the contact forces between the prims\nin the view and the filter prims. i.e., a matrix of dimension (self.\\_contact\\_view.num\\_filters, 3)\nwhere num\\_filters is the determined according to the filter\\_paths\\_expr parameter.\n\n**Args:**\n\n * `dt` (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor\\]: Net contact forces of the prims with shape (self.\\_geometry\\_prim\\_view.\\_contact\\_view.num\\_filters, 3).\n",
"snippet":"contact_force_matrix = dynamic_capsule.get_contact_force_matrix()\n",
"category":"method"
},
{
"title":"get_contact_offset",
"description":"Get the contact offset\n\nShapes whose distance is less than the sum of their contact offset values will generate contacts\n\nSearch for *Advanced Collision Detection* in for more details\n\n**Returns:**\n\n * float: contact offset of the collision shape. Default value is -inf, means default is picked by simulation.\n\n---\n**Example:**\n\n```python\n>>> prim.get_contact_offset()\n-inf\n```\n",
"snippet":"contact_offset = dynamic_capsule.get_contact_offset()\n",
"category":"method"
},
{
"title":"get_current_dynamic_state",
"description":"Get the current rigid body state (position, orientation and linear and angular velocities)\n\n**Returns:**\n\n * DynamicState: the dynamic state of the rigid body prim\n\n---\n**Example:**\n\n```python\n>>> # for the example the rigid body is in free fall\n>>> state = prim.get_current_dynamic_state()\n>>> state\n<omni.isaac.core.utils.types.DynamicState object at 0x7f740b36f670>\n>>> state.position\n[  0.99999857   2.0000017  -74.2862    ]\n>>> state.orientation\n[ 1.0000000e+00 -2.3961178e-07 -4.9891562e-09  4.9388258e-09]\n>>> state.linear_velocity\n[  0.        0.      -38.09554]\n>>> state.angular_velocity\n[0. 0. 0.]\n```\n",
"snippet":"current_dynamic_state = dynamic_capsule.get_current_dynamic_state()\n",
"category":"method"
},
{
"title":"get_default_state",
"description":"Get the default rigid body state (position, orientation and linear and angular velocities)\n\n**Returns:**\n\n * DynamicState: returns the default state of the prim that is used after each reset\n\n---\n**Example:**\n\n```python\n>>> state = prim.get_default_state()\n>>> state\n<omni.isaac.core.utils.types.DynamicState object at 0x7f7411fcbe20>\n>>> state.position\n[-7.8622378e-07  1.4450421e-06  1.6135601e-07]\n>>> state.orientation\n[ 9.9999994e-01 -2.7194994e-07  2.9607077e-07  2.7016510e-08]\n>>> state.linear_velocity\n[0. 0. 0.]\n>>> state.angular_velocity\n[0. 0. 0.]\n```\n",
"snippet":"default_state = dynamic_capsule.get_default_state()\n",
"category":"method"
},
{
"title":"get_default_state",
"description":"Get the default prim states (spatial position and orientation).\n\n**Returns:**\n\n * XFormPrimState: an object that contains the default state of the prim (position and orientation)\n\n---\n**Example:**\n\n```python\n>>> state = prim.get_default_state()\n>>> state\n<omni.isaac.core.utils.types.XFormPrimState object at 0x7f33addda650>\n>>>\n>>> state.position\n[-4.5299529e-08 -1.8347054e-09 -2.8610229e-08]\n>>> state.orientation\n[1. 0. 0. 0.]\n```\n",
"snippet":"default_state = dynamic_capsule.get_default_state()\n",
"category":"method"
},
{
"title":"get_density",
"description":"Get the density of the rigid body\n\n**Returns:**\n\n * float: density of the rigid body.\n\n---\n**Example:**\n\n```python\n>>> prim.get_density()\n0\n```\n",
"snippet":"density = dynamic_capsule.get_density()\n",
"category":"method"
},
{
"title":"get_height",
"description":"Get the capsule height\n\n**Returns:**\n\n * float: capsule height\n\n---\n**Example:**\n\n```python\n>>> prim.get_height()\n1.0\n```\n",
"snippet":"height = dynamic_capsule.get_height()\n",
"category":"method"
},
{
"title":"get_linear_velocity",
"description":"Get the linear velocity of the rigid body\n\n**Returns:**\n\n * np.ndarray: current linear velocity of the the rigid prim. Shape (3,).\n\n---\n**Example:**\n\n```python\n>>> prim.get_linear_velocity()\n[ 1.0812164e-04  6.1415871e-05 -2.1341663e-04]\n```\n",
"snippet":"linear_velocity = dynamic_capsule.get_linear_velocity()\n",
"category":"method"
},
{
"title":"get_local_pose",
"description":"Get prim's pose with respect to the local frame (the prim's parent frame)\n\n**Returns:**\n\n * Tuple\\[np.ndarray, np.ndarray\\]: first index is the position in the local frame (with shape (3, )).\n    Second index is quaternion orientation (with shape (4, )) in the local frame\n\n---\n**Example:**\n\n```python\n>>> # if the prim is in position (1.0, 0.5, 0.0) with respect to the world frame\n>>> position, orientation = prim.get_local_pose()\n>>> position\n[0. 0. 0.]\n>>> orientation\n[0. 0. 0.]\n```\n",
"snippet":"local_pose = dynamic_capsule.get_local_pose()\n",
"category":"method"
},
{
"title":"get_local_scale",
"description":"Get prim's scale with respect to the local frame (the parent's frame)\n\n**Returns:**\n\n * np.ndarray: scale applied to the prim's dimensions in the local frame. shape is (3, ).\n\n---\n**Example:**\n\n```python\n>>> prim.get_local_scale()\n[1. 1. 1.]\n```\n",
"snippet":"local_scale = dynamic_capsule.get_local_scale()\n",
"category":"method"
},
{
"title":"get_mass",
"description":"Get the mass of the rigid body\n\n**Returns:**\n\n * float: mass of the rigid body in kg.\n\n---\n**Example:**\n\n```python\n>>> prim.get_mass()\n0\n```\n",
"snippet":"mass = dynamic_capsule.get_mass()\n",
"category":"method"
},
{
"title":"get_min_torsional_patch_radius",
"description":"Get the minimum radius of the contact patch used to apply torsional friction\n\nSearch for *\"Torsional Patch Radius\"* in for more details\n\n**Returns:**\n\n * float: minimum radius of the contact patch used to apply torsional friction. Allowed range \\[0, max\\_float\\].\n\n---\n**Example:**\n\n```python\n>>> prim.get_min_torsional_patch_radius()\n0.0\n```\n",
"snippet":"min_torsional_patch_radius = dynamic_capsule.get_min_torsional_patch_radius()\n",
"category":"method"
},
{
"title":"get_net_contact_forces",
"description":"If contact forces of the prims in the view are tracked, this method returns the net contact forces on prims.\ni.e., a matrix of dimension (1, 3)\n\n**Args:**\n\n * `dt` (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor\\]: Net contact forces of the prims with shape (3).\n",
"snippet":"net_contact_forces = dynamic_capsule.get_net_contact_forces()\n",
"category":"method"
},
{
"title":"get_radius",
"description":"Get the capsule radius\n\n**Returns:**\n\n * float: capsule radius\n\n---\n**Example:**\n\n```python\n>>> prim.get_radius()\n0.5\n```\n",
"snippet":"radius = dynamic_capsule.get_radius()\n",
"category":"method"
},
{
"title":"get_rest_offset",
"description":"Get the rest offset\n\nTwo shapes will come to rest at a distance equal to the sum of their rest offset values.\nIf the rest offset is 0, they should converge to touching exactly\n\nSearch for *Advanced Collision Detection* in for more details\n\n**Returns:**\n\n * float: rest offset of the collision shape.\n\n---\n**Example:**\n\n```python\n>>> prim.get_rest_offset()\n-inf\n```\n",
"snippet":"rest_offset = dynamic_capsule.get_rest_offset()\n",
"category":"method"
},
{
"title":"get_sleep_threshold",
"description":"Get the threshold for the rigid body to enter a sleep state\n\nSearch for *Rigid Body Dynamics* \\> *Sleeping* in for more details\n\n**Returns:**\n\n * float: Mass-normalized kinetic energy threshold below which an actor may go to sleep. Range: \\[0, inf) Defaults: 0.00005 \\* tolerancesSpeed\\* tolerancesSpeed Units: distance\\^2 / second\\^2.\n\n---\n**Example:**\n\n```python\n>>> prim.get_sleep_threshold()\n5e-05\n```\n",
"snippet":"sleep_threshold = dynamic_capsule.get_sleep_threshold()\n",
"category":"method"
},
{
"title":"get_torsional_patch_radius",
"description":"Get the radius of the contact patch used to apply torsional friction\n\nSearch for *\"Torsional Patch Radius\"* in for more details\n\n**Returns:**\n\n * float: radius of the contact patch used to apply torsional friction. Allowed range \\[0, max\\_float\\].\n\n---\n**Example:**\n\n```python\n>>> prim.get_torsional_patch_radius()\n0.0\n```\n",
"snippet":"torsional_patch_radius = dynamic_capsule.get_torsional_patch_radius()\n",
"category":"method"
},
{
"title":"get_visibility",
"description":"**Returns:**\n\n * bool: true if the prim is visible in stage. false otherwise.\n\n---\n**Example:**\n\n```python\n>>> # get the visible state of an visible prim on the stage\n>>> prim.get_visibility()\nTrue\n```\n",
"snippet":"visibility = dynamic_capsule.get_visibility()\n",
"category":"method"
},
{
"title":"get_world_pose",
"description":"Get prim's pose with respect to the world's frame\n\n**Returns:**\n\n * Tuple\\[np.ndarray, np.ndarray\\]: first index is the position in the world frame (with shape (3, )).\n    Second index is quaternion orientation (with shape (4, )) in the world frame\n\n---\n**Example:**\n\n```python\n>>> # if the prim is in position (1.0, 0.5, 0.0) with respect to the world frame\n>>> position, orientation = prim.get_world_pose()\n>>> position\n[1.  0.5 0. ]\n>>> orientation\n[1. 0. 0. 0.]\n```\n",
"snippet":"world_pose = dynamic_capsule.get_world_pose()\n",
"category":"method"
},
{
"title":"get_world_scale",
"description":"Get prim's scale with respect to the world's frame\n\n**Returns:**\n\n * np.ndarray: scale applied to the prim's dimensions in the world frame. shape is (3, ).\n\n---\n**Example:**\n\n```python\n>>> prim.get_world_scale()\n[1. 1. 1.]\n```\n",
"snippet":"world_scale = dynamic_capsule.get_world_scale()\n",
"category":"method"
},
{
"title":"initialize",
"description":"Create a physics simulation view if not passed and using PhysX tensor API\n\n*Note:*\nIf the prim has been added to the world scene (e.g., `world.scene.add(prim)`),\nit will be automatically initialized when the world is reset (e.g., `world.reset()`).\n\n**Args:**\n\n * `physics_sim_view` (omni.physics.tensors.SimulationView, optional): current physics simulation view. Defaults to None.\n\n---\n**Example:**\n\n```python\n>>> prim.initialize()\n```\n",
"snippet":"dynamic_capsule.initialize()\n",
"category":"method"
},
{
"title":"is_valid",
"description":"Check if the prim path has a valid USD Prim at it\n\n**Returns:**\n\n * bool: True is the current prim path corresponds to a valid prim in stage. False otherwise.\n\n---\n**Example:**\n\n```python\n>>> # given an existing and valid prim\n>>> prims.is_valid()\nTrue\n```\n",
"snippet":"value = dynamic_capsule.is_valid()\n",
"category":"method"
},
{
"title":"is_visual_material_applied",
"description":"Check if there is a visual material applied\n\n**Returns:**\n\n * bool: True if there is a visual material applied. False otherwise.\n\n---\n**Example:**\n\n```python\n>>> # given a visual material applied\n>>> prim.is_visual_material_applied()\nTrue\n```\n",
"snippet":"value = dynamic_capsule.is_visual_material_applied()\n",
"category":"method"
},
{
"title":"post_reset",
"description":"Reset the prim to its default state (position and orientation).\n\n*Note:*\nFor an articulation, in addition to configuring the root prim's default position and spatial orientation\n(defined via the `set_default_state` method), the joint's positions, velocities, and efforts\n(defined via the `set_joints_default_state` method) are imposed\n\n---\n**Example:**\n\n```python\n>>> prim.post_reset()\n```\n",
"snippet":"dynamic_capsule.post_reset()\n",
"category":"method"
},
{
"title":"set_angular_velocity",
"description":"Set the angular velocity of the rigid body in stage\n\n*Warning:*\nThis method will immediately set the articulation state\n\n**Args:**\n\n * `velocity` (np.ndarray): angular velocity to set the rigid prim to. Shape (3,).\n\n*Hint:*\nThis method belongs to the methods used to set the rigid prim kinematic state:\n\n> `set_linear_velocity`, `set_angular_velocity`\n\n---\n**Example:**\n\n```python\n>>> prim.set_angular_velocity(np.array([0.0, 0.0, 10.0]))\n```\n",
"snippet":"dynamic_capsule.set_angular_velocity(velocity=velocity)\n",
"category":"method"
},
{
"title":"set_collision_approximation",
"description":"Set the collision approximation\n\n| Approximation           | Full name            | Description                                                                               |\n|-------------------------|----------------------|-------------------------------------------------------------------------------------------|\n| `\"none\"`                | Triangle Mesh        | The mesh geometry is used directly as a collider without any approximation                |\n| `\"convexDecomposition\"` | Convex Decomposition | A convex mesh decomposition is performed. This results in a set of convex mesh colliders  |\n| `\"convexHull\"`          | Convex Hull          | A convex hull of the mesh is generated and used as the collider                           |\n| `\"boundingSphere\"`      | Bounding Sphere      | A bounding sphere is computed around the mesh and used as a collider                      |\n| `\"boundingCube\"`        | Bounding Cube        | An optimally fitting box collider is computed around the mesh                             |\n| `\"meshSimplification\"`  | Mesh Simplification  | A mesh simplification step is performed, resulting in a simplified triangle mesh collider |\n| `\"sdf\"`                 | SDF Mesh             | SDF (Signed-Distance-Field) use high-detail triangle meshes as collision shape            |\n| `\"sphereFill\"`          | Sphere Approximation | A sphere mesh decomposition is performed. This results in a set of sphere colliders       |\n\n*Warning:*\nSwitching to Convex Decomposition or SDF (Signed-Distance-Field) will have a simulation performance\nimpact due to higher computational cost\n\n**Args:**\n\n * `approximation_type` (str): approximation used for collision\n\n---\n**Example:**\n\n```python\n>>> prim.set_collision_approximation(\"convexDecomposition\")\n```\n",
"snippet":"dynamic_capsule.set_collision_approximation(approximation_type=approximation_type)\n",
"category":"method"
},
{
"title":"set_collision_enabled",
"description":"Enable/disable the Collision API\n\n**Args:**\n\n * `enabled` (bool): Whether to enable or disable the Collision API\n\n---\n**Example:**\n\n```python\n>>> # disable collisions\n>>> prim.set_collision_enabled(False)\n```\n",
"snippet":"dynamic_capsule.set_collision_enabled(enabled=enabled)\n",
"category":"method"
},
{
"title":"set_contact_offset",
"description":"Set the contact offset\n\nShapes whose distance is less than the sum of their contact offset values will generate contacts\n\nSearch for *Advanced Collision Detection* in for more details\n\n*Warning:*\nThe contact offset must be positive and greater than the rest offset\n\n**Args:**\n\n * `offset` (float): Contact offset of a collision shape. Allowed range \\[maximum(0, rest\\_offset), 0\\]. Default value is -inf, means default is picked by simulation based on the shape extent.\n\n---\n**Example:**\n\n```python\n>>> prim.set_contact_offset(0.02)\n```\n",
"snippet":"dynamic_capsule.set_contact_offset(offset=offset)\n",
"category":"method"
},
{
"title":"set_default_state",
"description":"Set the default state of the prim (position, orientation and linear and angular velocities),\nthat will be used after each reset\n\n*Note:*\nThe default states will be set during post-reset (e.g., calling `.post_reset()` or `world.reset()` methods)\n\n**Args:**\n\n * `position` (Optional\\[Sequence\\[float\\]\\], optional): position in the world frame of the prim. shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the world frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n * `linear_velocity` (np.ndarray): linear velocity to set the rigid prim to. Shape (3,).\n * `angular_velocity` (np.ndarray): angular velocity to set the rigid prim to. Shape (3,).\n\n---\n**Example:**\n\n```python\n>>> prim.set_default_state(\n...     position=np.array([1.0, 2.0, 3.0]),\n...     orientation=np.array([1.0, 0.0, 0.0, 0.0]),\n...     linear_velocity=np.array([0.0, 0.0, 0.0]),\n...     angular_velocity=np.array([0.0, 0.0, 0.0])\n... )\n>>>\n>>> prim.post_reset()\n```\n",
"snippet":"dynamic_capsule.set_default_state()\n",
"category":"method"
},
{
"title":"set_default_state",
"description":"Set the default state of the prim (position and orientation), that will be used after each reset.\n\n**Args:**\n\n * `position` (Optional\\[Sequence\\[float\\]\\], optional): position in the world frame of the prim. shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the world frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n\n---\n**Example:**\n\n```python\n>>> # configure default state\n>>> prim.set_default_state(position=np.array([1.0, 0.5, 0.0]), orientation=np.array([1, 0, 0, 0]))\n>>>\n>>> # set default states during post-reset\n>>> prim.post_reset()\n```\n",
"snippet":"dynamic_capsule.set_default_state()\n",
"category":"method"
},
{
"title":"set_density",
"description":"Set the density of the rigid body\n\n**Args:**\n\n * `mass` (float): density of the rigid body.\n\n---\n**Example:**\n\n```python\n>>> prim.set_density(0.9)\n```\n",
"snippet":"dynamic_capsule.set_density(density=density)\n",
"category":"method"
},
{
"title":"set_height",
"description":"Set the capsule height\n\n**Args:**\n\n * `height` (float): capsule height\n\n---\n**Example:**\n\n```python\n>>> prim.set_height(2.0)\n```\n",
"snippet":"dynamic_capsule.set_height(height=height)\n",
"category":"method"
},
{
"title":"set_linear_velocity",
"description":"Set the linear velocity of the rigid body in stage\n\n*Warning:*\nThis method will immediately set the rigid prim state\n\n**Args:**\n\n * `velocity` (np.ndarray): linear velocity to set the rigid prim to. Shape (3,).\n\n*Hint:*\nThis method belongs to the methods used to set the rigid prim kinematic state:\n\n> `set_linear_velocity`, `set_angular_velocity`\n\n---\n**Example:**\n\n```python\n>>> prim.set_linear_velocity(np.array([5.0, 0.0, 0.0]))\n```\n",
"snippet":"dynamic_capsule.set_linear_velocity(velocity=velocity)\n",
"category":"method"
},
{
"title":"set_local_pose",
"description":"Set prim's pose with respect to the local frame (the prim's parent frame).\n\n*Warning:*\nThis method will change (teleport) the prim pose immediately to the indicated value\n\n**Args:**\n\n * `translation` (Optional\\[Sequence\\[float\\]\\], optional): translation in the local frame of the prim (with respect to its parent prim). shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the local frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n\n*Hint:*\nThis method belongs to the methods used to set the prim state\n\n---\n**Example:**\n\n```python\n>>> prim.set_local_pose(translation=np.array([1.0, 0.5, 0.0]), orientation=np.array([1., 0., 0., 0.]))\n```\n",
"snippet":"dynamic_capsule.set_local_pose()\n",
"category":"method"
},
{
"title":"set_local_scale",
"description":"Set prim's scale with respect to the local frame (the prim's parent frame).\n\n**Args:**\n\n * `scale` (Optional\\[Sequence\\[float\\]\\]): scale to be applied to the prim's dimensions. shape is (3, ). Defaults to None, which means left unchanged.\n\n---\n**Example:**\n\n```python\n>>> # scale prim 10 times smaller\n>>> prim.set_local_scale(np.array([0.1, 0.1, 0.1]))\n```\n",
"snippet":"dynamic_capsule.set_local_scale(scale=scale)\n",
"category":"method"
},
{
"title":"set_mass",
"description":"Set the mass of the rigid body\n\n**Args:**\n\n * `mass` (float): mass of the rigid body in kg.\n\n---\n**Example:**\n\n```python\n>>> prim.set_mass(1.0)\n```\n",
"snippet":"dynamic_capsule.set_mass(mass=mass)\n",
"category":"method"
},
{
"title":"set_min_torsional_patch_radius",
"description":"Set the minimum radius of the contact patch used to apply torsional friction\n\nSearch for *\"Torsional Patch Radius\"* in for more details\n\n**Args:**\n\n * `radius` (float): minimum radius of the contact patch used to apply torsional friction. Allowed range \\[0, max\\_float\\].\n\n---\n**Example:**\n\n```python\n>>> prim.set_min_torsional_patch_radius(0.05)\n```\n",
"snippet":"dynamic_capsule.set_min_torsional_patch_radius(radius=radius)\n",
"category":"method"
},
{
"title":"set_radius",
"description":"Set the capsule radius\n\n**Args:**\n\n * `radius` (float): capsule radius\n\n---\n**Example:**\n\n```python\n>>> prim.set_radius(1.0)\n```\n",
"snippet":"dynamic_capsule.set_radius(radius=radius)\n",
"category":"method"
},
{
"title":"set_rest_offset",
"description":"Set the rest offset\n\nTwo shapes will come to rest at a distance equal to the sum of their rest offset values.\nIf the rest offset is 0, they should converge to touching exactly\n\nSearch for *Advanced Collision Detection* in for more details\n\n*Warning:*\nThe contact offset must be positive and greater than the rest offset\n\n**Args:**\n\n * `offset` (float): Rest offset of a collision shape. Allowed range \\[-max\\_float, contact\\_offset. Default value is -inf, means default is picked by simulation. For rigid bodies its zero.\n\n---\n**Example:**\n\n```python\n>>> prim.set_rest_offset(0.01)\n```\n",
"snippet":"dynamic_capsule.set_rest_offset(offset=offset)\n",
"category":"method"
},
{
"title":"set_sleep_threshold",
"description":"Set the threshold for the rigid body to enter a sleep state\n\nSearch for *Rigid Body Dynamics* \\> *Sleeping* in for more details\n\n**Args:**\n\n * `threshold` (float): Mass-normalized kinetic energy threshold below which an actor may go to sleep. Range: \\[0, inf) Defaults: 0.00005 \\* tolerancesSpeed\\* tolerancesSpeed Units: distance\\^2 / second\\^2.\n\n---\n**Example:**\n\n```python\n>>> prim.set_sleep_threshold(1e-5)\n```\n",
"snippet":"dynamic_capsule.set_sleep_threshold(threshold=threshold)\n",
"category":"method"
},
{
"title":"set_torsional_patch_radius",
"description":"Set the radius of the contact patch used to apply torsional friction\n\nSearch for *\"Torsional Patch Radius\"* in for more details\n\n**Args:**\n\n * `radius` (float): radius of the contact patch used to apply torsional friction. Allowed range \\[0, max\\_float\\].\n\n---\n**Example:**\n\n```python\n>>> prim.set_torsional_patch_radius(0.1)\n```\n",
"snippet":"dynamic_capsule.set_torsional_patch_radius(radius=radius)\n",
"category":"method"
},
{
"title":"set_visibility",
"description":"Set the visibility of the prim in stage\n\n**Args:**\n\n * `visible` (bool): flag to set the visibility of the usd prim in stage.\n\n---\n**Example:**\n\n```python\n>>> # make prim not visible in the stage\n>>> prim.set_visibility(visible=False)\n```\n",
"snippet":"dynamic_capsule.set_visibility(visible=visible)\n",
"category":"method"
},
{
"title":"set_world_pose",
"description":"Ses prim's pose with respect to the world's frame\n\n*Warning:*\nThis method will change (teleport) the prim pose immediately to the indicated value\n\n**Args:**\n\n * `position` (Optional\\[Sequence\\[float\\]\\], optional): position in the world frame of the prim. shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the world frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n\n*Hint:*\nThis method belongs to the methods used to set the prim state\n\n---\n**Example:**\n\n```python\n>>> prim.set_world_pose(position=np.array([1.0, 0.5, 0.0]), orientation=np.array([1., 0., 0., 0.]))\n```\n",
"snippet":"dynamic_capsule.set_world_pose()\n",
"category":"method"
}
]
},
{
"title":"DynamicCone",
"snippets":[
{
"title":"import ...",
"description":"Import class",
"snippet":"from omni.isaac.core.objects import DynamicCone\n",
"category":"import"
},
{
"title":"DynamicCone",
"description":"High level wrapper to create/encapsulate a dynamic cone\n\n*Note:*\nDynamic cones (Cone shape) have collisions (Collider API) and rigid body dynamics (Rigid Body API)\n\n**Args:**\n\n * `prim_path` (str): prim path of the Prim to encapsulate or create\n * `name` (str, optional): shortname to be used as a key by Scene class. Note: needs to be unique if the object is added to the Scene. Defaults to \"dynamic\\_cone\".\n * `position` (Optional\\[Sequence\\[float\\]\\], optional): position in the world frame of the prim. shape is (3, ). Defaults to None, which means left unchanged.\n * `translation` (Optional\\[Sequence\\[float\\]\\], optional): translation in the local frame of the prim (with respect to its parent prim). shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the world/ local frame of the prim (depends if translation or position is specified). quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n * `scale` (Optional\\[Sequence\\[float\\]\\], optional): local scale to be applied to the prim's dimensions. shape is (3, ). Defaults to None, which means left unchanged.\n * `visible` (bool, optional): set to false for an invisible prim in the stage while rendering. Defaults to True.\n * `color` (Optional\\[np.ndarray\\], optional): color of the visual shape. Defaults to None, which means 50% gray\n * `radius` (Optional\\[float\\], optional): base radius. Defaults to None.\n * `height` (Optional\\[float\\], optional): cone height. Defaults to None.\n * `visual_material` (Optional\\[VisualMaterial\\], optional): visual material to be applied to the held prim. Defaults to None. If not specified, a default visual material will be added.\n * `physics_material` (Optional\\[PhysicsMaterial\\], optional): physics material to be applied to the held prim. Defaults to None. If not specified, a default physics material will be added.\n * `mass` (Optional\\[float\\], optional): mass in kg. Defaults to None.\n * `density` (Optional\\[float\\], optional): density. Defaults to None.\n * `linear_velocity` (Optional\\[np.ndarray\\], optional): linear velocity in the world frame. Defaults to None.\n * `angular_velocity` (Optional\\[np.ndarray\\], optional): angular velocity in the world frame. Defaults to None.\n\n---\n**Example:**\n\n```python\n>>> from omni.isaac.core.objects import DynamicCone\n>>> import numpy as np\n>>>\n>>> # create a red dynamic cone of mass 1kg at the given path\n>>> prim = DynamicCone(\n...     prim_path=\"/World/Xform/Cone\",\n...     radius=0.5,\n...     height=1.0,\n...     color=np.array([1.0, 0.0, 0.0]),\n...     mass=1.0\n... )\n>>> prim\n<omni.isaac.core.objects.cone.DynamicCone object at 0x7f4f9f5d11b0>\n```\n",
"snippet":"dynamic_cone = DynamicCone(prim_path=prim_path)\n",
"category":"class"
},
{
"title":"apply_physics_material",
"description":"Used to apply physics material to the held prim and optionally its descendants.\n\n**Args:**\n\n * `physics_material` (PhysicsMaterial): physics material to be applied to the held prim. This where you want to define friction, restitution..etc. Note: if a physics material is not defined, the defaults will be used from PhysX.\n * `weaker_than_descendants` (bool, optional): True if the material shouldn't override the descendants materials, otherwise False. Defaults to False.\n\n---\n**Example:**\n\n```python\n>>> from omni.isaac.core.materials import PhysicsMaterial\n>>>\n>>> # create a rigid body physical material\n>>> material = PhysicsMaterial(\n...     prim_path=\"/World/physics_material/aluminum\",  # path to the material prim to create\n...     dynamic_friction=0.4,\n...     static_friction=1.1,\n...     restitution=0.1\n... )\n>>> prim.apply_physics_material(material)\n```\n",
"snippet":"dynamic_cone.apply_physics_material(physics_material=physics_material)\n",
"category":"method"
},
{
"title":"apply_visual_material",
"description":"Apply visual material to the held prim and optionally its descendants.\n\n**Args:**\n\n * `visual_material` (VisualMaterial): visual material to be applied to the held prim. Currently supports PreviewSurface, OmniPBR and OmniGlass.\n * `weaker_than_descendants` (bool, optional): True if the material shouldn't override the descendants materials, otherwise False. Defaults to False.\n\n---\n**Example:**\n\n```python\n>>> from omni.isaac.core.materials import OmniGlass\n>>>\n>>> # create a dark-red glass visual material\n>>> material = OmniGlass(\n...     prim_path=\"/World/material/glass\",  # path to the material prim to create\n...     ior=1.25,\n...     depth=0.001,\n...     thin_walled=False,\n...     color=np.array([0.5, 0.0, 0.0])\n... )\n>>> prim.apply_visual_material(material)\n```\n",
"snippet":"dynamic_cone.apply_visual_material(visual_material=visual_material)\n",
"category":"method"
},
{
"title":"disable_rigid_body_physics",
"description":"Disable the rigid body physics\n\nWhen disabled, the object will not be moved by external forces such as gravity and collisions\n\n---\n**Example:**\n\n```python\n>>> prim.disable_rigid_body_physics()\n```\n",
"snippet":"dynamic_cone.disable_rigid_body_physics()\n",
"category":"method"
},
{
"title":"enable_rigid_body_physics",
"description":"Enable the rigid body physics\n\nWhen enabled, the object will be moved by external forces such as gravity and collisions\n\n---\n**Example:**\n\n```python\n>>> prim.enable_rigid_body_physics()\n```\n",
"snippet":"dynamic_cone.enable_rigid_body_physics()\n",
"category":"method"
},
{
"title":"get_angular_velocity",
"description":"Get the angular velocity of the rigid body\n\n**Returns:**\n\n * np.ndarray: current angular velocity of the the rigid prim. Shape (3,).\n\n---\n**Example:**\n\n```python\n>>> prim.get_angular_velocity()]\n[-0.01727393  0.00827609 -0.00040014]\n```\n",
"snippet":"dynamic_cone.get_angular_velocity()\n",
"category":"method"
},
{
"title":"get_applied_physics_material",
"description":"Return the current applied physics material in case it was applied using apply\\_physics\\_material or not.\n\n**Returns:**\n\n * PhysicsMaterial: the current applied physics material.\n\n---\n**Example:**\n\n```python\n>>> # given a physics material applied\n>>> prim.get_applied_physics_material()\n<omni.isaac.core.materials.physics_material.PhysicsMaterial object at 0x7fb66c30cd30>\n```\n",
"snippet":"applied_physics_material = dynamic_cone.get_applied_physics_material()\n",
"category":"method"
},
{
"title":"get_applied_visual_material",
"description":"Return the current applied visual material in case it was applied using apply\\_visual\\_material\nor it's one of the following materials that was already applied before: PreviewSurface, OmniPBR and OmniGlass.\n\n**Returns:**\n\n * VisualMaterial: the current applied visual material if its type is currently supported.\n\n---\n**Example:**\n\n```python\n>>> # given a visual material applied\n>>> prim.get_applied_visual_material()\n<omni.isaac.core.materials.omni_glass.OmniGlass object at 0x7f36263106a0>\n```\n",
"snippet":"applied_visual_material = dynamic_cone.get_applied_visual_material()\n",
"category":"method"
},
{
"title":"get_collision_approximation",
"description":"Get the collision approximation\n\n| Approximation           | Full name            | Description                                                                               |\n|-------------------------|----------------------|-------------------------------------------------------------------------------------------|\n| `\"none\"`                | Triangle Mesh        | The mesh geometry is used directly as a collider without any approximation                |\n| `\"convexDecomposition\"` | Convex Decomposition | A convex mesh decomposition is performed. This results in a set of convex mesh colliders  |\n| `\"convexHull\"`          | Convex Hull          | A convex hull of the mesh is generated and used as the collider                           |\n| `\"boundingSphere\"`      | Bounding Sphere      | A bounding sphere is computed around the mesh and used as a collider                      |\n| `\"boundingCube\"`        | Bounding Cube        | An optimally fitting box collider is computed around the mesh                             |\n| `\"meshSimplification\"`  | Mesh Simplification  | A mesh simplification step is performed, resulting in a simplified triangle mesh collider |\n| `\"sdf\"`                 | SDF Mesh             | SDF (Signed-Distance-Field) use high-detail triangle meshes as collision shape            |\n| `\"sphereFill\"`          | Sphere Approximation | A sphere mesh decomposition is performed. This results in a set of sphere colliders       |\n\n**Returns:**\n\n * str: approximation used for collision\n\n---\n**Example:**\n\n```python\n>>> prim.get_collision_approximation()\nnone\n```\n",
"snippet":"collision_approximation = dynamic_cone.get_collision_approximation()\n",
"category":"method"
},
{
"title":"get_collision_enabled",
"description":"Check if the Collision API is enabled\n\n**Returns:**\n\n * bool: True if the Collision API is enabled. Otherwise False\n\n---\n**Example:**\n\n```python\n>>> prim.get_collision_enabled()\nTrue\n```\n",
"snippet":"collision_enabled = dynamic_cone.get_collision_enabled()\n",
"category":"method"
},
{
"title":"get_contact_force_matrix",
"description":"If the object is initialized with filter\\_paths\\_expr list, this method returns the contact forces between the prims\nin the view and the filter prims. i.e., a matrix of dimension (self.\\_contact\\_view.num\\_filters, 3)\nwhere num\\_filters is the determined according to the filter\\_paths\\_expr parameter.\n\n**Args:**\n\n * `dt` (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor\\]: Net contact forces of the prims with shape (self.\\_geometry\\_prim\\_view.\\_contact\\_view.num\\_filters, 3).\n",
"snippet":"contact_force_matrix = dynamic_cone.get_contact_force_matrix()\n",
"category":"method"
},
{
"title":"get_contact_offset",
"description":"Get the contact offset\n\nShapes whose distance is less than the sum of their contact offset values will generate contacts\n\nSearch for *Advanced Collision Detection* in for more details\n\n**Returns:**\n\n * float: contact offset of the collision shape. Default value is -inf, means default is picked by simulation.\n\n---\n**Example:**\n\n```python\n>>> prim.get_contact_offset()\n-inf\n```\n",
"snippet":"contact_offset = dynamic_cone.get_contact_offset()\n",
"category":"method"
},
{
"title":"get_current_dynamic_state",
"description":"Get the current rigid body state (position, orientation and linear and angular velocities)\n\n**Returns:**\n\n * DynamicState: the dynamic state of the rigid body prim\n\n---\n**Example:**\n\n```python\n>>> # for the example the rigid body is in free fall\n>>> state = prim.get_current_dynamic_state()\n>>> state\n<omni.isaac.core.utils.types.DynamicState object at 0x7f740b36f670>\n>>> state.position\n[  0.99999857   2.0000017  -74.2862    ]\n>>> state.orientation\n[ 1.0000000e+00 -2.3961178e-07 -4.9891562e-09  4.9388258e-09]\n>>> state.linear_velocity\n[  0.        0.      -38.09554]\n>>> state.angular_velocity\n[0. 0. 0.]\n```\n",
"snippet":"current_dynamic_state = dynamic_cone.get_current_dynamic_state()\n",
"category":"method"
},
{
"title":"get_default_state",
"description":"Get the default rigid body state (position, orientation and linear and angular velocities)\n\n**Returns:**\n\n * DynamicState: returns the default state of the prim that is used after each reset\n\n---\n**Example:**\n\n```python\n>>> state = prim.get_default_state()\n>>> state\n<omni.isaac.core.utils.types.DynamicState object at 0x7f7411fcbe20>\n>>> state.position\n[-7.8622378e-07  1.4450421e-06  1.6135601e-07]\n>>> state.orientation\n[ 9.9999994e-01 -2.7194994e-07  2.9607077e-07  2.7016510e-08]\n>>> state.linear_velocity\n[0. 0. 0.]\n>>> state.angular_velocity\n[0. 0. 0.]\n```\n",
"snippet":"default_state = dynamic_cone.get_default_state()\n",
"category":"method"
},
{
"title":"get_default_state",
"description":"Get the default prim states (spatial position and orientation).\n\n**Returns:**\n\n * XFormPrimState: an object that contains the default state of the prim (position and orientation)\n\n---\n**Example:**\n\n```python\n>>> state = prim.get_default_state()\n>>> state\n<omni.isaac.core.utils.types.XFormPrimState object at 0x7f33addda650>\n>>>\n>>> state.position\n[-4.5299529e-08 -1.8347054e-09 -2.8610229e-08]\n>>> state.orientation\n[1. 0. 0. 0.]\n```\n",
"snippet":"default_state = dynamic_cone.get_default_state()\n",
"category":"method"
},
{
"title":"get_density",
"description":"Get the density of the rigid body\n\n**Returns:**\n\n * float: density of the rigid body.\n\n---\n**Example:**\n\n```python\n>>> prim.get_density()\n0\n```\n",
"snippet":"density = dynamic_cone.get_density()\n",
"category":"method"
},
{
"title":"get_height",
"description":"Get the cone height\n\n**Returns:**\n\n * float: cone height\n\n---\n**Example:**\n\n```python\n>>> prim.get_height()\n1.0\n```\n",
"snippet":"height = dynamic_cone.get_height()\n",
"category":"method"
},
{
"title":"get_linear_velocity",
"description":"Get the linear velocity of the rigid body\n\n**Returns:**\n\n * np.ndarray: current linear velocity of the the rigid prim. Shape (3,).\n\n---\n**Example:**\n\n```python\n>>> prim.get_linear_velocity()\n[ 1.0812164e-04  6.1415871e-05 -2.1341663e-04]\n```\n",
"snippet":"linear_velocity = dynamic_cone.get_linear_velocity()\n",
"category":"method"
},
{
"title":"get_local_pose",
"description":"Get prim's pose with respect to the local frame (the prim's parent frame)\n\n**Returns:**\n\n * Tuple\\[np.ndarray, np.ndarray\\]: first index is the position in the local frame (with shape (3, )).\n    Second index is quaternion orientation (with shape (4, )) in the local frame\n\n---\n**Example:**\n\n```python\n>>> # if the prim is in position (1.0, 0.5, 0.0) with respect to the world frame\n>>> position, orientation = prim.get_local_pose()\n>>> position\n[0. 0. 0.]\n>>> orientation\n[0. 0. 0.]\n```\n",
"snippet":"local_pose = dynamic_cone.get_local_pose()\n",
"category":"method"
},
{
"title":"get_local_scale",
"description":"Get prim's scale with respect to the local frame (the parent's frame)\n\n**Returns:**\n\n * np.ndarray: scale applied to the prim's dimensions in the local frame. shape is (3, ).\n\n---\n**Example:**\n\n```python\n>>> prim.get_local_scale()\n[1. 1. 1.]\n```\n",
"snippet":"local_scale = dynamic_cone.get_local_scale()\n",
"category":"method"
},
{
"title":"get_mass",
"description":"Get the mass of the rigid body\n\n**Returns:**\n\n * float: mass of the rigid body in kg.\n\n---\n**Example:**\n\n```python\n>>> prim.get_mass()\n0\n```\n",
"snippet":"mass = dynamic_cone.get_mass()\n",
"category":"method"
},
{
"title":"get_min_torsional_patch_radius",
"description":"Get the minimum radius of the contact patch used to apply torsional friction\n\nSearch for *\"Torsional Patch Radius\"* in for more details\n\n**Returns:**\n\n * float: minimum radius of the contact patch used to apply torsional friction. Allowed range \\[0, max\\_float\\].\n\n---\n**Example:**\n\n```python\n>>> prim.get_min_torsional_patch_radius()\n0.0\n```\n",
"snippet":"min_torsional_patch_radius = dynamic_cone.get_min_torsional_patch_radius()\n",
"category":"method"
},
{
"title":"get_net_contact_forces",
"description":"If contact forces of the prims in the view are tracked, this method returns the net contact forces on prims.\ni.e., a matrix of dimension (1, 3)\n\n**Args:**\n\n * `dt` (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor\\]: Net contact forces of the prims with shape (3).\n",
"snippet":"net_contact_forces = dynamic_cone.get_net_contact_forces()\n",
"category":"method"
},
{
"title":"get_radius",
"description":"Get the base radius\n\n**Returns:**\n\n * float: base radius\n\n---\n**Example:**\n\n```python\n>>> prim.get_radius()\n0.5\n```\n",
"snippet":"radius = dynamic_cone.get_radius()\n",
"category":"method"
},
{
"title":"get_rest_offset",
"description":"Get the rest offset\n\nTwo shapes will come to rest at a distance equal to the sum of their rest offset values.\nIf the rest offset is 0, they should converge to touching exactly\n\nSearch for *Advanced Collision Detection* in for more details\n\n**Returns:**\n\n * float: rest offset of the collision shape.\n\n---\n**Example:**\n\n```python\n>>> prim.get_rest_offset()\n-inf\n```\n",
"snippet":"rest_offset = dynamic_cone.get_rest_offset()\n",
"category":"method"
},
{
"title":"get_sleep_threshold",
"description":"Get the threshold for the rigid body to enter a sleep state\n\nSearch for *Rigid Body Dynamics* \\> *Sleeping* in for more details\n\n**Returns:**\n\n * float: Mass-normalized kinetic energy threshold below which an actor may go to sleep. Range: \\[0, inf) Defaults: 0.00005 \\* tolerancesSpeed\\* tolerancesSpeed Units: distance\\^2 / second\\^2.\n\n---\n**Example:**\n\n```python\n>>> prim.get_sleep_threshold()\n5e-05\n```\n",
"snippet":"sleep_threshold = dynamic_cone.get_sleep_threshold()\n",
"category":"method"
},
{
"title":"get_torsional_patch_radius",
"description":"Get the radius of the contact patch used to apply torsional friction\n\nSearch for *\"Torsional Patch Radius\"* in for more details\n\n**Returns:**\n\n * float: radius of the contact patch used to apply torsional friction. Allowed range \\[0, max\\_float\\].\n\n---\n**Example:**\n\n```python\n>>> prim.get_torsional_patch_radius()\n0.0\n```\n",
"snippet":"torsional_patch_radius = dynamic_cone.get_torsional_patch_radius()\n",
"category":"method"
},
{
"title":"get_visibility",
"description":"**Returns:**\n\n * bool: true if the prim is visible in stage. false otherwise.\n\n---\n**Example:**\n\n```python\n>>> # get the visible state of an visible prim on the stage\n>>> prim.get_visibility()\nTrue\n```\n",
"snippet":"visibility = dynamic_cone.get_visibility()\n",
"category":"method"
},
{
"title":"get_world_pose",
"description":"Get prim's pose with respect to the world's frame\n\n**Returns:**\n\n * Tuple\\[np.ndarray, np.ndarray\\]: first index is the position in the world frame (with shape (3, )).\n    Second index is quaternion orientation (with shape (4, )) in the world frame\n\n---\n**Example:**\n\n```python\n>>> # if the prim is in position (1.0, 0.5, 0.0) with respect to the world frame\n>>> position, orientation = prim.get_world_pose()\n>>> position\n[1.  0.5 0. ]\n>>> orientation\n[1. 0. 0. 0.]\n```\n",
"snippet":"world_pose = dynamic_cone.get_world_pose()\n",
"category":"method"
},
{
"title":"get_world_scale",
"description":"Get prim's scale with respect to the world's frame\n\n**Returns:**\n\n * np.ndarray: scale applied to the prim's dimensions in the world frame. shape is (3, ).\n\n---\n**Example:**\n\n```python\n>>> prim.get_world_scale()\n[1. 1. 1.]\n```\n",
"snippet":"world_scale = dynamic_cone.get_world_scale()\n",
"category":"method"
},
{
"title":"initialize",
"description":"Create a physics simulation view if not passed and using PhysX tensor API\n\n*Note:*\nIf the prim has been added to the world scene (e.g., `world.scene.add(prim)`),\nit will be automatically initialized when the world is reset (e.g., `world.reset()`).\n\n**Args:**\n\n * `physics_sim_view` (omni.physics.tensors.SimulationView, optional): current physics simulation view. Defaults to None.\n\n---\n**Example:**\n\n```python\n>>> prim.initialize()\n```\n",
"snippet":"dynamic_cone.initialize()\n",
"category":"method"
},
{
"title":"is_valid",
"description":"Check if the prim path has a valid USD Prim at it\n\n**Returns:**\n\n * bool: True is the current prim path corresponds to a valid prim in stage. False otherwise.\n\n---\n**Example:**\n\n```python\n>>> # given an existing and valid prim\n>>> prims.is_valid()\nTrue\n```\n",
"snippet":"value = dynamic_cone.is_valid()\n",
"category":"method"
},
{
"title":"is_visual_material_applied",
"description":"Check if there is a visual material applied\n\n**Returns:**\n\n * bool: True if there is a visual material applied. False otherwise.\n\n---\n**Example:**\n\n```python\n>>> # given a visual material applied\n>>> prim.is_visual_material_applied()\nTrue\n```\n",
"snippet":"value = dynamic_cone.is_visual_material_applied()\n",
"category":"method"
},
{
"title":"post_reset",
"description":"Reset the prim to its default state (position and orientation).\n\n*Note:*\nFor an articulation, in addition to configuring the root prim's default position and spatial orientation\n(defined via the `set_default_state` method), the joint's positions, velocities, and efforts\n(defined via the `set_joints_default_state` method) are imposed\n\n---\n**Example:**\n\n```python\n>>> prim.post_reset()\n```\n",
"snippet":"dynamic_cone.post_reset()\n",
"category":"method"
},
{
"title":"set_angular_velocity",
"description":"Set the angular velocity of the rigid body in stage\n\n*Warning:*\nThis method will immediately set the articulation state\n\n**Args:**\n\n * `velocity` (np.ndarray): angular velocity to set the rigid prim to. Shape (3,).\n\n*Hint:*\nThis method belongs to the methods used to set the rigid prim kinematic state:\n\n> `set_linear_velocity`, `set_angular_velocity`\n\n---\n**Example:**\n\n```python\n>>> prim.set_angular_velocity(np.array([0.0, 0.0, 10.0]))\n```\n",
"snippet":"dynamic_cone.set_angular_velocity(velocity=velocity)\n",
"category":"method"
},
{
"title":"set_collision_approximation",
"description":"Set the collision approximation\n\n| Approximation           | Full name            | Description                                                                               |\n|-------------------------|----------------------|-------------------------------------------------------------------------------------------|\n| `\"none\"`                | Triangle Mesh        | The mesh geometry is used directly as a collider without any approximation                |\n| `\"convexDecomposition\"` | Convex Decomposition | A convex mesh decomposition is performed. This results in a set of convex mesh colliders  |\n| `\"convexHull\"`          | Convex Hull          | A convex hull of the mesh is generated and used as the collider                           |\n| `\"boundingSphere\"`      | Bounding Sphere      | A bounding sphere is computed around the mesh and used as a collider                      |\n| `\"boundingCube\"`        | Bounding Cube        | An optimally fitting box collider is computed around the mesh                             |\n| `\"meshSimplification\"`  | Mesh Simplification  | A mesh simplification step is performed, resulting in a simplified triangle mesh collider |\n| `\"sdf\"`                 | SDF Mesh             | SDF (Signed-Distance-Field) use high-detail triangle meshes as collision shape            |\n| `\"sphereFill\"`          | Sphere Approximation | A sphere mesh decomposition is performed. This results in a set of sphere colliders       |\n\n*Warning:*\nSwitching to Convex Decomposition or SDF (Signed-Distance-Field) will have a simulation performance\nimpact due to higher computational cost\n\n**Args:**\n\n * `approximation_type` (str): approximation used for collision\n\n---\n**Example:**\n\n```python\n>>> prim.set_collision_approximation(\"convexDecomposition\")\n```\n",
"snippet":"dynamic_cone.set_collision_approximation(approximation_type=approximation_type)\n",
"category":"method"
},
{
"title":"set_collision_enabled",
"description":"Enable/disable the Collision API\n\n**Args:**\n\n * `enabled` (bool): Whether to enable or disable the Collision API\n\n---\n**Example:**\n\n```python\n>>> # disable collisions\n>>> prim.set_collision_enabled(False)\n```\n",
"snippet":"dynamic_cone.set_collision_enabled(enabled=enabled)\n",
"category":"method"
},
{
"title":"set_contact_offset",
"description":"Set the contact offset\n\nShapes whose distance is less than the sum of their contact offset values will generate contacts\n\nSearch for *Advanced Collision Detection* in for more details\n\n*Warning:*\nThe contact offset must be positive and greater than the rest offset\n\n**Args:**\n\n * `offset` (float): Contact offset of a collision shape. Allowed range \\[maximum(0, rest\\_offset), 0\\]. Default value is -inf, means default is picked by simulation based on the shape extent.\n\n---\n**Example:**\n\n```python\n>>> prim.set_contact_offset(0.02)\n```\n",
"snippet":"dynamic_cone.set_contact_offset(offset=offset)\n",
"category":"method"
},
{
"title":"set_default_state",
"description":"Set the default state of the prim (position, orientation and linear and angular velocities),\nthat will be used after each reset\n\n*Note:*\nThe default states will be set during post-reset (e.g., calling `.post_reset()` or `world.reset()` methods)\n\n**Args:**\n\n * `position` (Optional\\[Sequence\\[float\\]\\], optional): position in the world frame of the prim. shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the world frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n * `linear_velocity` (np.ndarray): linear velocity to set the rigid prim to. Shape (3,).\n * `angular_velocity` (np.ndarray): angular velocity to set the rigid prim to. Shape (3,).\n\n---\n**Example:**\n\n```python\n>>> prim.set_default_state(\n...     position=np.array([1.0, 2.0, 3.0]),\n...     orientation=np.array([1.0, 0.0, 0.0, 0.0]),\n...     linear_velocity=np.array([0.0, 0.0, 0.0]),\n...     angular_velocity=np.array([0.0, 0.0, 0.0])\n... )\n>>>\n>>> prim.post_reset()\n```\n",
"snippet":"dynamic_cone.set_default_state()\n",
"category":"method"
},
{
"title":"set_default_state",
"description":"Set the default state of the prim (position and orientation), that will be used after each reset.\n\n**Args:**\n\n * `position` (Optional\\[Sequence\\[float\\]\\], optional): position in the world frame of the prim. shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the world frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n\n---\n**Example:**\n\n```python\n>>> # configure default state\n>>> prim.set_default_state(position=np.array([1.0, 0.5, 0.0]), orientation=np.array([1, 0, 0, 0]))\n>>>\n>>> # set default states during post-reset\n>>> prim.post_reset()\n```\n",
"snippet":"dynamic_cone.set_default_state()\n",
"category":"method"
},
{
"title":"set_density",
"description":"Set the density of the rigid body\n\n**Args:**\n\n * `mass` (float): density of the rigid body.\n\n---\n**Example:**\n\n```python\n>>> prim.set_density(0.9)\n```\n",
"snippet":"dynamic_cone.set_density(density=density)\n",
"category":"method"
},
{
"title":"set_height",
"description":"Set the cone height\n\n**Args:**\n\n * `height` (float): cone height\n\n---\n**Example:**\n\n```python\n>>> prim.set_height(2.0)\n```\n",
"snippet":"dynamic_cone.set_height(height=height)\n",
"category":"method"
},
{
"title":"set_linear_velocity",
"description":"Set the linear velocity of the rigid body in stage\n\n*Warning:*\nThis method will immediately set the rigid prim state\n\n**Args:**\n\n * `velocity` (np.ndarray): linear velocity to set the rigid prim to. Shape (3,).\n\n*Hint:*\nThis method belongs to the methods used to set the rigid prim kinematic state:\n\n> `set_linear_velocity`, `set_angular_velocity`\n\n---\n**Example:**\n\n```python\n>>> prim.set_linear_velocity(np.array([5.0, 0.0, 0.0]))\n```\n",
"snippet":"dynamic_cone.set_linear_velocity(velocity=velocity)\n",
"category":"method"
},
{
"title":"set_local_pose",
"description":"Set prim's pose with respect to the local frame (the prim's parent frame).\n\n*Warning:*\nThis method will change (teleport) the prim pose immediately to the indicated value\n\n**Args:**\n\n * `translation` (Optional\\[Sequence\\[float\\]\\], optional): translation in the local frame of the prim (with respect to its parent prim). shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the local frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n\n*Hint:*\nThis method belongs to the methods used to set the prim state\n\n---\n**Example:**\n\n```python\n>>> prim.set_local_pose(translation=np.array([1.0, 0.5, 0.0]), orientation=np.array([1., 0., 0., 0.]))\n```\n",
"snippet":"dynamic_cone.set_local_pose()\n",
"category":"method"
},
{
"title":"set_local_scale",
"description":"Set prim's scale with respect to the local frame (the prim's parent frame).\n\n**Args:**\n\n * `scale` (Optional\\[Sequence\\[float\\]\\]): scale to be applied to the prim's dimensions. shape is (3, ). Defaults to None, which means left unchanged.\n\n---\n**Example:**\n\n```python\n>>> # scale prim 10 times smaller\n>>> prim.set_local_scale(np.array([0.1, 0.1, 0.1]))\n```\n",
"snippet":"dynamic_cone.set_local_scale(scale=scale)\n",
"category":"method"
},
{
"title":"set_mass",
"description":"Set the mass of the rigid body\n\n**Args:**\n\n * `mass` (float): mass of the rigid body in kg.\n\n---\n**Example:**\n\n```python\n>>> prim.set_mass(1.0)\n```\n",
"snippet":"dynamic_cone.set_mass(mass=mass)\n",
"category":"method"
},
{
"title":"set_min_torsional_patch_radius",
"description":"Set the minimum radius of the contact patch used to apply torsional friction\n\nSearch for *\"Torsional Patch Radius\"* in for more details\n\n**Args:**\n\n * `radius` (float): minimum radius of the contact patch used to apply torsional friction. Allowed range \\[0, max\\_float\\].\n\n---\n**Example:**\n\n```python\n>>> prim.set_min_torsional_patch_radius(0.05)\n```\n",
"snippet":"dynamic_cone.set_min_torsional_patch_radius(radius=radius)\n",
"category":"method"
},
{
"title":"set_radius",
"description":"Set the base radius\n\n**Args:**\n\n * `radius` (float): base radius\n\n---\n**Example:**\n\n```python\n>>> prim.set_radius(1.0)\n```\n",
"snippet":"dynamic_cone.set_radius(radius=radius)\n",
"category":"method"
},
{
"title":"set_rest_offset",
"description":"Set the rest offset\n\nTwo shapes will come to rest at a distance equal to the sum of their rest offset values.\nIf the rest offset is 0, they should converge to touching exactly\n\nSearch for *Advanced Collision Detection* in for more details\n\n*Warning:*\nThe contact offset must be positive and greater than the rest offset\n\n**Args:**\n\n * `offset` (float): Rest offset of a collision shape. Allowed range \\[-max\\_float, contact\\_offset. Default value is -inf, means default is picked by simulation. For rigid bodies its zero.\n\n---\n**Example:**\n\n```python\n>>> prim.set_rest_offset(0.01)\n```\n",
"snippet":"dynamic_cone.set_rest_offset(offset=offset)\n",
"category":"method"
},
{
"title":"set_sleep_threshold",
"description":"Set the threshold for the rigid body to enter a sleep state\n\nSearch for *Rigid Body Dynamics* \\> *Sleeping* in for more details\n\n**Args:**\n\n * `threshold` (float): Mass-normalized kinetic energy threshold below which an actor may go to sleep. Range: \\[0, inf) Defaults: 0.00005 \\* tolerancesSpeed\\* tolerancesSpeed Units: distance\\^2 / second\\^2.\n\n---\n**Example:**\n\n```python\n>>> prim.set_sleep_threshold(1e-5)\n```\n",
"snippet":"dynamic_cone.set_sleep_threshold(threshold=threshold)\n",
"category":"method"
},
{
"title":"set_torsional_patch_radius",
"description":"Set the radius of the contact patch used to apply torsional friction\n\nSearch for *\"Torsional Patch Radius\"* in for more details\n\n**Args:**\n\n * `radius` (float): radius of the contact patch used to apply torsional friction. Allowed range \\[0, max\\_float\\].\n\n---\n**Example:**\n\n```python\n>>> prim.set_torsional_patch_radius(0.1)\n```\n",
"snippet":"dynamic_cone.set_torsional_patch_radius(radius=radius)\n",
"category":"method"
},
{
"title":"set_visibility",
"description":"Set the visibility of the prim in stage\n\n**Args:**\n\n * `visible` (bool): flag to set the visibility of the usd prim in stage.\n\n---\n**Example:**\n\n```python\n>>> # make prim not visible in the stage\n>>> prim.set_visibility(visible=False)\n```\n",
"snippet":"dynamic_cone.set_visibility(visible=visible)\n",
"category":"method"
},
{
"title":"set_world_pose",
"description":"Ses prim's pose with respect to the world's frame\n\n*Warning:*\nThis method will change (teleport) the prim pose immediately to the indicated value\n\n**Args:**\n\n * `position` (Optional\\[Sequence\\[float\\]\\], optional): position in the world frame of the prim. shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the world frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n\n*Hint:*\nThis method belongs to the methods used to set the prim state\n\n---\n**Example:**\n\n```python\n>>> prim.set_world_pose(position=np.array([1.0, 0.5, 0.0]), orientation=np.array([1., 0., 0., 0.]))\n```\n",
"snippet":"dynamic_cone.set_world_pose()\n",
"category":"method"
}
]
},
{
"title":"DynamicCuboid",
"snippets":[
{
"title":"import ...",
"description":"Import class",
"snippet":"from omni.isaac.core.objects import DynamicCuboid\n",
"category":"import"
},
{
"title":"DynamicCuboid",
"description":"High level wrapper to create/encapsulate a dynamic cuboid\n\n*Note:*\nDynamic cuboids (Cube shape) have collisions (Collider API) and rigid body dynamics (Rigid Body API)\n\n**Args:**\n\n * `prim_path` (str): prim path of the Prim to encapsulate or create\n * `name` (str, optional): shortname to be used as a key by Scene class. Note: needs to be unique if the object is added to the Scene. Defaults to \"fixed\\_cube\".\n * `position` (Optional\\[Sequence\\[float\\]\\], optional): position in the world frame of the prim. shape is (3, ). Defaults to None, which means left unchanged.\n * `translation` (Optional\\[Sequence\\[float\\]\\], optional): translation in the local frame of the prim (with respect to its parent prim). shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the world/ local frame of the prim (depends if translation or position is specified). quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n * `scale` (Optional\\[Sequence\\[float\\]\\], optional): local scale to be applied to the prim's dimensions. shape is (3, ). Defaults to None, which means left unchanged.\n * `visible` (bool, optional): set to false for an invisible prim in the stage while rendering. Defaults to True.\n * `color` (Optional\\[np.ndarray\\], optional): color of the visual shape. Defaults to None, which means 50% gray\n * `size` (Optional\\[float\\], optional): length of each cube edge. Defaults to None.\n * `visual_material` (Optional\\[VisualMaterial\\], optional): visual material to be applied to the held prim. Defaults to None. If not specified, a default visual material will be added.\n * `physics_material` (Optional\\[PhysicsMaterial\\], optional): physics material to be applied to the held prim. Defaults to None. If not specified, a default physics material will be added.\n * `mass` (Optional\\[float\\], optional): mass in kg. Defaults to None.\n * `density` (Optional\\[float\\], optional): density. Defaults to None.\n * `linear_velocity` (Optional\\[np.ndarray\\], optional): linear velocity in the world frame. Defaults to None.\n * `angular_velocity` (Optional\\[np.ndarray\\], optional): angular velocity in the world frame. Defaults to None.\n\n---\n**Example:**\n\n```python\n>>> from omni.isaac.core.objects import DynamicCuboid\n>>> import numpy as np\n>>>\n>>> # create a red dynamic cube of mass 1kg at the given path\n>>> prim = DynamicCuboid(prim_path=\"/World/Xform/Cube\", color=np.array([1.0, 0.0, 0.0]), mass=1.0)\n>>> prim\n<omni.isaac.core.objects.cuboid.DynamicCuboid object at 0x7ff14c04d990>\n```\n",
"snippet":"dynamic_cuboid = DynamicCuboid(prim_path=prim_path)\n",
"category":"class"
},
{
"title":"apply_physics_material",
"description":"Used to apply physics material to the held prim and optionally its descendants.\n\n**Args:**\n\n * `physics_material` (PhysicsMaterial): physics material to be applied to the held prim. This where you want to define friction, restitution..etc. Note: if a physics material is not defined, the defaults will be used from PhysX.\n * `weaker_than_descendants` (bool, optional): True if the material shouldn't override the descendants materials, otherwise False. Defaults to False.\n\n---\n**Example:**\n\n```python\n>>> from omni.isaac.core.materials import PhysicsMaterial\n>>>\n>>> # create a rigid body physical material\n>>> material = PhysicsMaterial(\n...     prim_path=\"/World/physics_material/aluminum\",  # path to the material prim to create\n...     dynamic_friction=0.4,\n...     static_friction=1.1,\n...     restitution=0.1\n... )\n>>> prim.apply_physics_material(material)\n```\n",
"snippet":"dynamic_cuboid.apply_physics_material(physics_material=physics_material)\n",
"category":"method"
},
{
"title":"apply_visual_material",
"description":"Apply visual material to the held prim and optionally its descendants.\n\n**Args:**\n\n * `visual_material` (VisualMaterial): visual material to be applied to the held prim. Currently supports PreviewSurface, OmniPBR and OmniGlass.\n * `weaker_than_descendants` (bool, optional): True if the material shouldn't override the descendants materials, otherwise False. Defaults to False.\n\n---\n**Example:**\n\n```python\n>>> from omni.isaac.core.materials import OmniGlass\n>>>\n>>> # create a dark-red glass visual material\n>>> material = OmniGlass(\n...     prim_path=\"/World/material/glass\",  # path to the material prim to create\n...     ior=1.25,\n...     depth=0.001,\n...     thin_walled=False,\n...     color=np.array([0.5, 0.0, 0.0])\n... )\n>>> prim.apply_visual_material(material)\n```\n",
"snippet":"dynamic_cuboid.apply_visual_material(visual_material=visual_material)\n",
"category":"method"
},
{
"title":"disable_rigid_body_physics",
"description":"Disable the rigid body physics\n\nWhen disabled, the object will not be moved by external forces such as gravity and collisions\n\n---\n**Example:**\n\n```python\n>>> prim.disable_rigid_body_physics()\n```\n",
"snippet":"dynamic_cuboid.disable_rigid_body_physics()\n",
"category":"method"
},
{
"title":"enable_rigid_body_physics",
"description":"Enable the rigid body physics\n\nWhen enabled, the object will be moved by external forces such as gravity and collisions\n\n---\n**Example:**\n\n```python\n>>> prim.enable_rigid_body_physics()\n```\n",
"snippet":"dynamic_cuboid.enable_rigid_body_physics()\n",
"category":"method"
},
{
"title":"get_angular_velocity",
"description":"Get the angular velocity of the rigid body\n\n**Returns:**\n\n * np.ndarray: current angular velocity of the the rigid prim. Shape (3,).\n\n---\n**Example:**\n\n```python\n>>> prim.get_angular_velocity()]\n[-0.01727393  0.00827609 -0.00040014]\n```\n",
"snippet":"dynamic_cuboid.get_angular_velocity()\n",
"category":"method"
},
{
"title":"get_applied_physics_material",
"description":"Return the current applied physics material in case it was applied using apply\\_physics\\_material or not.\n\n**Returns:**\n\n * PhysicsMaterial: the current applied physics material.\n\n---\n**Example:**\n\n```python\n>>> # given a physics material applied\n>>> prim.get_applied_physics_material()\n<omni.isaac.core.materials.physics_material.PhysicsMaterial object at 0x7fb66c30cd30>\n```\n",
"snippet":"applied_physics_material = dynamic_cuboid.get_applied_physics_material()\n",
"category":"method"
},
{
"title":"get_applied_visual_material",
"description":"Return the current applied visual material in case it was applied using apply\\_visual\\_material\nor it's one of the following materials that was already applied before: PreviewSurface, OmniPBR and OmniGlass.\n\n**Returns:**\n\n * VisualMaterial: the current applied visual material if its type is currently supported.\n\n---\n**Example:**\n\n```python\n>>> # given a visual material applied\n>>> prim.get_applied_visual_material()\n<omni.isaac.core.materials.omni_glass.OmniGlass object at 0x7f36263106a0>\n```\n",
"snippet":"applied_visual_material = dynamic_cuboid.get_applied_visual_material()\n",
"category":"method"
},
{
"title":"get_collision_approximation",
"description":"Get the collision approximation\n\n| Approximation           | Full name            | Description                                                                               |\n|-------------------------|----------------------|-------------------------------------------------------------------------------------------|\n| `\"none\"`                | Triangle Mesh        | The mesh geometry is used directly as a collider without any approximation                |\n| `\"convexDecomposition\"` | Convex Decomposition | A convex mesh decomposition is performed. This results in a set of convex mesh colliders  |\n| `\"convexHull\"`          | Convex Hull          | A convex hull of the mesh is generated and used as the collider                           |\n| `\"boundingSphere\"`      | Bounding Sphere      | A bounding sphere is computed around the mesh and used as a collider                      |\n| `\"boundingCube\"`        | Bounding Cube        | An optimally fitting box collider is computed around the mesh                             |\n| `\"meshSimplification\"`  | Mesh Simplification  | A mesh simplification step is performed, resulting in a simplified triangle mesh collider |\n| `\"sdf\"`                 | SDF Mesh             | SDF (Signed-Distance-Field) use high-detail triangle meshes as collision shape            |\n| `\"sphereFill\"`          | Sphere Approximation | A sphere mesh decomposition is performed. This results in a set of sphere colliders       |\n\n**Returns:**\n\n * str: approximation used for collision\n\n---\n**Example:**\n\n```python\n>>> prim.get_collision_approximation()\nnone\n```\n",
"snippet":"collision_approximation = dynamic_cuboid.get_collision_approximation()\n",
"category":"method"
},
{
"title":"get_collision_enabled",
"description":"Check if the Collision API is enabled\n\n**Returns:**\n\n * bool: True if the Collision API is enabled. Otherwise False\n\n---\n**Example:**\n\n```python\n>>> prim.get_collision_enabled()\nTrue\n```\n",
"snippet":"collision_enabled = dynamic_cuboid.get_collision_enabled()\n",
"category":"method"
},
{
"title":"get_contact_force_matrix",
"description":"If the object is initialized with filter\\_paths\\_expr list, this method returns the contact forces between the prims\nin the view and the filter prims. i.e., a matrix of dimension (self.\\_contact\\_view.num\\_filters, 3)\nwhere num\\_filters is the determined according to the filter\\_paths\\_expr parameter.\n\n**Args:**\n\n * `dt` (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor\\]: Net contact forces of the prims with shape (self.\\_geometry\\_prim\\_view.\\_contact\\_view.num\\_filters, 3).\n",
"snippet":"contact_force_matrix = dynamic_cuboid.get_contact_force_matrix()\n",
"category":"method"
},
{
"title":"get_contact_offset",
"description":"Get the contact offset\n\nShapes whose distance is less than the sum of their contact offset values will generate contacts\n\nSearch for *Advanced Collision Detection* in for more details\n\n**Returns:**\n\n * float: contact offset of the collision shape. Default value is -inf, means default is picked by simulation.\n\n---\n**Example:**\n\n```python\n>>> prim.get_contact_offset()\n-inf\n```\n",
"snippet":"contact_offset = dynamic_cuboid.get_contact_offset()\n",
"category":"method"
},
{
"title":"get_current_dynamic_state",
"description":"Get the current rigid body state (position, orientation and linear and angular velocities)\n\n**Returns:**\n\n * DynamicState: the dynamic state of the rigid body prim\n\n---\n**Example:**\n\n```python\n>>> # for the example the rigid body is in free fall\n>>> state = prim.get_current_dynamic_state()\n>>> state\n<omni.isaac.core.utils.types.DynamicState object at 0x7f740b36f670>\n>>> state.position\n[  0.99999857   2.0000017  -74.2862    ]\n>>> state.orientation\n[ 1.0000000e+00 -2.3961178e-07 -4.9891562e-09  4.9388258e-09]\n>>> state.linear_velocity\n[  0.        0.      -38.09554]\n>>> state.angular_velocity\n[0. 0. 0.]\n```\n",
"snippet":"current_dynamic_state = dynamic_cuboid.get_current_dynamic_state()\n",
"category":"method"
},
{
"title":"get_default_state",
"description":"Get the default rigid body state (position, orientation and linear and angular velocities)\n\n**Returns:**\n\n * DynamicState: returns the default state of the prim that is used after each reset\n\n---\n**Example:**\n\n```python\n>>> state = prim.get_default_state()\n>>> state\n<omni.isaac.core.utils.types.DynamicState object at 0x7f7411fcbe20>\n>>> state.position\n[-7.8622378e-07  1.4450421e-06  1.6135601e-07]\n>>> state.orientation\n[ 9.9999994e-01 -2.7194994e-07  2.9607077e-07  2.7016510e-08]\n>>> state.linear_velocity\n[0. 0. 0.]\n>>> state.angular_velocity\n[0. 0. 0.]\n```\n",
"snippet":"default_state = dynamic_cuboid.get_default_state()\n",
"category":"method"
},
{
"title":"get_default_state",
"description":"Get the default prim states (spatial position and orientation).\n\n**Returns:**\n\n * XFormPrimState: an object that contains the default state of the prim (position and orientation)\n\n---\n**Example:**\n\n```python\n>>> state = prim.get_default_state()\n>>> state\n<omni.isaac.core.utils.types.XFormPrimState object at 0x7f33addda650>\n>>>\n>>> state.position\n[-4.5299529e-08 -1.8347054e-09 -2.8610229e-08]\n>>> state.orientation\n[1. 0. 0. 0.]\n```\n",
"snippet":"default_state = dynamic_cuboid.get_default_state()\n",
"category":"method"
},
{
"title":"get_density",
"description":"Get the density of the rigid body\n\n**Returns:**\n\n * float: density of the rigid body.\n\n---\n**Example:**\n\n```python\n>>> prim.get_density()\n0\n```\n",
"snippet":"density = dynamic_cuboid.get_density()\n",
"category":"method"
},
{
"title":"get_linear_velocity",
"description":"Get the linear velocity of the rigid body\n\n**Returns:**\n\n * np.ndarray: current linear velocity of the the rigid prim. Shape (3,).\n\n---\n**Example:**\n\n```python\n>>> prim.get_linear_velocity()\n[ 1.0812164e-04  6.1415871e-05 -2.1341663e-04]\n```\n",
"snippet":"linear_velocity = dynamic_cuboid.get_linear_velocity()\n",
"category":"method"
},
{
"title":"get_local_pose",
"description":"Get prim's pose with respect to the local frame (the prim's parent frame)\n\n**Returns:**\n\n * Tuple\\[np.ndarray, np.ndarray\\]: first index is the position in the local frame (with shape (3, )).\n    Second index is quaternion orientation (with shape (4, )) in the local frame\n\n---\n**Example:**\n\n```python\n>>> # if the prim is in position (1.0, 0.5, 0.0) with respect to the world frame\n>>> position, orientation = prim.get_local_pose()\n>>> position\n[0. 0. 0.]\n>>> orientation\n[0. 0. 0.]\n```\n",
"snippet":"local_pose = dynamic_cuboid.get_local_pose()\n",
"category":"method"
},
{
"title":"get_local_scale",
"description":"Get prim's scale with respect to the local frame (the parent's frame)\n\n**Returns:**\n\n * np.ndarray: scale applied to the prim's dimensions in the local frame. shape is (3, ).\n\n---\n**Example:**\n\n```python\n>>> prim.get_local_scale()\n[1. 1. 1.]\n```\n",
"snippet":"local_scale = dynamic_cuboid.get_local_scale()\n",
"category":"method"
},
{
"title":"get_mass",
"description":"Get the mass of the rigid body\n\n**Returns:**\n\n * float: mass of the rigid body in kg.\n\n---\n**Example:**\n\n```python\n>>> prim.get_mass()\n0\n```\n",
"snippet":"mass = dynamic_cuboid.get_mass()\n",
"category":"method"
},
{
"title":"get_min_torsional_patch_radius",
"description":"Get the minimum radius of the contact patch used to apply torsional friction\n\nSearch for *\"Torsional Patch Radius\"* in for more details\n\n**Returns:**\n\n * float: minimum radius of the contact patch used to apply torsional friction. Allowed range \\[0, max\\_float\\].\n\n---\n**Example:**\n\n```python\n>>> prim.get_min_torsional_patch_radius()\n0.0\n```\n",
"snippet":"min_torsional_patch_radius = dynamic_cuboid.get_min_torsional_patch_radius()\n",
"category":"method"
},
{
"title":"get_net_contact_forces",
"description":"If contact forces of the prims in the view are tracked, this method returns the net contact forces on prims.\ni.e., a matrix of dimension (1, 3)\n\n**Args:**\n\n * `dt` (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor\\]: Net contact forces of the prims with shape (3).\n",
"snippet":"net_contact_forces = dynamic_cuboid.get_net_contact_forces()\n",
"category":"method"
},
{
"title":"get_rest_offset",
"description":"Get the rest offset\n\nTwo shapes will come to rest at a distance equal to the sum of their rest offset values.\nIf the rest offset is 0, they should converge to touching exactly\n\nSearch for *Advanced Collision Detection* in for more details\n\n**Returns:**\n\n * float: rest offset of the collision shape.\n\n---\n**Example:**\n\n```python\n>>> prim.get_rest_offset()\n-inf\n```\n",
"snippet":"rest_offset = dynamic_cuboid.get_rest_offset()\n",
"category":"method"
},
{
"title":"get_size",
"description":"Get the length of each cube edge\n\n**Returns:**\n\n * float: edge length\n\n---\n**Example:**\n\n```python\n>>> prim.get_size()\n1.0\n```\n",
"snippet":"size = dynamic_cuboid.get_size()\n",
"category":"method"
},
{
"title":"get_sleep_threshold",
"description":"Get the threshold for the rigid body to enter a sleep state\n\nSearch for *Rigid Body Dynamics* \\> *Sleeping* in for more details\n\n**Returns:**\n\n * float: Mass-normalized kinetic energy threshold below which an actor may go to sleep. Range: \\[0, inf) Defaults: 0.00005 \\* tolerancesSpeed\\* tolerancesSpeed Units: distance\\^2 / second\\^2.\n\n---\n**Example:**\n\n```python\n>>> prim.get_sleep_threshold()\n5e-05\n```\n",
"snippet":"sleep_threshold = dynamic_cuboid.get_sleep_threshold()\n",
"category":"method"
},
{
"title":"get_torsional_patch_radius",
"description":"Get the radius of the contact patch used to apply torsional friction\n\nSearch for *\"Torsional Patch Radius\"* in for more details\n\n**Returns:**\n\n * float: radius of the contact patch used to apply torsional friction. Allowed range \\[0, max\\_float\\].\n\n---\n**Example:**\n\n```python\n>>> prim.get_torsional_patch_radius()\n0.0\n```\n",
"snippet":"torsional_patch_radius = dynamic_cuboid.get_torsional_patch_radius()\n",
"category":"method"
},
{
"title":"get_visibility",
"description":"**Returns:**\n\n * bool: true if the prim is visible in stage. false otherwise.\n\n---\n**Example:**\n\n```python\n>>> # get the visible state of an visible prim on the stage\n>>> prim.get_visibility()\nTrue\n```\n",
"snippet":"visibility = dynamic_cuboid.get_visibility()\n",
"category":"method"
},
{
"title":"get_world_pose",
"description":"Get prim's pose with respect to the world's frame\n\n**Returns:**\n\n * Tuple\\[np.ndarray, np.ndarray\\]: first index is the position in the world frame (with shape (3, )).\n    Second index is quaternion orientation (with shape (4, )) in the world frame\n\n---\n**Example:**\n\n```python\n>>> # if the prim is in position (1.0, 0.5, 0.0) with respect to the world frame\n>>> position, orientation = prim.get_world_pose()\n>>> position\n[1.  0.5 0. ]\n>>> orientation\n[1. 0. 0. 0.]\n```\n",
"snippet":"world_pose = dynamic_cuboid.get_world_pose()\n",
"category":"method"
},
{
"title":"get_world_scale",
"description":"Get prim's scale with respect to the world's frame\n\n**Returns:**\n\n * np.ndarray: scale applied to the prim's dimensions in the world frame. shape is (3, ).\n\n---\n**Example:**\n\n```python\n>>> prim.get_world_scale()\n[1. 1. 1.]\n```\n",
"snippet":"world_scale = dynamic_cuboid.get_world_scale()\n",
"category":"method"
},
{
"title":"initialize",
"description":"Create a physics simulation view if not passed and using PhysX tensor API\n\n*Note:*\nIf the prim has been added to the world scene (e.g., `world.scene.add(prim)`),\nit will be automatically initialized when the world is reset (e.g., `world.reset()`).\n\n**Args:**\n\n * `physics_sim_view` (omni.physics.tensors.SimulationView, optional): current physics simulation view. Defaults to None.\n\n---\n**Example:**\n\n```python\n>>> prim.initialize()\n```\n",
"snippet":"dynamic_cuboid.initialize()\n",
"category":"method"
},
{
"title":"is_valid",
"description":"Check if the prim path has a valid USD Prim at it\n\n**Returns:**\n\n * bool: True is the current prim path corresponds to a valid prim in stage. False otherwise.\n\n---\n**Example:**\n\n```python\n>>> # given an existing and valid prim\n>>> prims.is_valid()\nTrue\n```\n",
"snippet":"value = dynamic_cuboid.is_valid()\n",
"category":"method"
},
{
"title":"is_visual_material_applied",
"description":"Check if there is a visual material applied\n\n**Returns:**\n\n * bool: True if there is a visual material applied. False otherwise.\n\n---\n**Example:**\n\n```python\n>>> # given a visual material applied\n>>> prim.is_visual_material_applied()\nTrue\n```\n",
"snippet":"value = dynamic_cuboid.is_visual_material_applied()\n",
"category":"method"
},
{
"title":"post_reset",
"description":"Reset the prim to its default state (position and orientation).\n\n*Note:*\nFor an articulation, in addition to configuring the root prim's default position and spatial orientation\n(defined via the `set_default_state` method), the joint's positions, velocities, and efforts\n(defined via the `set_joints_default_state` method) are imposed\n\n---\n**Example:**\n\n```python\n>>> prim.post_reset()\n```\n",
"snippet":"dynamic_cuboid.post_reset()\n",
"category":"method"
},
{
"title":"set_angular_velocity",
"description":"Set the angular velocity of the rigid body in stage\n\n*Warning:*\nThis method will immediately set the articulation state\n\n**Args:**\n\n * `velocity` (np.ndarray): angular velocity to set the rigid prim to. Shape (3,).\n\n*Hint:*\nThis method belongs to the methods used to set the rigid prim kinematic state:\n\n> `set_linear_velocity`, `set_angular_velocity`\n\n---\n**Example:**\n\n```python\n>>> prim.set_angular_velocity(np.array([0.0, 0.0, 10.0]))\n```\n",
"snippet":"dynamic_cuboid.set_angular_velocity(velocity=velocity)\n",
"category":"method"
},
{
"title":"set_collision_approximation",
"description":"Set the collision approximation\n\n| Approximation           | Full name            | Description                                                                               |\n|-------------------------|----------------------|-------------------------------------------------------------------------------------------|\n| `\"none\"`                | Triangle Mesh        | The mesh geometry is used directly as a collider without any approximation                |\n| `\"convexDecomposition\"` | Convex Decomposition | A convex mesh decomposition is performed. This results in a set of convex mesh colliders  |\n| `\"convexHull\"`          | Convex Hull          | A convex hull of the mesh is generated and used as the collider                           |\n| `\"boundingSphere\"`      | Bounding Sphere      | A bounding sphere is computed around the mesh and used as a collider                      |\n| `\"boundingCube\"`        | Bounding Cube        | An optimally fitting box collider is computed around the mesh                             |\n| `\"meshSimplification\"`  | Mesh Simplification  | A mesh simplification step is performed, resulting in a simplified triangle mesh collider |\n| `\"sdf\"`                 | SDF Mesh             | SDF (Signed-Distance-Field) use high-detail triangle meshes as collision shape            |\n| `\"sphereFill\"`          | Sphere Approximation | A sphere mesh decomposition is performed. This results in a set of sphere colliders       |\n\n*Warning:*\nSwitching to Convex Decomposition or SDF (Signed-Distance-Field) will have a simulation performance\nimpact due to higher computational cost\n\n**Args:**\n\n * `approximation_type` (str): approximation used for collision\n\n---\n**Example:**\n\n```python\n>>> prim.set_collision_approximation(\"convexDecomposition\")\n```\n",
"snippet":"dynamic_cuboid.set_collision_approximation(approximation_type=approximation_type)\n",
"category":"method"
},
{
"title":"set_collision_enabled",
"description":"Enable/disable the Collision API\n\n**Args:**\n\n * `enabled` (bool): Whether to enable or disable the Collision API\n\n---\n**Example:**\n\n```python\n>>> # disable collisions\n>>> prim.set_collision_enabled(False)\n```\n",
"snippet":"dynamic_cuboid.set_collision_enabled(enabled=enabled)\n",
"category":"method"
},
{
"title":"set_contact_offset",
"description":"Set the contact offset\n\nShapes whose distance is less than the sum of their contact offset values will generate contacts\n\nSearch for *Advanced Collision Detection* in for more details\n\n*Warning:*\nThe contact offset must be positive and greater than the rest offset\n\n**Args:**\n\n * `offset` (float): Contact offset of a collision shape. Allowed range \\[maximum(0, rest\\_offset), 0\\]. Default value is -inf, means default is picked by simulation based on the shape extent.\n\n---\n**Example:**\n\n```python\n>>> prim.set_contact_offset(0.02)\n```\n",
"snippet":"dynamic_cuboid.set_contact_offset(offset=offset)\n",
"category":"method"
},
{
"title":"set_default_state",
"description":"Set the default state of the prim (position, orientation and linear and angular velocities),\nthat will be used after each reset\n\n*Note:*\nThe default states will be set during post-reset (e.g., calling `.post_reset()` or `world.reset()` methods)\n\n**Args:**\n\n * `position` (Optional\\[Sequence\\[float\\]\\], optional): position in the world frame of the prim. shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the world frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n * `linear_velocity` (np.ndarray): linear velocity to set the rigid prim to. Shape (3,).\n * `angular_velocity` (np.ndarray): angular velocity to set the rigid prim to. Shape (3,).\n\n---\n**Example:**\n\n```python\n>>> prim.set_default_state(\n...     position=np.array([1.0, 2.0, 3.0]),\n...     orientation=np.array([1.0, 0.0, 0.0, 0.0]),\n...     linear_velocity=np.array([0.0, 0.0, 0.0]),\n...     angular_velocity=np.array([0.0, 0.0, 0.0])\n... )\n>>>\n>>> prim.post_reset()\n```\n",
"snippet":"dynamic_cuboid.set_default_state()\n",
"category":"method"
},
{
"title":"set_default_state",
"description":"Set the default state of the prim (position and orientation), that will be used after each reset.\n\n**Args:**\n\n * `position` (Optional\\[Sequence\\[float\\]\\], optional): position in the world frame of the prim. shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the world frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n\n---\n**Example:**\n\n```python\n>>> # configure default state\n>>> prim.set_default_state(position=np.array([1.0, 0.5, 0.0]), orientation=np.array([1, 0, 0, 0]))\n>>>\n>>> # set default states during post-reset\n>>> prim.post_reset()\n```\n",
"snippet":"dynamic_cuboid.set_default_state()\n",
"category":"method"
},
{
"title":"set_density",
"description":"Set the density of the rigid body\n\n**Args:**\n\n * `mass` (float): density of the rigid body.\n\n---\n**Example:**\n\n```python\n>>> prim.set_density(0.9)\n```\n",
"snippet":"dynamic_cuboid.set_density(density=density)\n",
"category":"method"
},
{
"title":"set_linear_velocity",
"description":"Set the linear velocity of the rigid body in stage\n\n*Warning:*\nThis method will immediately set the rigid prim state\n\n**Args:**\n\n * `velocity` (np.ndarray): linear velocity to set the rigid prim to. Shape (3,).\n\n*Hint:*\nThis method belongs to the methods used to set the rigid prim kinematic state:\n\n> `set_linear_velocity`, `set_angular_velocity`\n\n---\n**Example:**\n\n```python\n>>> prim.set_linear_velocity(np.array([5.0, 0.0, 0.0]))\n```\n",
"snippet":"dynamic_cuboid.set_linear_velocity(velocity=velocity)\n",
"category":"method"
},
{
"title":"set_local_pose",
"description":"Set prim's pose with respect to the local frame (the prim's parent frame).\n\n*Warning:*\nThis method will change (teleport) the prim pose immediately to the indicated value\n\n**Args:**\n\n * `translation` (Optional\\[Sequence\\[float\\]\\], optional): translation in the local frame of the prim (with respect to its parent prim). shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the local frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n\n*Hint:*\nThis method belongs to the methods used to set the prim state\n\n---\n**Example:**\n\n```python\n>>> prim.set_local_pose(translation=np.array([1.0, 0.5, 0.0]), orientation=np.array([1., 0., 0., 0.]))\n```\n",
"snippet":"dynamic_cuboid.set_local_pose()\n",
"category":"method"
},
{
"title":"set_local_scale",
"description":"Set prim's scale with respect to the local frame (the prim's parent frame).\n\n**Args:**\n\n * `scale` (Optional\\[Sequence\\[float\\]\\]): scale to be applied to the prim's dimensions. shape is (3, ). Defaults to None, which means left unchanged.\n\n---\n**Example:**\n\n```python\n>>> # scale prim 10 times smaller\n>>> prim.set_local_scale(np.array([0.1, 0.1, 0.1]))\n```\n",
"snippet":"dynamic_cuboid.set_local_scale(scale=scale)\n",
"category":"method"
},
{
"title":"set_mass",
"description":"Set the mass of the rigid body\n\n**Args:**\n\n * `mass` (float): mass of the rigid body in kg.\n\n---\n**Example:**\n\n```python\n>>> prim.set_mass(1.0)\n```\n",
"snippet":"dynamic_cuboid.set_mass(mass=mass)\n",
"category":"method"
},
{
"title":"set_min_torsional_patch_radius",
"description":"Set the minimum radius of the contact patch used to apply torsional friction\n\nSearch for *\"Torsional Patch Radius\"* in for more details\n\n**Args:**\n\n * `radius` (float): minimum radius of the contact patch used to apply torsional friction. Allowed range \\[0, max\\_float\\].\n\n---\n**Example:**\n\n```python\n>>> prim.set_min_torsional_patch_radius(0.05)\n```\n",
"snippet":"dynamic_cuboid.set_min_torsional_patch_radius(radius=radius)\n",
"category":"method"
},
{
"title":"set_rest_offset",
"description":"Set the rest offset\n\nTwo shapes will come to rest at a distance equal to the sum of their rest offset values.\nIf the rest offset is 0, they should converge to touching exactly\n\nSearch for *Advanced Collision Detection* in for more details\n\n*Warning:*\nThe contact offset must be positive and greater than the rest offset\n\n**Args:**\n\n * `offset` (float): Rest offset of a collision shape. Allowed range \\[-max\\_float, contact\\_offset. Default value is -inf, means default is picked by simulation. For rigid bodies its zero.\n\n---\n**Example:**\n\n```python\n>>> prim.set_rest_offset(0.01)\n```\n",
"snippet":"dynamic_cuboid.set_rest_offset(offset=offset)\n",
"category":"method"
},
{
"title":"set_size",
"description":"Set the length of each cube edge\n\n**Args:**\n\n * `size` (float): edge length\n\n---\n**Example:**\n\n```python\n>>> prim.set_size(2.0)\n```\n",
"snippet":"dynamic_cuboid.set_size(size=size)\n",
"category":"method"
},
{
"title":"set_sleep_threshold",
"description":"Set the threshold for the rigid body to enter a sleep state\n\nSearch for *Rigid Body Dynamics* \\> *Sleeping* in for more details\n\n**Args:**\n\n * `threshold` (float): Mass-normalized kinetic energy threshold below which an actor may go to sleep. Range: \\[0, inf) Defaults: 0.00005 \\* tolerancesSpeed\\* tolerancesSpeed Units: distance\\^2 / second\\^2.\n\n---\n**Example:**\n\n```python\n>>> prim.set_sleep_threshold(1e-5)\n```\n",
"snippet":"dynamic_cuboid.set_sleep_threshold(threshold=threshold)\n",
"category":"method"
},
{
"title":"set_torsional_patch_radius",
"description":"Set the radius of the contact patch used to apply torsional friction\n\nSearch for *\"Torsional Patch Radius\"* in for more details\n\n**Args:**\n\n * `radius` (float): radius of the contact patch used to apply torsional friction. Allowed range \\[0, max\\_float\\].\n\n---\n**Example:**\n\n```python\n>>> prim.set_torsional_patch_radius(0.1)\n```\n",
"snippet":"dynamic_cuboid.set_torsional_patch_radius(radius=radius)\n",
"category":"method"
},
{
"title":"set_visibility",
"description":"Set the visibility of the prim in stage\n\n**Args:**\n\n * `visible` (bool): flag to set the visibility of the usd prim in stage.\n\n---\n**Example:**\n\n```python\n>>> # make prim not visible in the stage\n>>> prim.set_visibility(visible=False)\n```\n",
"snippet":"dynamic_cuboid.set_visibility(visible=visible)\n",
"category":"method"
},
{
"title":"set_world_pose",
"description":"Ses prim's pose with respect to the world's frame\n\n*Warning:*\nThis method will change (teleport) the prim pose immediately to the indicated value\n\n**Args:**\n\n * `position` (Optional\\[Sequence\\[float\\]\\], optional): position in the world frame of the prim. shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the world frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n\n*Hint:*\nThis method belongs to the methods used to set the prim state\n\n---\n**Example:**\n\n```python\n>>> prim.set_world_pose(position=np.array([1.0, 0.5, 0.0]), orientation=np.array([1., 0., 0., 0.]))\n```\n",
"snippet":"dynamic_cuboid.set_world_pose()\n",
"category":"method"
}
]
},
{
"title":"DynamicCylinder",
"snippets":[
{
"title":"import ...",
"description":"Import class",
"snippet":"from omni.isaac.core.objects import DynamicCylinder\n",
"category":"import"
},
{
"title":"DynamicCylinder",
"description":"High level wrapper to create/encapsulate a dynamic cylinder\n\n*Note:*\nDynamic cylinders (Cylinder shape) have collisions (Collider API) and rigid body dynamics (Rigid Body API)\n\n**Args:**\n\n * `prim_path` (str): prim path of the Prim to encapsulate or create\n * `name` (str, optional): shortname to be used as a key by Scene class. Note: needs to be unique if the object is added to the Scene. Defaults to \"dynamic\\_cylinder\".\n * `position` (Optional\\[Sequence\\[float\\]\\], optional): position in the world frame of the prim. shape is (3, ). Defaults to None, which means left unchanged.\n * `translation` (Optional\\[Sequence\\[float\\]\\], optional): translation in the local frame of the prim (with respect to its parent prim). shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the world/ local frame of the prim (depends if translation or position is specified). quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n * `scale` (Optional\\[Sequence\\[float\\]\\], optional): local scale to be applied to the prim's dimensions. shape is (3, ). Defaults to None, which means left unchanged.\n * `visible` (bool, optional): set to false for an invisible prim in the stage while rendering. Defaults to True.\n * `color` (Optional\\[np.ndarray\\], optional): color of the visual shape. Defaults to None, which means 50% gray\n * `radius` (Optional\\[float\\], optional): base radius. Defaults to None.\n * `height` (Optional\\[float\\], optional): cylinder height. Defaults to None.\n * `visual_material` (Optional\\[VisualMaterial\\], optional): visual material to be applied to the held prim. Defaults to None. If not specified, a default visual material will be added.\n * `physics_material` (Optional\\[PhysicsMaterial\\], optional): physics material to be applied to the held prim. Defaults to None. If not specified, a default physics material will be added.\n * `mass` (Optional\\[float\\], optional): mass in kg. Defaults to None.\n * `density` (Optional\\[float\\], optional): density. Defaults to None.\n * `linear_velocity` (Optional\\[np.ndarray\\], optional): linear velocity in the world frame. Defaults to None.\n * `angular_velocity` (Optional\\[np.ndarray\\], optional): angular velocity in the world frame. Defaults to None.\n\n---\n**Example:**\n\n```python\n>>> from omni.isaac.core.objects import DynamicCylinder\n>>> import numpy as np\n>>>\n>>> # create a red fixed cylinder of mass 1kg at the given path\n>>> prim = DynamicCylinder(\n...     prim_path=\"/World/Xform/Cylinder\",\n...     radius=0.5,\n...     height=1.0,\n...     color=np.array([1.0, 0.0, 0.0]),\n...     mass=1.0\n... )\n>>> prim\n<omni.isaac.core.objects.cylinder.DynamicCylinder object at 0x7f4e8f5c4a60>\n```\n",
"snippet":"dynamic_cylinder = DynamicCylinder(prim_path=prim_path)\n",
"category":"class"
},
{
"title":"apply_physics_material",
"description":"Used to apply physics material to the held prim and optionally its descendants.\n\n**Args:**\n\n * `physics_material` (PhysicsMaterial): physics material to be applied to the held prim. This where you want to define friction, restitution..etc. Note: if a physics material is not defined, the defaults will be used from PhysX.\n * `weaker_than_descendants` (bool, optional): True if the material shouldn't override the descendants materials, otherwise False. Defaults to False.\n\n---\n**Example:**\n\n```python\n>>> from omni.isaac.core.materials import PhysicsMaterial\n>>>\n>>> # create a rigid body physical material\n>>> material = PhysicsMaterial(\n...     prim_path=\"/World/physics_material/aluminum\",  # path to the material prim to create\n...     dynamic_friction=0.4,\n...     static_friction=1.1,\n...     restitution=0.1\n... )\n>>> prim.apply_physics_material(material)\n```\n",
"snippet":"dynamic_cylinder.apply_physics_material(physics_material=physics_material)\n",
"category":"method"
},
{
"title":"apply_visual_material",
"description":"Apply visual material to the held prim and optionally its descendants.\n\n**Args:**\n\n * `visual_material` (VisualMaterial): visual material to be applied to the held prim. Currently supports PreviewSurface, OmniPBR and OmniGlass.\n * `weaker_than_descendants` (bool, optional): True if the material shouldn't override the descendants materials, otherwise False. Defaults to False.\n\n---\n**Example:**\n\n```python\n>>> from omni.isaac.core.materials import OmniGlass\n>>>\n>>> # create a dark-red glass visual material\n>>> material = OmniGlass(\n...     prim_path=\"/World/material/glass\",  # path to the material prim to create\n...     ior=1.25,\n...     depth=0.001,\n...     thin_walled=False,\n...     color=np.array([0.5, 0.0, 0.0])\n... )\n>>> prim.apply_visual_material(material)\n```\n",
"snippet":"dynamic_cylinder.apply_visual_material(visual_material=visual_material)\n",
"category":"method"
},
{
"title":"disable_rigid_body_physics",
"description":"Disable the rigid body physics\n\nWhen disabled, the object will not be moved by external forces such as gravity and collisions\n\n---\n**Example:**\n\n```python\n>>> prim.disable_rigid_body_physics()\n```\n",
"snippet":"dynamic_cylinder.disable_rigid_body_physics()\n",
"category":"method"
},
{
"title":"enable_rigid_body_physics",
"description":"Enable the rigid body physics\n\nWhen enabled, the object will be moved by external forces such as gravity and collisions\n\n---\n**Example:**\n\n```python\n>>> prim.enable_rigid_body_physics()\n```\n",
"snippet":"dynamic_cylinder.enable_rigid_body_physics()\n",
"category":"method"
},
{
"title":"get_angular_velocity",
"description":"Get the angular velocity of the rigid body\n\n**Returns:**\n\n * np.ndarray: current angular velocity of the the rigid prim. Shape (3,).\n\n---\n**Example:**\n\n```python\n>>> prim.get_angular_velocity()]\n[-0.01727393  0.00827609 -0.00040014]\n```\n",
"snippet":"dynamic_cylinder.get_angular_velocity()\n",
"category":"method"
},
{
"title":"get_applied_physics_material",
"description":"Return the current applied physics material in case it was applied using apply\\_physics\\_material or not.\n\n**Returns:**\n\n * PhysicsMaterial: the current applied physics material.\n\n---\n**Example:**\n\n```python\n>>> # given a physics material applied\n>>> prim.get_applied_physics_material()\n<omni.isaac.core.materials.physics_material.PhysicsMaterial object at 0x7fb66c30cd30>\n```\n",
"snippet":"applied_physics_material = dynamic_cylinder.get_applied_physics_material()\n",
"category":"method"
},
{
"title":"get_applied_visual_material",
"description":"Return the current applied visual material in case it was applied using apply\\_visual\\_material\nor it's one of the following materials that was already applied before: PreviewSurface, OmniPBR and OmniGlass.\n\n**Returns:**\n\n * VisualMaterial: the current applied visual material if its type is currently supported.\n\n---\n**Example:**\n\n```python\n>>> # given a visual material applied\n>>> prim.get_applied_visual_material()\n<omni.isaac.core.materials.omni_glass.OmniGlass object at 0x7f36263106a0>\n```\n",
"snippet":"applied_visual_material = dynamic_cylinder.get_applied_visual_material()\n",
"category":"method"
},
{
"title":"get_collision_approximation",
"description":"Get the collision approximation\n\n| Approximation           | Full name            | Description                                                                               |\n|-------------------------|----------------------|-------------------------------------------------------------------------------------------|\n| `\"none\"`                | Triangle Mesh        | The mesh geometry is used directly as a collider without any approximation                |\n| `\"convexDecomposition\"` | Convex Decomposition | A convex mesh decomposition is performed. This results in a set of convex mesh colliders  |\n| `\"convexHull\"`          | Convex Hull          | A convex hull of the mesh is generated and used as the collider                           |\n| `\"boundingSphere\"`      | Bounding Sphere      | A bounding sphere is computed around the mesh and used as a collider                      |\n| `\"boundingCube\"`        | Bounding Cube        | An optimally fitting box collider is computed around the mesh                             |\n| `\"meshSimplification\"`  | Mesh Simplification  | A mesh simplification step is performed, resulting in a simplified triangle mesh collider |\n| `\"sdf\"`                 | SDF Mesh             | SDF (Signed-Distance-Field) use high-detail triangle meshes as collision shape            |\n| `\"sphereFill\"`          | Sphere Approximation | A sphere mesh decomposition is performed. This results in a set of sphere colliders       |\n\n**Returns:**\n\n * str: approximation used for collision\n\n---\n**Example:**\n\n```python\n>>> prim.get_collision_approximation()\nnone\n```\n",
"snippet":"collision_approximation = dynamic_cylinder.get_collision_approximation()\n",
"category":"method"
},
{
"title":"get_collision_enabled",
"description":"Check if the Collision API is enabled\n\n**Returns:**\n\n * bool: True if the Collision API is enabled. Otherwise False\n\n---\n**Example:**\n\n```python\n>>> prim.get_collision_enabled()\nTrue\n```\n",
"snippet":"collision_enabled = dynamic_cylinder.get_collision_enabled()\n",
"category":"method"
},
{
"title":"get_contact_force_matrix",
"description":"If the object is initialized with filter\\_paths\\_expr list, this method returns the contact forces between the prims\nin the view and the filter prims. i.e., a matrix of dimension (self.\\_contact\\_view.num\\_filters, 3)\nwhere num\\_filters is the determined according to the filter\\_paths\\_expr parameter.\n\n**Args:**\n\n * `dt` (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor\\]: Net contact forces of the prims with shape (self.\\_geometry\\_prim\\_view.\\_contact\\_view.num\\_filters, 3).\n",
"snippet":"contact_force_matrix = dynamic_cylinder.get_contact_force_matrix()\n",
"category":"method"
},
{
"title":"get_contact_offset",
"description":"Get the contact offset\n\nShapes whose distance is less than the sum of their contact offset values will generate contacts\n\nSearch for *Advanced Collision Detection* in for more details\n\n**Returns:**\n\n * float: contact offset of the collision shape. Default value is -inf, means default is picked by simulation.\n\n---\n**Example:**\n\n```python\n>>> prim.get_contact_offset()\n-inf\n```\n",
"snippet":"contact_offset = dynamic_cylinder.get_contact_offset()\n",
"category":"method"
},
{
"title":"get_current_dynamic_state",
"description":"Get the current rigid body state (position, orientation and linear and angular velocities)\n\n**Returns:**\n\n * DynamicState: the dynamic state of the rigid body prim\n\n---\n**Example:**\n\n```python\n>>> # for the example the rigid body is in free fall\n>>> state = prim.get_current_dynamic_state()\n>>> state\n<omni.isaac.core.utils.types.DynamicState object at 0x7f740b36f670>\n>>> state.position\n[  0.99999857   2.0000017  -74.2862    ]\n>>> state.orientation\n[ 1.0000000e+00 -2.3961178e-07 -4.9891562e-09  4.9388258e-09]\n>>> state.linear_velocity\n[  0.        0.      -38.09554]\n>>> state.angular_velocity\n[0. 0. 0.]\n```\n",
"snippet":"current_dynamic_state = dynamic_cylinder.get_current_dynamic_state()\n",
"category":"method"
},
{
"title":"get_default_state",
"description":"Get the default rigid body state (position, orientation and linear and angular velocities)\n\n**Returns:**\n\n * DynamicState: returns the default state of the prim that is used after each reset\n\n---\n**Example:**\n\n```python\n>>> state = prim.get_default_state()\n>>> state\n<omni.isaac.core.utils.types.DynamicState object at 0x7f7411fcbe20>\n>>> state.position\n[-7.8622378e-07  1.4450421e-06  1.6135601e-07]\n>>> state.orientation\n[ 9.9999994e-01 -2.7194994e-07  2.9607077e-07  2.7016510e-08]\n>>> state.linear_velocity\n[0. 0. 0.]\n>>> state.angular_velocity\n[0. 0. 0.]\n```\n",
"snippet":"default_state = dynamic_cylinder.get_default_state()\n",
"category":"method"
},
{
"title":"get_default_state",
"description":"Get the default prim states (spatial position and orientation).\n\n**Returns:**\n\n * XFormPrimState: an object that contains the default state of the prim (position and orientation)\n\n---\n**Example:**\n\n```python\n>>> state = prim.get_default_state()\n>>> state\n<omni.isaac.core.utils.types.XFormPrimState object at 0x7f33addda650>\n>>>\n>>> state.position\n[-4.5299529e-08 -1.8347054e-09 -2.8610229e-08]\n>>> state.orientation\n[1. 0. 0. 0.]\n```\n",
"snippet":"default_state = dynamic_cylinder.get_default_state()\n",
"category":"method"
},
{
"title":"get_density",
"description":"Get the density of the rigid body\n\n**Returns:**\n\n * float: density of the rigid body.\n\n---\n**Example:**\n\n```python\n>>> prim.get_density()\n0\n```\n",
"snippet":"density = dynamic_cylinder.get_density()\n",
"category":"method"
},
{
"title":"get_height",
"description":"Get the cylinder height\n\n**Returns:**\n\n * float: cylinder height\n\n---\n**Example:**\n\n```python\n>>> prim.get_height()\n1.0\n```\n",
"snippet":"height = dynamic_cylinder.get_height()\n",
"category":"method"
},
{
"title":"get_linear_velocity",
"description":"Get the linear velocity of the rigid body\n\n**Returns:**\n\n * np.ndarray: current linear velocity of the the rigid prim. Shape (3,).\n\n---\n**Example:**\n\n```python\n>>> prim.get_linear_velocity()\n[ 1.0812164e-04  6.1415871e-05 -2.1341663e-04]\n```\n",
"snippet":"linear_velocity = dynamic_cylinder.get_linear_velocity()\n",
"category":"method"
},
{
"title":"get_local_pose",
"description":"Get prim's pose with respect to the local frame (the prim's parent frame)\n\n**Returns:**\n\n * Tuple\\[np.ndarray, np.ndarray\\]: first index is the position in the local frame (with shape (3, )).\n    Second index is quaternion orientation (with shape (4, )) in the local frame\n\n---\n**Example:**\n\n```python\n>>> # if the prim is in position (1.0, 0.5, 0.0) with respect to the world frame\n>>> position, orientation = prim.get_local_pose()\n>>> position\n[0. 0. 0.]\n>>> orientation\n[0. 0. 0.]\n```\n",
"snippet":"local_pose = dynamic_cylinder.get_local_pose()\n",
"category":"method"
},
{
"title":"get_local_scale",
"description":"Get prim's scale with respect to the local frame (the parent's frame)\n\n**Returns:**\n\n * np.ndarray: scale applied to the prim's dimensions in the local frame. shape is (3, ).\n\n---\n**Example:**\n\n```python\n>>> prim.get_local_scale()\n[1. 1. 1.]\n```\n",
"snippet":"local_scale = dynamic_cylinder.get_local_scale()\n",
"category":"method"
},
{
"title":"get_mass",
"description":"Get the mass of the rigid body\n\n**Returns:**\n\n * float: mass of the rigid body in kg.\n\n---\n**Example:**\n\n```python\n>>> prim.get_mass()\n0\n```\n",
"snippet":"mass = dynamic_cylinder.get_mass()\n",
"category":"method"
},
{
"title":"get_min_torsional_patch_radius",
"description":"Get the minimum radius of the contact patch used to apply torsional friction\n\nSearch for *\"Torsional Patch Radius\"* in for more details\n\n**Returns:**\n\n * float: minimum radius of the contact patch used to apply torsional friction. Allowed range \\[0, max\\_float\\].\n\n---\n**Example:**\n\n```python\n>>> prim.get_min_torsional_patch_radius()\n0.0\n```\n",
"snippet":"min_torsional_patch_radius = dynamic_cylinder.get_min_torsional_patch_radius()\n",
"category":"method"
},
{
"title":"get_net_contact_forces",
"description":"If contact forces of the prims in the view are tracked, this method returns the net contact forces on prims.\ni.e., a matrix of dimension (1, 3)\n\n**Args:**\n\n * `dt` (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor\\]: Net contact forces of the prims with shape (3).\n",
"snippet":"net_contact_forces = dynamic_cylinder.get_net_contact_forces()\n",
"category":"method"
},
{
"title":"get_radius",
"description":"Get the base radius\n\n**Returns:**\n\n * float: base radius\n\n---\n**Example:**\n\n```python\n>>> prim.get_radius()\n0.5\n```\n",
"snippet":"radius = dynamic_cylinder.get_radius()\n",
"category":"method"
},
{
"title":"get_rest_offset",
"description":"Get the rest offset\n\nTwo shapes will come to rest at a distance equal to the sum of their rest offset values.\nIf the rest offset is 0, they should converge to touching exactly\n\nSearch for *Advanced Collision Detection* in for more details\n\n**Returns:**\n\n * float: rest offset of the collision shape.\n\n---\n**Example:**\n\n```python\n>>> prim.get_rest_offset()\n-inf\n```\n",
"snippet":"rest_offset = dynamic_cylinder.get_rest_offset()\n",
"category":"method"
},
{
"title":"get_sleep_threshold",
"description":"Get the threshold for the rigid body to enter a sleep state\n\nSearch for *Rigid Body Dynamics* \\> *Sleeping* in for more details\n\n**Returns:**\n\n * float: Mass-normalized kinetic energy threshold below which an actor may go to sleep. Range: \\[0, inf) Defaults: 0.00005 \\* tolerancesSpeed\\* tolerancesSpeed Units: distance\\^2 / second\\^2.\n\n---\n**Example:**\n\n```python\n>>> prim.get_sleep_threshold()\n5e-05\n```\n",
"snippet":"sleep_threshold = dynamic_cylinder.get_sleep_threshold()\n",
"category":"method"
},
{
"title":"get_torsional_patch_radius",
"description":"Get the radius of the contact patch used to apply torsional friction\n\nSearch for *\"Torsional Patch Radius\"* in for more details\n\n**Returns:**\n\n * float: radius of the contact patch used to apply torsional friction. Allowed range \\[0, max\\_float\\].\n\n---\n**Example:**\n\n```python\n>>> prim.get_torsional_patch_radius()\n0.0\n```\n",
"snippet":"torsional_patch_radius = dynamic_cylinder.get_torsional_patch_radius()\n",
"category":"method"
},
{
"title":"get_visibility",
"description":"**Returns:**\n\n * bool: true if the prim is visible in stage. false otherwise.\n\n---\n**Example:**\n\n```python\n>>> # get the visible state of an visible prim on the stage\n>>> prim.get_visibility()\nTrue\n```\n",
"snippet":"visibility = dynamic_cylinder.get_visibility()\n",
"category":"method"
},
{
"title":"get_world_pose",
"description":"Get prim's pose with respect to the world's frame\n\n**Returns:**\n\n * Tuple\\[np.ndarray, np.ndarray\\]: first index is the position in the world frame (with shape (3, )).\n    Second index is quaternion orientation (with shape (4, )) in the world frame\n\n---\n**Example:**\n\n```python\n>>> # if the prim is in position (1.0, 0.5, 0.0) with respect to the world frame\n>>> position, orientation = prim.get_world_pose()\n>>> position\n[1.  0.5 0. ]\n>>> orientation\n[1. 0. 0. 0.]\n```\n",
"snippet":"world_pose = dynamic_cylinder.get_world_pose()\n",
"category":"method"
},
{
"title":"get_world_scale",
"description":"Get prim's scale with respect to the world's frame\n\n**Returns:**\n\n * np.ndarray: scale applied to the prim's dimensions in the world frame. shape is (3, ).\n\n---\n**Example:**\n\n```python\n>>> prim.get_world_scale()\n[1. 1. 1.]\n```\n",
"snippet":"world_scale = dynamic_cylinder.get_world_scale()\n",
"category":"method"
},
{
"title":"initialize",
"description":"Create a physics simulation view if not passed and using PhysX tensor API\n\n*Note:*\nIf the prim has been added to the world scene (e.g., `world.scene.add(prim)`),\nit will be automatically initialized when the world is reset (e.g., `world.reset()`).\n\n**Args:**\n\n * `physics_sim_view` (omni.physics.tensors.SimulationView, optional): current physics simulation view. Defaults to None.\n\n---\n**Example:**\n\n```python\n>>> prim.initialize()\n```\n",
"snippet":"dynamic_cylinder.initialize()\n",
"category":"method"
},
{
"title":"is_valid",
"description":"Check if the prim path has a valid USD Prim at it\n\n**Returns:**\n\n * bool: True is the current prim path corresponds to a valid prim in stage. False otherwise.\n\n---\n**Example:**\n\n```python\n>>> # given an existing and valid prim\n>>> prims.is_valid()\nTrue\n```\n",
"snippet":"value = dynamic_cylinder.is_valid()\n",
"category":"method"
},
{
"title":"is_visual_material_applied",
"description":"Check if there is a visual material applied\n\n**Returns:**\n\n * bool: True if there is a visual material applied. False otherwise.\n\n---\n**Example:**\n\n```python\n>>> # given a visual material applied\n>>> prim.is_visual_material_applied()\nTrue\n```\n",
"snippet":"value = dynamic_cylinder.is_visual_material_applied()\n",
"category":"method"
},
{
"title":"post_reset",
"description":"Reset the prim to its default state (position and orientation).\n\n*Note:*\nFor an articulation, in addition to configuring the root prim's default position and spatial orientation\n(defined via the `set_default_state` method), the joint's positions, velocities, and efforts\n(defined via the `set_joints_default_state` method) are imposed\n\n---\n**Example:**\n\n```python\n>>> prim.post_reset()\n```\n",
"snippet":"dynamic_cylinder.post_reset()\n",
"category":"method"
},
{
"title":"set_angular_velocity",
"description":"Set the angular velocity of the rigid body in stage\n\n*Warning:*\nThis method will immediately set the articulation state\n\n**Args:**\n\n * `velocity` (np.ndarray): angular velocity to set the rigid prim to. Shape (3,).\n\n*Hint:*\nThis method belongs to the methods used to set the rigid prim kinematic state:\n\n> `set_linear_velocity`, `set_angular_velocity`\n\n---\n**Example:**\n\n```python\n>>> prim.set_angular_velocity(np.array([0.0, 0.0, 10.0]))\n```\n",
"snippet":"dynamic_cylinder.set_angular_velocity(velocity=velocity)\n",
"category":"method"
},
{
"title":"set_collision_approximation",
"description":"Set the collision approximation\n\n| Approximation           | Full name            | Description                                                                               |\n|-------------------------|----------------------|-------------------------------------------------------------------------------------------|\n| `\"none\"`                | Triangle Mesh        | The mesh geometry is used directly as a collider without any approximation                |\n| `\"convexDecomposition\"` | Convex Decomposition | A convex mesh decomposition is performed. This results in a set of convex mesh colliders  |\n| `\"convexHull\"`          | Convex Hull          | A convex hull of the mesh is generated and used as the collider                           |\n| `\"boundingSphere\"`      | Bounding Sphere      | A bounding sphere is computed around the mesh and used as a collider                      |\n| `\"boundingCube\"`        | Bounding Cube        | An optimally fitting box collider is computed around the mesh                             |\n| `\"meshSimplification\"`  | Mesh Simplification  | A mesh simplification step is performed, resulting in a simplified triangle mesh collider |\n| `\"sdf\"`                 | SDF Mesh             | SDF (Signed-Distance-Field) use high-detail triangle meshes as collision shape            |\n| `\"sphereFill\"`          | Sphere Approximation | A sphere mesh decomposition is performed. This results in a set of sphere colliders       |\n\n*Warning:*\nSwitching to Convex Decomposition or SDF (Signed-Distance-Field) will have a simulation performance\nimpact due to higher computational cost\n\n**Args:**\n\n * `approximation_type` (str): approximation used for collision\n\n---\n**Example:**\n\n```python\n>>> prim.set_collision_approximation(\"convexDecomposition\")\n```\n",
"snippet":"dynamic_cylinder.set_collision_approximation(approximation_type=approximation_type)\n",
"category":"method"
},
{
"title":"set_collision_enabled",
"description":"Enable/disable the Collision API\n\n**Args:**\n\n * `enabled` (bool): Whether to enable or disable the Collision API\n\n---\n**Example:**\n\n```python\n>>> # disable collisions\n>>> prim.set_collision_enabled(False)\n```\n",
"snippet":"dynamic_cylinder.set_collision_enabled(enabled=enabled)\n",
"category":"method"
},
{
"title":"set_contact_offset",
"description":"Set the contact offset\n\nShapes whose distance is less than the sum of their contact offset values will generate contacts\n\nSearch for *Advanced Collision Detection* in for more details\n\n*Warning:*\nThe contact offset must be positive and greater than the rest offset\n\n**Args:**\n\n * `offset` (float): Contact offset of a collision shape. Allowed range \\[maximum(0, rest\\_offset), 0\\]. Default value is -inf, means default is picked by simulation based on the shape extent.\n\n---\n**Example:**\n\n```python\n>>> prim.set_contact_offset(0.02)\n```\n",
"snippet":"dynamic_cylinder.set_contact_offset(offset=offset)\n",
"category":"method"
},
{
"title":"set_default_state",
"description":"Set the default state of the prim (position, orientation and linear and angular velocities),\nthat will be used after each reset\n\n*Note:*\nThe default states will be set during post-reset (e.g., calling `.post_reset()` or `world.reset()` methods)\n\n**Args:**\n\n * `position` (Optional\\[Sequence\\[float\\]\\], optional): position in the world frame of the prim. shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the world frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n * `linear_velocity` (np.ndarray): linear velocity to set the rigid prim to. Shape (3,).\n * `angular_velocity` (np.ndarray): angular velocity to set the rigid prim to. Shape (3,).\n\n---\n**Example:**\n\n```python\n>>> prim.set_default_state(\n...     position=np.array([1.0, 2.0, 3.0]),\n...     orientation=np.array([1.0, 0.0, 0.0, 0.0]),\n...     linear_velocity=np.array([0.0, 0.0, 0.0]),\n...     angular_velocity=np.array([0.0, 0.0, 0.0])\n... )\n>>>\n>>> prim.post_reset()\n```\n",
"snippet":"dynamic_cylinder.set_default_state()\n",
"category":"method"
},
{
"title":"set_default_state",
"description":"Set the default state of the prim (position and orientation), that will be used after each reset.\n\n**Args:**\n\n * `position` (Optional\\[Sequence\\[float\\]\\], optional): position in the world frame of the prim. shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the world frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n\n---\n**Example:**\n\n```python\n>>> # configure default state\n>>> prim.set_default_state(position=np.array([1.0, 0.5, 0.0]), orientation=np.array([1, 0, 0, 0]))\n>>>\n>>> # set default states during post-reset\n>>> prim.post_reset()\n```\n",
"snippet":"dynamic_cylinder.set_default_state()\n",
"category":"method"
},
{
"title":"set_density",
"description":"Set the density of the rigid body\n\n**Args:**\n\n * `mass` (float): density of the rigid body.\n\n---\n**Example:**\n\n```python\n>>> prim.set_density(0.9)\n```\n",
"snippet":"dynamic_cylinder.set_density(density=density)\n",
"category":"method"
},
{
"title":"set_height",
"description":"Set the cylinder height\n\n**Args:**\n\n * `height` (float): cylinder height\n\n---\n**Example:**\n\n```python\n>>> prim.set_height(2.0)\n```\n",
"snippet":"dynamic_cylinder.set_height(height=height)\n",
"category":"method"
},
{
"title":"set_linear_velocity",
"description":"Set the linear velocity of the rigid body in stage\n\n*Warning:*\nThis method will immediately set the rigid prim state\n\n**Args:**\n\n * `velocity` (np.ndarray): linear velocity to set the rigid prim to. Shape (3,).\n\n*Hint:*\nThis method belongs to the methods used to set the rigid prim kinematic state:\n\n> `set_linear_velocity`, `set_angular_velocity`\n\n---\n**Example:**\n\n```python\n>>> prim.set_linear_velocity(np.array([5.0, 0.0, 0.0]))\n```\n",
"snippet":"dynamic_cylinder.set_linear_velocity(velocity=velocity)\n",
"category":"method"
},
{
"title":"set_local_pose",
"description":"Set prim's pose with respect to the local frame (the prim's parent frame).\n\n*Warning:*\nThis method will change (teleport) the prim pose immediately to the indicated value\n\n**Args:**\n\n * `translation` (Optional\\[Sequence\\[float\\]\\], optional): translation in the local frame of the prim (with respect to its parent prim). shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the local frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n\n*Hint:*\nThis method belongs to the methods used to set the prim state\n\n---\n**Example:**\n\n```python\n>>> prim.set_local_pose(translation=np.array([1.0, 0.5, 0.0]), orientation=np.array([1., 0., 0., 0.]))\n```\n",
"snippet":"dynamic_cylinder.set_local_pose()\n",
"category":"method"
},
{
"title":"set_local_scale",
"description":"Set prim's scale with respect to the local frame (the prim's parent frame).\n\n**Args:**\n\n * `scale` (Optional\\[Sequence\\[float\\]\\]): scale to be applied to the prim's dimensions. shape is (3, ). Defaults to None, which means left unchanged.\n\n---\n**Example:**\n\n```python\n>>> # scale prim 10 times smaller\n>>> prim.set_local_scale(np.array([0.1, 0.1, 0.1]))\n```\n",
"snippet":"dynamic_cylinder.set_local_scale(scale=scale)\n",
"category":"method"
},
{
"title":"set_mass",
"description":"Set the mass of the rigid body\n\n**Args:**\n\n * `mass` (float): mass of the rigid body in kg.\n\n---\n**Example:**\n\n```python\n>>> prim.set_mass(1.0)\n```\n",
"snippet":"dynamic_cylinder.set_mass(mass=mass)\n",
"category":"method"
},
{
"title":"set_min_torsional_patch_radius",
"description":"Set the minimum radius of the contact patch used to apply torsional friction\n\nSearch for *\"Torsional Patch Radius\"* in for more details\n\n**Args:**\n\n * `radius` (float): minimum radius of the contact patch used to apply torsional friction. Allowed range \\[0, max\\_float\\].\n\n---\n**Example:**\n\n```python\n>>> prim.set_min_torsional_patch_radius(0.05)\n```\n",
"snippet":"dynamic_cylinder.set_min_torsional_patch_radius(radius=radius)\n",
"category":"method"
},
{
"title":"set_radius",
"description":"Set the base radius\n\n**Args:**\n\n * `radius` (float): base radius\n\n---\n**Example:**\n\n```python\n>>> prim.set_radius(1.0)\n```\n",
"snippet":"dynamic_cylinder.set_radius(radius=radius)\n",
"category":"method"
},
{
"title":"set_rest_offset",
"description":"Set the rest offset\n\nTwo shapes will come to rest at a distance equal to the sum of their rest offset values.\nIf the rest offset is 0, they should converge to touching exactly\n\nSearch for *Advanced Collision Detection* in for more details\n\n*Warning:*\nThe contact offset must be positive and greater than the rest offset\n\n**Args:**\n\n * `offset` (float): Rest offset of a collision shape. Allowed range \\[-max\\_float, contact\\_offset. Default value is -inf, means default is picked by simulation. For rigid bodies its zero.\n\n---\n**Example:**\n\n```python\n>>> prim.set_rest_offset(0.01)\n```\n",
"snippet":"dynamic_cylinder.set_rest_offset(offset=offset)\n",
"category":"method"
},
{
"title":"set_sleep_threshold",
"description":"Set the threshold for the rigid body to enter a sleep state\n\nSearch for *Rigid Body Dynamics* \\> *Sleeping* in for more details\n\n**Args:**\n\n * `threshold` (float): Mass-normalized kinetic energy threshold below which an actor may go to sleep. Range: \\[0, inf) Defaults: 0.00005 \\* tolerancesSpeed\\* tolerancesSpeed Units: distance\\^2 / second\\^2.\n\n---\n**Example:**\n\n```python\n>>> prim.set_sleep_threshold(1e-5)\n```\n",
"snippet":"dynamic_cylinder.set_sleep_threshold(threshold=threshold)\n",
"category":"method"
},
{
"title":"set_torsional_patch_radius",
"description":"Set the radius of the contact patch used to apply torsional friction\n\nSearch for *\"Torsional Patch Radius\"* in for more details\n\n**Args:**\n\n * `radius` (float): radius of the contact patch used to apply torsional friction. Allowed range \\[0, max\\_float\\].\n\n---\n**Example:**\n\n```python\n>>> prim.set_torsional_patch_radius(0.1)\n```\n",
"snippet":"dynamic_cylinder.set_torsional_patch_radius(radius=radius)\n",
"category":"method"
},
{
"title":"set_visibility",
"description":"Set the visibility of the prim in stage\n\n**Args:**\n\n * `visible` (bool): flag to set the visibility of the usd prim in stage.\n\n---\n**Example:**\n\n```python\n>>> # make prim not visible in the stage\n>>> prim.set_visibility(visible=False)\n```\n",
"snippet":"dynamic_cylinder.set_visibility(visible=visible)\n",
"category":"method"
},
{
"title":"set_world_pose",
"description":"Ses prim's pose with respect to the world's frame\n\n*Warning:*\nThis method will change (teleport) the prim pose immediately to the indicated value\n\n**Args:**\n\n * `position` (Optional\\[Sequence\\[float\\]\\], optional): position in the world frame of the prim. shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the world frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n\n*Hint:*\nThis method belongs to the methods used to set the prim state\n\n---\n**Example:**\n\n```python\n>>> prim.set_world_pose(position=np.array([1.0, 0.5, 0.0]), orientation=np.array([1., 0., 0., 0.]))\n```\n",
"snippet":"dynamic_cylinder.set_world_pose()\n",
"category":"method"
}
]
},
{
"title":"DynamicSphere",
"snippets":[
{
"title":"import ...",
"description":"Import class",
"snippet":"from omni.isaac.core.objects import DynamicSphere\n",
"category":"import"
},
{
"title":"DynamicSphere",
"description":"High level wrapper to create/encapsulate a dynamic sphere\n\n*Note:*\nDynamic spheres (Sphere shape) have collisions (Collider API) and rigid body dynamics (Rigid Body API)\n\n**Args:**\n\n * `prim_path` (str): prim path of the Prim to encapsulate or create\n * `name` (str, optional): shortname to be used as a key by Scene class. Note: needs to be unique if the object is added to the Scene. Defaults to \"dynamic\\_sphere\".\n * `position` (Optional\\[Sequence\\[float\\]\\], optional): position in the world frame of the prim. shape is (3, ). Defaults to None, which means left unchanged.\n * `translation` (Optional\\[Sequence\\[float\\]\\], optional): translation in the local frame of the prim (with respect to its parent prim). shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the world/ local frame of the prim (depends if translation or position is specified). quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n * `scale` (Optional\\[Sequence\\[float\\]\\], optional): local scale to be applied to the prim's dimensions. shape is (3, ). Defaults to None, which means left unchanged.\n * `visible` (bool, optional): set to false for an invisible prim in the stage while rendering. Defaults to True.\n * `color` (Optional\\[np.ndarray\\], optional): color of the visual shape. Defaults to None, which means 50% gray\n * `radius` (Optional\\[float\\], optional): sphere radius. Defaults to None.\n * `visual_material` (Optional\\[VisualMaterial\\], optional): visual material to be applied to the held prim. Defaults to None. If not specified, a default visual material will be added.\n * `physics_material` (Optional\\[PhysicsMaterial\\], optional): physics material to be applied to the held prim. Defaults to None. If not specified, a default physics material will be added.\n * `mass` (Optional\\[float\\], optional): mass in kg. Defaults to None.\n * `density` (Optional\\[float\\], optional): density. Defaults to None.\n * `linear_velocity` (Optional\\[np.ndarray\\], optional): linear velocity in the world frame. Defaults to None.\n * `angular_velocity` (Optional\\[np.ndarray\\], optional): angular velocity in the world frame. Defaults to None.\n\n---\n**Example:**\n\n```python\n>>> from omni.isaac.core.objects import DynamicSphere\n>>> import numpy as np\n>>>\n>>> # create a red dynamic sphere of mass 1kg at the given path\n>>> prim = DynamicSphere(prim_path=\"/World/Xform/Sphere\", color=np.array([1.0, 0.0, 0.0]), mass=1.0)\n>>> prim\n<omni.isaac.core.objects.sphere.DynamicSphere object at 0x7f4deaf8f010>\n```\n",
"snippet":"dynamic_sphere = DynamicSphere(prim_path=prim_path)\n",
"category":"class"
},
{
"title":"apply_physics_material",
"description":"Used to apply physics material to the held prim and optionally its descendants.\n\n**Args:**\n\n * `physics_material` (PhysicsMaterial): physics material to be applied to the held prim. This where you want to define friction, restitution..etc. Note: if a physics material is not defined, the defaults will be used from PhysX.\n * `weaker_than_descendants` (bool, optional): True if the material shouldn't override the descendants materials, otherwise False. Defaults to False.\n\n---\n**Example:**\n\n```python\n>>> from omni.isaac.core.materials import PhysicsMaterial\n>>>\n>>> # create a rigid body physical material\n>>> material = PhysicsMaterial(\n...     prim_path=\"/World/physics_material/aluminum\",  # path to the material prim to create\n...     dynamic_friction=0.4,\n...     static_friction=1.1,\n...     restitution=0.1\n... )\n>>> prim.apply_physics_material(material)\n```\n",
"snippet":"dynamic_sphere.apply_physics_material(physics_material=physics_material)\n",
"category":"method"
},
{
"title":"apply_visual_material",
"description":"Apply visual material to the held prim and optionally its descendants.\n\n**Args:**\n\n * `visual_material` (VisualMaterial): visual material to be applied to the held prim. Currently supports PreviewSurface, OmniPBR and OmniGlass.\n * `weaker_than_descendants` (bool, optional): True if the material shouldn't override the descendants materials, otherwise False. Defaults to False.\n\n---\n**Example:**\n\n```python\n>>> from omni.isaac.core.materials import OmniGlass\n>>>\n>>> # create a dark-red glass visual material\n>>> material = OmniGlass(\n...     prim_path=\"/World/material/glass\",  # path to the material prim to create\n...     ior=1.25,\n...     depth=0.001,\n...     thin_walled=False,\n...     color=np.array([0.5, 0.0, 0.0])\n... )\n>>> prim.apply_visual_material(material)\n```\n",
"snippet":"dynamic_sphere.apply_visual_material(visual_material=visual_material)\n",
"category":"method"
},
{
"title":"disable_rigid_body_physics",
"description":"Disable the rigid body physics\n\nWhen disabled, the object will not be moved by external forces such as gravity and collisions\n\n---\n**Example:**\n\n```python\n>>> prim.disable_rigid_body_physics()\n```\n",
"snippet":"dynamic_sphere.disable_rigid_body_physics()\n",
"category":"method"
},
{
"title":"enable_rigid_body_physics",
"description":"Enable the rigid body physics\n\nWhen enabled, the object will be moved by external forces such as gravity and collisions\n\n---\n**Example:**\n\n```python\n>>> prim.enable_rigid_body_physics()\n```\n",
"snippet":"dynamic_sphere.enable_rigid_body_physics()\n",
"category":"method"
},
{
"title":"get_angular_velocity",
"description":"Get the angular velocity of the rigid body\n\n**Returns:**\n\n * np.ndarray: current angular velocity of the the rigid prim. Shape (3,).\n\n---\n**Example:**\n\n```python\n>>> prim.get_angular_velocity()]\n[-0.01727393  0.00827609 -0.00040014]\n```\n",
"snippet":"dynamic_sphere.get_angular_velocity()\n",
"category":"method"
},
{
"title":"get_applied_physics_material",
"description":"Return the current applied physics material in case it was applied using apply\\_physics\\_material or not.\n\n**Returns:**\n\n * PhysicsMaterial: the current applied physics material.\n\n---\n**Example:**\n\n```python\n>>> # given a physics material applied\n>>> prim.get_applied_physics_material()\n<omni.isaac.core.materials.physics_material.PhysicsMaterial object at 0x7fb66c30cd30>\n```\n",
"snippet":"applied_physics_material = dynamic_sphere.get_applied_physics_material()\n",
"category":"method"
},
{
"title":"get_applied_visual_material",
"description":"Return the current applied visual material in case it was applied using apply\\_visual\\_material\nor it's one of the following materials that was already applied before: PreviewSurface, OmniPBR and OmniGlass.\n\n**Returns:**\n\n * VisualMaterial: the current applied visual material if its type is currently supported.\n\n---\n**Example:**\n\n```python\n>>> # given a visual material applied\n>>> prim.get_applied_visual_material()\n<omni.isaac.core.materials.omni_glass.OmniGlass object at 0x7f36263106a0>\n```\n",
"snippet":"applied_visual_material = dynamic_sphere.get_applied_visual_material()\n",
"category":"method"
},
{
"title":"get_collision_approximation",
"description":"Get the collision approximation\n\n| Approximation           | Full name            | Description                                                                               |\n|-------------------------|----------------------|-------------------------------------------------------------------------------------------|\n| `\"none\"`                | Triangle Mesh        | The mesh geometry is used directly as a collider without any approximation                |\n| `\"convexDecomposition\"` | Convex Decomposition | A convex mesh decomposition is performed. This results in a set of convex mesh colliders  |\n| `\"convexHull\"`          | Convex Hull          | A convex hull of the mesh is generated and used as the collider                           |\n| `\"boundingSphere\"`      | Bounding Sphere      | A bounding sphere is computed around the mesh and used as a collider                      |\n| `\"boundingCube\"`        | Bounding Cube        | An optimally fitting box collider is computed around the mesh                             |\n| `\"meshSimplification\"`  | Mesh Simplification  | A mesh simplification step is performed, resulting in a simplified triangle mesh collider |\n| `\"sdf\"`                 | SDF Mesh             | SDF (Signed-Distance-Field) use high-detail triangle meshes as collision shape            |\n| `\"sphereFill\"`          | Sphere Approximation | A sphere mesh decomposition is performed. This results in a set of sphere colliders       |\n\n**Returns:**\n\n * str: approximation used for collision\n\n---\n**Example:**\n\n```python\n>>> prim.get_collision_approximation()\nnone\n```\n",
"snippet":"collision_approximation = dynamic_sphere.get_collision_approximation()\n",
"category":"method"
},
{
"title":"get_collision_enabled",
"description":"Check if the Collision API is enabled\n\n**Returns:**\n\n * bool: True if the Collision API is enabled. Otherwise False\n\n---\n**Example:**\n\n```python\n>>> prim.get_collision_enabled()\nTrue\n```\n",
"snippet":"collision_enabled = dynamic_sphere.get_collision_enabled()\n",
"category":"method"
},
{
"title":"get_contact_force_matrix",
"description":"If the object is initialized with filter\\_paths\\_expr list, this method returns the contact forces between the prims\nin the view and the filter prims. i.e., a matrix of dimension (self.\\_contact\\_view.num\\_filters, 3)\nwhere num\\_filters is the determined according to the filter\\_paths\\_expr parameter.\n\n**Args:**\n\n * `dt` (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor\\]: Net contact forces of the prims with shape (self.\\_geometry\\_prim\\_view.\\_contact\\_view.num\\_filters, 3).\n",
"snippet":"contact_force_matrix = dynamic_sphere.get_contact_force_matrix()\n",
"category":"method"
},
{
"title":"get_contact_offset",
"description":"Get the contact offset\n\nShapes whose distance is less than the sum of their contact offset values will generate contacts\n\nSearch for *Advanced Collision Detection* in for more details\n\n**Returns:**\n\n * float: contact offset of the collision shape. Default value is -inf, means default is picked by simulation.\n\n---\n**Example:**\n\n```python\n>>> prim.get_contact_offset()\n-inf\n```\n",
"snippet":"contact_offset = dynamic_sphere.get_contact_offset()\n",
"category":"method"
},
{
"title":"get_current_dynamic_state",
"description":"Get the current rigid body state (position, orientation and linear and angular velocities)\n\n**Returns:**\n\n * DynamicState: the dynamic state of the rigid body prim\n\n---\n**Example:**\n\n```python\n>>> # for the example the rigid body is in free fall\n>>> state = prim.get_current_dynamic_state()\n>>> state\n<omni.isaac.core.utils.types.DynamicState object at 0x7f740b36f670>\n>>> state.position\n[  0.99999857   2.0000017  -74.2862    ]\n>>> state.orientation\n[ 1.0000000e+00 -2.3961178e-07 -4.9891562e-09  4.9388258e-09]\n>>> state.linear_velocity\n[  0.        0.      -38.09554]\n>>> state.angular_velocity\n[0. 0. 0.]\n```\n",
"snippet":"current_dynamic_state = dynamic_sphere.get_current_dynamic_state()\n",
"category":"method"
},
{
"title":"get_default_state",
"description":"Get the default rigid body state (position, orientation and linear and angular velocities)\n\n**Returns:**\n\n * DynamicState: returns the default state of the prim that is used after each reset\n\n---\n**Example:**\n\n```python\n>>> state = prim.get_default_state()\n>>> state\n<omni.isaac.core.utils.types.DynamicState object at 0x7f7411fcbe20>\n>>> state.position\n[-7.8622378e-07  1.4450421e-06  1.6135601e-07]\n>>> state.orientation\n[ 9.9999994e-01 -2.7194994e-07  2.9607077e-07  2.7016510e-08]\n>>> state.linear_velocity\n[0. 0. 0.]\n>>> state.angular_velocity\n[0. 0. 0.]\n```\n",
"snippet":"default_state = dynamic_sphere.get_default_state()\n",
"category":"method"
},
{
"title":"get_default_state",
"description":"Get the default prim states (spatial position and orientation).\n\n**Returns:**\n\n * XFormPrimState: an object that contains the default state of the prim (position and orientation)\n\n---\n**Example:**\n\n```python\n>>> state = prim.get_default_state()\n>>> state\n<omni.isaac.core.utils.types.XFormPrimState object at 0x7f33addda650>\n>>>\n>>> state.position\n[-4.5299529e-08 -1.8347054e-09 -2.8610229e-08]\n>>> state.orientation\n[1. 0. 0. 0.]\n```\n",
"snippet":"default_state = dynamic_sphere.get_default_state()\n",
"category":"method"
},
{
"title":"get_density",
"description":"Get the density of the rigid body\n\n**Returns:**\n\n * float: density of the rigid body.\n\n---\n**Example:**\n\n```python\n>>> prim.get_density()\n0\n```\n",
"snippet":"density = dynamic_sphere.get_density()\n",
"category":"method"
},
{
"title":"get_linear_velocity",
"description":"Get the linear velocity of the rigid body\n\n**Returns:**\n\n * np.ndarray: current linear velocity of the the rigid prim. Shape (3,).\n\n---\n**Example:**\n\n```python\n>>> prim.get_linear_velocity()\n[ 1.0812164e-04  6.1415871e-05 -2.1341663e-04]\n```\n",
"snippet":"linear_velocity = dynamic_sphere.get_linear_velocity()\n",
"category":"method"
},
{
"title":"get_local_pose",
"description":"Get prim's pose with respect to the local frame (the prim's parent frame)\n\n**Returns:**\n\n * Tuple\\[np.ndarray, np.ndarray\\]: first index is the position in the local frame (with shape (3, )).\n    Second index is quaternion orientation (with shape (4, )) in the local frame\n\n---\n**Example:**\n\n```python\n>>> # if the prim is in position (1.0, 0.5, 0.0) with respect to the world frame\n>>> position, orientation = prim.get_local_pose()\n>>> position\n[0. 0. 0.]\n>>> orientation\n[0. 0. 0.]\n```\n",
"snippet":"local_pose = dynamic_sphere.get_local_pose()\n",
"category":"method"
},
{
"title":"get_local_scale",
"description":"Get prim's scale with respect to the local frame (the parent's frame)\n\n**Returns:**\n\n * np.ndarray: scale applied to the prim's dimensions in the local frame. shape is (3, ).\n\n---\n**Example:**\n\n```python\n>>> prim.get_local_scale()\n[1. 1. 1.]\n```\n",
"snippet":"local_scale = dynamic_sphere.get_local_scale()\n",
"category":"method"
},
{
"title":"get_mass",
"description":"Get the mass of the rigid body\n\n**Returns:**\n\n * float: mass of the rigid body in kg.\n\n---\n**Example:**\n\n```python\n>>> prim.get_mass()\n0\n```\n",
"snippet":"mass = dynamic_sphere.get_mass()\n",
"category":"method"
},
{
"title":"get_min_torsional_patch_radius",
"description":"Get the minimum radius of the contact patch used to apply torsional friction\n\nSearch for *\"Torsional Patch Radius\"* in for more details\n\n**Returns:**\n\n * float: minimum radius of the contact patch used to apply torsional friction. Allowed range \\[0, max\\_float\\].\n\n---\n**Example:**\n\n```python\n>>> prim.get_min_torsional_patch_radius()\n0.0\n```\n",
"snippet":"min_torsional_patch_radius = dynamic_sphere.get_min_torsional_patch_radius()\n",
"category":"method"
},
{
"title":"get_net_contact_forces",
"description":"If contact forces of the prims in the view are tracked, this method returns the net contact forces on prims.\ni.e., a matrix of dimension (1, 3)\n\n**Args:**\n\n * `dt` (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor\\]: Net contact forces of the prims with shape (3).\n",
"snippet":"net_contact_forces = dynamic_sphere.get_net_contact_forces()\n",
"category":"method"
},
{
"title":"get_radius",
"description":"Get the sphere radius\n\n**Returns:**\n\n * float: sphere radius\n\n---\n**Example:**\n\n```python\n>>> prim.get_radius()\n1.0\n```\n",
"snippet":"radius = dynamic_sphere.get_radius()\n",
"category":"method"
},
{
"title":"get_rest_offset",
"description":"Get the rest offset\n\nTwo shapes will come to rest at a distance equal to the sum of their rest offset values.\nIf the rest offset is 0, they should converge to touching exactly\n\nSearch for *Advanced Collision Detection* in for more details\n\n**Returns:**\n\n * float: rest offset of the collision shape.\n\n---\n**Example:**\n\n```python\n>>> prim.get_rest_offset()\n-inf\n```\n",
"snippet":"rest_offset = dynamic_sphere.get_rest_offset()\n",
"category":"method"
},
{
"title":"get_sleep_threshold",
"description":"Get the threshold for the rigid body to enter a sleep state\n\nSearch for *Rigid Body Dynamics* \\> *Sleeping* in for more details\n\n**Returns:**\n\n * float: Mass-normalized kinetic energy threshold below which an actor may go to sleep. Range: \\[0, inf) Defaults: 0.00005 \\* tolerancesSpeed\\* tolerancesSpeed Units: distance\\^2 / second\\^2.\n\n---\n**Example:**\n\n```python\n>>> prim.get_sleep_threshold()\n5e-05\n```\n",
"snippet":"sleep_threshold = dynamic_sphere.get_sleep_threshold()\n",
"category":"method"
},
{
"title":"get_torsional_patch_radius",
"description":"Get the radius of the contact patch used to apply torsional friction\n\nSearch for *\"Torsional Patch Radius\"* in for more details\n\n**Returns:**\n\n * float: radius of the contact patch used to apply torsional friction. Allowed range \\[0, max\\_float\\].\n\n---\n**Example:**\n\n```python\n>>> prim.get_torsional_patch_radius()\n0.0\n```\n",
"snippet":"torsional_patch_radius = dynamic_sphere.get_torsional_patch_radius()\n",
"category":"method"
},
{
"title":"get_visibility",
"description":"**Returns:**\n\n * bool: true if the prim is visible in stage. false otherwise.\n\n---\n**Example:**\n\n```python\n>>> # get the visible state of an visible prim on the stage\n>>> prim.get_visibility()\nTrue\n```\n",
"snippet":"visibility = dynamic_sphere.get_visibility()\n",
"category":"method"
},
{
"title":"get_world_pose",
"description":"Get prim's pose with respect to the world's frame\n\n**Returns:**\n\n * Tuple\\[np.ndarray, np.ndarray\\]: first index is the position in the world frame (with shape (3, )).\n    Second index is quaternion orientation (with shape (4, )) in the world frame\n\n---\n**Example:**\n\n```python\n>>> # if the prim is in position (1.0, 0.5, 0.0) with respect to the world frame\n>>> position, orientation = prim.get_world_pose()\n>>> position\n[1.  0.5 0. ]\n>>> orientation\n[1. 0. 0. 0.]\n```\n",
"snippet":"world_pose = dynamic_sphere.get_world_pose()\n",
"category":"method"
},
{
"title":"get_world_scale",
"description":"Get prim's scale with respect to the world's frame\n\n**Returns:**\n\n * np.ndarray: scale applied to the prim's dimensions in the world frame. shape is (3, ).\n\n---\n**Example:**\n\n```python\n>>> prim.get_world_scale()\n[1. 1. 1.]\n```\n",
"snippet":"world_scale = dynamic_sphere.get_world_scale()\n",
"category":"method"
},
{
"title":"initialize",
"description":"Create a physics simulation view if not passed and using PhysX tensor API\n\n*Note:*\nIf the prim has been added to the world scene (e.g., `world.scene.add(prim)`),\nit will be automatically initialized when the world is reset (e.g., `world.reset()`).\n\n**Args:**\n\n * `physics_sim_view` (omni.physics.tensors.SimulationView, optional): current physics simulation view. Defaults to None.\n\n---\n**Example:**\n\n```python\n>>> prim.initialize()\n```\n",
"snippet":"dynamic_sphere.initialize()\n",
"category":"method"
},
{
"title":"is_valid",
"description":"Check if the prim path has a valid USD Prim at it\n\n**Returns:**\n\n * bool: True is the current prim path corresponds to a valid prim in stage. False otherwise.\n\n---\n**Example:**\n\n```python\n>>> # given an existing and valid prim\n>>> prims.is_valid()\nTrue\n```\n",
"snippet":"value = dynamic_sphere.is_valid()\n",
"category":"method"
},
{
"title":"is_visual_material_applied",
"description":"Check if there is a visual material applied\n\n**Returns:**\n\n * bool: True if there is a visual material applied. False otherwise.\n\n---\n**Example:**\n\n```python\n>>> # given a visual material applied\n>>> prim.is_visual_material_applied()\nTrue\n```\n",
"snippet":"value = dynamic_sphere.is_visual_material_applied()\n",
"category":"method"
},
{
"title":"post_reset",
"description":"Reset the prim to its default state (position and orientation).\n\n*Note:*\nFor an articulation, in addition to configuring the root prim's default position and spatial orientation\n(defined via the `set_default_state` method), the joint's positions, velocities, and efforts\n(defined via the `set_joints_default_state` method) are imposed\n\n---\n**Example:**\n\n```python\n>>> prim.post_reset()\n```\n",
"snippet":"dynamic_sphere.post_reset()\n",
"category":"method"
},
{
"title":"set_angular_velocity",
"description":"Set the angular velocity of the rigid body in stage\n\n*Warning:*\nThis method will immediately set the articulation state\n\n**Args:**\n\n * `velocity` (np.ndarray): angular velocity to set the rigid prim to. Shape (3,).\n\n*Hint:*\nThis method belongs to the methods used to set the rigid prim kinematic state:\n\n> `set_linear_velocity`, `set_angular_velocity`\n\n---\n**Example:**\n\n```python\n>>> prim.set_angular_velocity(np.array([0.0, 0.0, 10.0]))\n```\n",
"snippet":"dynamic_sphere.set_angular_velocity(velocity=velocity)\n",
"category":"method"
},
{
"title":"set_collision_approximation",
"description":"Set the collision approximation\n\n| Approximation           | Full name            | Description                                                                               |\n|-------------------------|----------------------|-------------------------------------------------------------------------------------------|\n| `\"none\"`                | Triangle Mesh        | The mesh geometry is used directly as a collider without any approximation                |\n| `\"convexDecomposition\"` | Convex Decomposition | A convex mesh decomposition is performed. This results in a set of convex mesh colliders  |\n| `\"convexHull\"`          | Convex Hull          | A convex hull of the mesh is generated and used as the collider                           |\n| `\"boundingSphere\"`      | Bounding Sphere      | A bounding sphere is computed around the mesh and used as a collider                      |\n| `\"boundingCube\"`        | Bounding Cube        | An optimally fitting box collider is computed around the mesh                             |\n| `\"meshSimplification\"`  | Mesh Simplification  | A mesh simplification step is performed, resulting in a simplified triangle mesh collider |\n| `\"sdf\"`                 | SDF Mesh             | SDF (Signed-Distance-Field) use high-detail triangle meshes as collision shape            |\n| `\"sphereFill\"`          | Sphere Approximation | A sphere mesh decomposition is performed. This results in a set of sphere colliders       |\n\n*Warning:*\nSwitching to Convex Decomposition or SDF (Signed-Distance-Field) will have a simulation performance\nimpact due to higher computational cost\n\n**Args:**\n\n * `approximation_type` (str): approximation used for collision\n\n---\n**Example:**\n\n```python\n>>> prim.set_collision_approximation(\"convexDecomposition\")\n```\n",
"snippet":"dynamic_sphere.set_collision_approximation(approximation_type=approximation_type)\n",
"category":"method"
},
{
"title":"set_collision_enabled",
"description":"Enable/disable the Collision API\n\n**Args:**\n\n * `enabled` (bool): Whether to enable or disable the Collision API\n\n---\n**Example:**\n\n```python\n>>> # disable collisions\n>>> prim.set_collision_enabled(False)\n```\n",
"snippet":"dynamic_sphere.set_collision_enabled(enabled=enabled)\n",
"category":"method"
},
{
"title":"set_contact_offset",
"description":"Set the contact offset\n\nShapes whose distance is less than the sum of their contact offset values will generate contacts\n\nSearch for *Advanced Collision Detection* in for more details\n\n*Warning:*\nThe contact offset must be positive and greater than the rest offset\n\n**Args:**\n\n * `offset` (float): Contact offset of a collision shape. Allowed range \\[maximum(0, rest\\_offset), 0\\]. Default value is -inf, means default is picked by simulation based on the shape extent.\n\n---\n**Example:**\n\n```python\n>>> prim.set_contact_offset(0.02)\n```\n",
"snippet":"dynamic_sphere.set_contact_offset(offset=offset)\n",
"category":"method"
},
{
"title":"set_default_state",
"description":"Set the default state of the prim (position, orientation and linear and angular velocities),\nthat will be used after each reset\n\n*Note:*\nThe default states will be set during post-reset (e.g., calling `.post_reset()` or `world.reset()` methods)\n\n**Args:**\n\n * `position` (Optional\\[Sequence\\[float\\]\\], optional): position in the world frame of the prim. shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the world frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n * `linear_velocity` (np.ndarray): linear velocity to set the rigid prim to. Shape (3,).\n * `angular_velocity` (np.ndarray): angular velocity to set the rigid prim to. Shape (3,).\n\n---\n**Example:**\n\n```python\n>>> prim.set_default_state(\n...     position=np.array([1.0, 2.0, 3.0]),\n...     orientation=np.array([1.0, 0.0, 0.0, 0.0]),\n...     linear_velocity=np.array([0.0, 0.0, 0.0]),\n...     angular_velocity=np.array([0.0, 0.0, 0.0])\n... )\n>>>\n>>> prim.post_reset()\n```\n",
"snippet":"dynamic_sphere.set_default_state()\n",
"category":"method"
},
{
"title":"set_default_state",
"description":"Set the default state of the prim (position and orientation), that will be used after each reset.\n\n**Args:**\n\n * `position` (Optional\\[Sequence\\[float\\]\\], optional): position in the world frame of the prim. shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the world frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n\n---\n**Example:**\n\n```python\n>>> # configure default state\n>>> prim.set_default_state(position=np.array([1.0, 0.5, 0.0]), orientation=np.array([1, 0, 0, 0]))\n>>>\n>>> # set default states during post-reset\n>>> prim.post_reset()\n```\n",
"snippet":"dynamic_sphere.set_default_state()\n",
"category":"method"
},
{
"title":"set_density",
"description":"Set the density of the rigid body\n\n**Args:**\n\n * `mass` (float): density of the rigid body.\n\n---\n**Example:**\n\n```python\n>>> prim.set_density(0.9)\n```\n",
"snippet":"dynamic_sphere.set_density(density=density)\n",
"category":"method"
},
{
"title":"set_linear_velocity",
"description":"Set the linear velocity of the rigid body in stage\n\n*Warning:*\nThis method will immediately set the rigid prim state\n\n**Args:**\n\n * `velocity` (np.ndarray): linear velocity to set the rigid prim to. Shape (3,).\n\n*Hint:*\nThis method belongs to the methods used to set the rigid prim kinematic state:\n\n> `set_linear_velocity`, `set_angular_velocity`\n\n---\n**Example:**\n\n```python\n>>> prim.set_linear_velocity(np.array([5.0, 0.0, 0.0]))\n```\n",
"snippet":"dynamic_sphere.set_linear_velocity(velocity=velocity)\n",
"category":"method"
},
{
"title":"set_local_pose",
"description":"Set prim's pose with respect to the local frame (the prim's parent frame).\n\n*Warning:*\nThis method will change (teleport) the prim pose immediately to the indicated value\n\n**Args:**\n\n * `translation` (Optional\\[Sequence\\[float\\]\\], optional): translation in the local frame of the prim (with respect to its parent prim). shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the local frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n\n*Hint:*\nThis method belongs to the methods used to set the prim state\n\n---\n**Example:**\n\n```python\n>>> prim.set_local_pose(translation=np.array([1.0, 0.5, 0.0]), orientation=np.array([1., 0., 0., 0.]))\n```\n",
"snippet":"dynamic_sphere.set_local_pose()\n",
"category":"method"
},
{
"title":"set_local_scale",
"description":"Set prim's scale with respect to the local frame (the prim's parent frame).\n\n**Args:**\n\n * `scale` (Optional\\[Sequence\\[float\\]\\]): scale to be applied to the prim's dimensions. shape is (3, ). Defaults to None, which means left unchanged.\n\n---\n**Example:**\n\n```python\n>>> # scale prim 10 times smaller\n>>> prim.set_local_scale(np.array([0.1, 0.1, 0.1]))\n```\n",
"snippet":"dynamic_sphere.set_local_scale(scale=scale)\n",
"category":"method"
},
{
"title":"set_mass",
"description":"Set the mass of the rigid body\n\n**Args:**\n\n * `mass` (float): mass of the rigid body in kg.\n\n---\n**Example:**\n\n```python\n>>> prim.set_mass(1.0)\n```\n",
"snippet":"dynamic_sphere.set_mass(mass=mass)\n",
"category":"method"
},
{
"title":"set_min_torsional_patch_radius",
"description":"Set the minimum radius of the contact patch used to apply torsional friction\n\nSearch for *\"Torsional Patch Radius\"* in for more details\n\n**Args:**\n\n * `radius` (float): minimum radius of the contact patch used to apply torsional friction. Allowed range \\[0, max\\_float\\].\n\n---\n**Example:**\n\n```python\n>>> prim.set_min_torsional_patch_radius(0.05)\n```\n",
"snippet":"dynamic_sphere.set_min_torsional_patch_radius(radius=radius)\n",
"category":"method"
},
{
"title":"set_radius",
"description":"Set the sphere radius\n\n**Args:**\n\n * `radius` (float): sphere radius\n\n---\n**Example:**\n\n```python\n>>> prim.set_radius(2.0)\n```\n",
"snippet":"dynamic_sphere.set_radius(radius=radius)\n",
"category":"method"
},
{
"title":"set_rest_offset",
"description":"Set the rest offset\n\nTwo shapes will come to rest at a distance equal to the sum of their rest offset values.\nIf the rest offset is 0, they should converge to touching exactly\n\nSearch for *Advanced Collision Detection* in for more details\n\n*Warning:*\nThe contact offset must be positive and greater than the rest offset\n\n**Args:**\n\n * `offset` (float): Rest offset of a collision shape. Allowed range \\[-max\\_float, contact\\_offset. Default value is -inf, means default is picked by simulation. For rigid bodies its zero.\n\n---\n**Example:**\n\n```python\n>>> prim.set_rest_offset(0.01)\n```\n",
"snippet":"dynamic_sphere.set_rest_offset(offset=offset)\n",
"category":"method"
},
{
"title":"set_sleep_threshold",
"description":"Set the threshold for the rigid body to enter a sleep state\n\nSearch for *Rigid Body Dynamics* \\> *Sleeping* in for more details\n\n**Args:**\n\n * `threshold` (float): Mass-normalized kinetic energy threshold below which an actor may go to sleep. Range: \\[0, inf) Defaults: 0.00005 \\* tolerancesSpeed\\* tolerancesSpeed Units: distance\\^2 / second\\^2.\n\n---\n**Example:**\n\n```python\n>>> prim.set_sleep_threshold(1e-5)\n```\n",
"snippet":"dynamic_sphere.set_sleep_threshold(threshold=threshold)\n",
"category":"method"
},
{
"title":"set_torsional_patch_radius",
"description":"Set the radius of the contact patch used to apply torsional friction\n\nSearch for *\"Torsional Patch Radius\"* in for more details\n\n**Args:**\n\n * `radius` (float): radius of the contact patch used to apply torsional friction. Allowed range \\[0, max\\_float\\].\n\n---\n**Example:**\n\n```python\n>>> prim.set_torsional_patch_radius(0.1)\n```\n",
"snippet":"dynamic_sphere.set_torsional_patch_radius(radius=radius)\n",
"category":"method"
},
{
"title":"set_visibility",
"description":"Set the visibility of the prim in stage\n\n**Args:**\n\n * `visible` (bool): flag to set the visibility of the usd prim in stage.\n\n---\n**Example:**\n\n```python\n>>> # make prim not visible in the stage\n>>> prim.set_visibility(visible=False)\n```\n",
"snippet":"dynamic_sphere.set_visibility(visible=visible)\n",
"category":"method"
},
{
"title":"set_world_pose",
"description":"Ses prim's pose with respect to the world's frame\n\n*Warning:*\nThis method will change (teleport) the prim pose immediately to the indicated value\n\n**Args:**\n\n * `position` (Optional\\[Sequence\\[float\\]\\], optional): position in the world frame of the prim. shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the world frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n\n*Hint:*\nThis method belongs to the methods used to set the prim state\n\n---\n**Example:**\n\n```python\n>>> prim.set_world_pose(position=np.array([1.0, 0.5, 0.0]), orientation=np.array([1., 0., 0., 0.]))\n```\n",
"snippet":"dynamic_sphere.set_world_pose()\n",
"category":"method"
}
]
},
{
"title":"FixedCapsule",
"snippets":[
{
"title":"import ...",
"description":"Import class",
"snippet":"from omni.isaac.core.objects import FixedCapsule\n",
"category":"import"
},
{
"title":"FixedCapsule",
"description":"High level wrapper to create/encapsulate a fixed capsule\n\n*Note:*\nFixed capsules (Capsule shape) have collisions (Collider API) but no rigid body dynamics (Rigid Body API)\n\n**Args:**\n\n * `prim_path` (str): prim path of the Prim to encapsulate or create\n * `name` (str, optional): shortname to be used as a key by Scene class. Note: needs to be unique if the object is added to the Scene. Defaults to \"fixed\\_capsule\".\n * `position` (Optional\\[Sequence\\[float\\]\\], optional): position in the world frame of the prim. shape is (3, ). Defaults to None, which means left unchanged.\n * `translation` (Optional\\[Sequence\\[float\\]\\], optional): translation in the local frame of the prim (with respect to its parent prim). shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the world/ local frame of the prim (depends if translation or position is specified). quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n * `scale` (Optional\\[Sequence\\[float\\]\\], optional): local scale to be applied to the prim's dimensions. shape is (3, ). Defaults to None, which means left unchanged.\n * `visible` (bool, optional): set to false for an invisible prim in the stage while rendering. Defaults to True.\n * `color` (Optional\\[np.ndarray\\], optional): color of the visual shape. Defaults to None, which means 50% gray\n * `radius` (Optional\\[float\\], optional): capsule radius. Defaults to None.\n * `height` (Optional\\[float\\], optional): capsule height. Defaults to None.\n * `visual_material` (Optional\\[VisualMaterial\\], optional): visual material to be applied to the held prim. Defaults to None. If not specified, a default visual material will be added.\n * `physics_material` (Optional\\[PhysicsMaterial\\], optional): physics material to be applied to the held prim. Defaults to None. If not specified, a default physics material will be added.\n\n---\n**Example:**\n\n```python\n>>> from omni.isaac.core.objects import FixedCapsule\n>>> import numpy as np\n>>>\n>>> # create a red fixed capsule at the given path\n>>> prim = FixedCapsule(\n...     prim_path=\"/World/Xform/Capsule\",\n...     radius=0.5,\n...     height=1.0,\n...     color=np.array([1.0, 0.0, 0.0])\n... )\n>>> print(prim)\n<omni.isaac.core.objects.capsule.FixedCapsule object at 0x7f520c0d4790>\n```\n",
"snippet":"fixed_capsule = FixedCapsule(prim_path=prim_path)\n",
"category":"class"
},
{
"title":"apply_physics_material",
"description":"Used to apply physics material to the held prim and optionally its descendants.\n\n**Args:**\n\n * `physics_material` (PhysicsMaterial): physics material to be applied to the held prim. This where you want to define friction, restitution..etc. Note: if a physics material is not defined, the defaults will be used from PhysX.\n * `weaker_than_descendants` (bool, optional): True if the material shouldn't override the descendants materials, otherwise False. Defaults to False.\n\n---\n**Example:**\n\n```python\n>>> from omni.isaac.core.materials import PhysicsMaterial\n>>>\n>>> # create a rigid body physical material\n>>> material = PhysicsMaterial(\n...     prim_path=\"/World/physics_material/aluminum\",  # path to the material prim to create\n...     dynamic_friction=0.4,\n...     static_friction=1.1,\n...     restitution=0.1\n... )\n>>> prim.apply_physics_material(material)\n```\n",
"snippet":"fixed_capsule.apply_physics_material(physics_material=physics_material)\n",
"category":"method"
},
{
"title":"apply_visual_material",
"description":"Apply visual material to the held prim and optionally its descendants.\n\n**Args:**\n\n * `visual_material` (VisualMaterial): visual material to be applied to the held prim. Currently supports PreviewSurface, OmniPBR and OmniGlass.\n * `weaker_than_descendants` (bool, optional): True if the material shouldn't override the descendants materials, otherwise False. Defaults to False.\n\n---\n**Example:**\n\n```python\n>>> from omni.isaac.core.materials import OmniGlass\n>>>\n>>> # create a dark-red glass visual material\n>>> material = OmniGlass(\n...     prim_path=\"/World/material/glass\",  # path to the material prim to create\n...     ior=1.25,\n...     depth=0.001,\n...     thin_walled=False,\n...     color=np.array([0.5, 0.0, 0.0])\n... )\n>>> prim.apply_visual_material(material)\n```\n",
"snippet":"fixed_capsule.apply_visual_material(visual_material=visual_material)\n",
"category":"method"
},
{
"title":"get_applied_physics_material",
"description":"Return the current applied physics material in case it was applied using apply\\_physics\\_material or not.\n\n**Returns:**\n\n * PhysicsMaterial: the current applied physics material.\n\n---\n**Example:**\n\n```python\n>>> # given a physics material applied\n>>> prim.get_applied_physics_material()\n<omni.isaac.core.materials.physics_material.PhysicsMaterial object at 0x7fb66c30cd30>\n```\n",
"snippet":"applied_physics_material = fixed_capsule.get_applied_physics_material()\n",
"category":"method"
},
{
"title":"get_applied_visual_material",
"description":"Return the current applied visual material in case it was applied using apply\\_visual\\_material\nor it's one of the following materials that was already applied before: PreviewSurface, OmniPBR and OmniGlass.\n\n**Returns:**\n\n * VisualMaterial: the current applied visual material if its type is currently supported.\n\n---\n**Example:**\n\n```python\n>>> # given a visual material applied\n>>> prim.get_applied_visual_material()\n<omni.isaac.core.materials.omni_glass.OmniGlass object at 0x7f36263106a0>\n```\n",
"snippet":"applied_visual_material = fixed_capsule.get_applied_visual_material()\n",
"category":"method"
},
{
"title":"get_collision_approximation",
"description":"Get the collision approximation\n\n| Approximation           | Full name            | Description                                                                               |\n|-------------------------|----------------------|-------------------------------------------------------------------------------------------|\n| `\"none\"`                | Triangle Mesh        | The mesh geometry is used directly as a collider without any approximation                |\n| `\"convexDecomposition\"` | Convex Decomposition | A convex mesh decomposition is performed. This results in a set of convex mesh colliders  |\n| `\"convexHull\"`          | Convex Hull          | A convex hull of the mesh is generated and used as the collider                           |\n| `\"boundingSphere\"`      | Bounding Sphere      | A bounding sphere is computed around the mesh and used as a collider                      |\n| `\"boundingCube\"`        | Bounding Cube        | An optimally fitting box collider is computed around the mesh                             |\n| `\"meshSimplification\"`  | Mesh Simplification  | A mesh simplification step is performed, resulting in a simplified triangle mesh collider |\n| `\"sdf\"`                 | SDF Mesh             | SDF (Signed-Distance-Field) use high-detail triangle meshes as collision shape            |\n| `\"sphereFill\"`          | Sphere Approximation | A sphere mesh decomposition is performed. This results in a set of sphere colliders       |\n\n**Returns:**\n\n * str: approximation used for collision\n\n---\n**Example:**\n\n```python\n>>> prim.get_collision_approximation()\nnone\n```\n",
"snippet":"collision_approximation = fixed_capsule.get_collision_approximation()\n",
"category":"method"
},
{
"title":"get_collision_enabled",
"description":"Check if the Collision API is enabled\n\n**Returns:**\n\n * bool: True if the Collision API is enabled. Otherwise False\n\n---\n**Example:**\n\n```python\n>>> prim.get_collision_enabled()\nTrue\n```\n",
"snippet":"collision_enabled = fixed_capsule.get_collision_enabled()\n",
"category":"method"
},
{
"title":"get_contact_force_matrix",
"description":"If the object is initialized with filter\\_paths\\_expr list, this method returns the contact forces between the prims\nin the view and the filter prims. i.e., a matrix of dimension (self.\\_contact\\_view.num\\_filters, 3)\nwhere num\\_filters is the determined according to the filter\\_paths\\_expr parameter.\n\n**Args:**\n\n * `dt` (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor\\]: Net contact forces of the prims with shape (self.\\_geometry\\_prim\\_view.\\_contact\\_view.num\\_filters, 3).\n",
"snippet":"contact_force_matrix = fixed_capsule.get_contact_force_matrix()\n",
"category":"method"
},
{
"title":"get_contact_offset",
"description":"Get the contact offset\n\nShapes whose distance is less than the sum of their contact offset values will generate contacts\n\nSearch for *Advanced Collision Detection* in for more details\n\n**Returns:**\n\n * float: contact offset of the collision shape. Default value is -inf, means default is picked by simulation.\n\n---\n**Example:**\n\n```python\n>>> prim.get_contact_offset()\n-inf\n```\n",
"snippet":"contact_offset = fixed_capsule.get_contact_offset()\n",
"category":"method"
},
{
"title":"get_default_state",
"description":"Get the default prim states (spatial position and orientation).\n\n**Returns:**\n\n * XFormPrimState: an object that contains the default state of the prim (position and orientation)\n\n---\n**Example:**\n\n```python\n>>> state = prim.get_default_state()\n>>> state\n<omni.isaac.core.utils.types.XFormPrimState object at 0x7f33addda650>\n>>>\n>>> state.position\n[-4.5299529e-08 -1.8347054e-09 -2.8610229e-08]\n>>> state.orientation\n[1. 0. 0. 0.]\n```\n",
"snippet":"default_state = fixed_capsule.get_default_state()\n",
"category":"method"
},
{
"title":"get_height",
"description":"Get the capsule height\n\n**Returns:**\n\n * float: capsule height\n\n---\n**Example:**\n\n```python\n>>> prim.get_height()\n1.0\n```\n",
"snippet":"height = fixed_capsule.get_height()\n",
"category":"method"
},
{
"title":"get_local_pose",
"description":"Get prim's pose with respect to the local frame (the prim's parent frame)\n\n**Returns:**\n\n * Tuple\\[np.ndarray, np.ndarray\\]: first index is the position in the local frame (with shape (3, )).\n    Second index is quaternion orientation (with shape (4, )) in the local frame\n\n---\n**Example:**\n\n```python\n>>> # if the prim is in position (1.0, 0.5, 0.0) with respect to the world frame\n>>> position, orientation = prim.get_local_pose()\n>>> position\n[0. 0. 0.]\n>>> orientation\n[0. 0. 0.]\n```\n",
"snippet":"local_pose = fixed_capsule.get_local_pose()\n",
"category":"method"
},
{
"title":"get_local_scale",
"description":"Get prim's scale with respect to the local frame (the parent's frame)\n\n**Returns:**\n\n * np.ndarray: scale applied to the prim's dimensions in the local frame. shape is (3, ).\n\n---\n**Example:**\n\n```python\n>>> prim.get_local_scale()\n[1. 1. 1.]\n```\n",
"snippet":"local_scale = fixed_capsule.get_local_scale()\n",
"category":"method"
},
{
"title":"get_min_torsional_patch_radius",
"description":"Get the minimum radius of the contact patch used to apply torsional friction\n\nSearch for *\"Torsional Patch Radius\"* in for more details\n\n**Returns:**\n\n * float: minimum radius of the contact patch used to apply torsional friction. Allowed range \\[0, max\\_float\\].\n\n---\n**Example:**\n\n```python\n>>> prim.get_min_torsional_patch_radius()\n0.0\n```\n",
"snippet":"min_torsional_patch_radius = fixed_capsule.get_min_torsional_patch_radius()\n",
"category":"method"
},
{
"title":"get_net_contact_forces",
"description":"If contact forces of the prims in the view are tracked, this method returns the net contact forces on prims.\ni.e., a matrix of dimension (1, 3)\n\n**Args:**\n\n * `dt` (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor\\]: Net contact forces of the prims with shape (3).\n",
"snippet":"net_contact_forces = fixed_capsule.get_net_contact_forces()\n",
"category":"method"
},
{
"title":"get_radius",
"description":"Get the capsule radius\n\n**Returns:**\n\n * float: capsule radius\n\n---\n**Example:**\n\n```python\n>>> prim.get_radius()\n0.5\n```\n",
"snippet":"radius = fixed_capsule.get_radius()\n",
"category":"method"
},
{
"title":"get_rest_offset",
"description":"Get the rest offset\n\nTwo shapes will come to rest at a distance equal to the sum of their rest offset values.\nIf the rest offset is 0, they should converge to touching exactly\n\nSearch for *Advanced Collision Detection* in for more details\n\n**Returns:**\n\n * float: rest offset of the collision shape.\n\n---\n**Example:**\n\n```python\n>>> prim.get_rest_offset()\n-inf\n```\n",
"snippet":"rest_offset = fixed_capsule.get_rest_offset()\n",
"category":"method"
},
{
"title":"get_torsional_patch_radius",
"description":"Get the radius of the contact patch used to apply torsional friction\n\nSearch for *\"Torsional Patch Radius\"* in for more details\n\n**Returns:**\n\n * float: radius of the contact patch used to apply torsional friction. Allowed range \\[0, max\\_float\\].\n\n---\n**Example:**\n\n```python\n>>> prim.get_torsional_patch_radius()\n0.0\n```\n",
"snippet":"torsional_patch_radius = fixed_capsule.get_torsional_patch_radius()\n",
"category":"method"
},
{
"title":"get_visibility",
"description":"**Returns:**\n\n * bool: true if the prim is visible in stage. false otherwise.\n\n---\n**Example:**\n\n```python\n>>> # get the visible state of an visible prim on the stage\n>>> prim.get_visibility()\nTrue\n```\n",
"snippet":"visibility = fixed_capsule.get_visibility()\n",
"category":"method"
},
{
"title":"get_world_pose",
"description":"Get prim's pose with respect to the world's frame\n\n**Returns:**\n\n * Tuple\\[np.ndarray, np.ndarray\\]: first index is the position in the world frame (with shape (3, )).\n    Second index is quaternion orientation (with shape (4, )) in the world frame\n\n---\n**Example:**\n\n```python\n>>> # if the prim is in position (1.0, 0.5, 0.0) with respect to the world frame\n>>> position, orientation = prim.get_world_pose()\n>>> position\n[1.  0.5 0. ]\n>>> orientation\n[1. 0. 0. 0.]\n```\n",
"snippet":"world_pose = fixed_capsule.get_world_pose()\n",
"category":"method"
},
{
"title":"get_world_scale",
"description":"Get prim's scale with respect to the world's frame\n\n**Returns:**\n\n * np.ndarray: scale applied to the prim's dimensions in the world frame. shape is (3, ).\n\n---\n**Example:**\n\n```python\n>>> prim.get_world_scale()\n[1. 1. 1.]\n```\n",
"snippet":"world_scale = fixed_capsule.get_world_scale()\n",
"category":"method"
},
{
"title":"initialize",
"description":"Create a physics simulation view if not passed and using PhysX tensor API\n\n*Note:*\nIf the prim has been added to the world scene (e.g., `world.scene.add(prim)`),\nit will be automatically initialized when the world is reset (e.g., `world.reset()`).\n\n**Args:**\n\n * `physics_sim_view` (omni.physics.tensors.SimulationView, optional): current physics simulation view. Defaults to None.\n\n---\n**Example:**\n\n```python\n>>> prim.initialize()\n```\n",
"snippet":"fixed_capsule.initialize()\n",
"category":"method"
},
{
"title":"is_valid",
"description":"Check if the prim path has a valid USD Prim at it\n\n**Returns:**\n\n * bool: True is the current prim path corresponds to a valid prim in stage. False otherwise.\n\n---\n**Example:**\n\n```python\n>>> # given an existing and valid prim\n>>> prims.is_valid()\nTrue\n```\n",
"snippet":"value = fixed_capsule.is_valid()\n",
"category":"method"
},
{
"title":"is_visual_material_applied",
"description":"Check if there is a visual material applied\n\n**Returns:**\n\n * bool: True if there is a visual material applied. False otherwise.\n\n---\n**Example:**\n\n```python\n>>> # given a visual material applied\n>>> prim.is_visual_material_applied()\nTrue\n```\n",
"snippet":"value = fixed_capsule.is_visual_material_applied()\n",
"category":"method"
},
{
"title":"post_reset",
"description":"Reset the prim to its default state (position and orientation).\n\n*Note:*\nFor an articulation, in addition to configuring the root prim's default position and spatial orientation\n(defined via the `set_default_state` method), the joint's positions, velocities, and efforts\n(defined via the `set_joints_default_state` method) are imposed\n\n---\n**Example:**\n\n```python\n>>> prim.post_reset()\n```\n",
"snippet":"fixed_capsule.post_reset()\n",
"category":"method"
},
{
"title":"set_collision_approximation",
"description":"Set the collision approximation\n\n| Approximation           | Full name            | Description                                                                               |\n|-------------------------|----------------------|-------------------------------------------------------------------------------------------|\n| `\"none\"`                | Triangle Mesh        | The mesh geometry is used directly as a collider without any approximation                |\n| `\"convexDecomposition\"` | Convex Decomposition | A convex mesh decomposition is performed. This results in a set of convex mesh colliders  |\n| `\"convexHull\"`          | Convex Hull          | A convex hull of the mesh is generated and used as the collider                           |\n| `\"boundingSphere\"`      | Bounding Sphere      | A bounding sphere is computed around the mesh and used as a collider                      |\n| `\"boundingCube\"`        | Bounding Cube        | An optimally fitting box collider is computed around the mesh                             |\n| `\"meshSimplification\"`  | Mesh Simplification  | A mesh simplification step is performed, resulting in a simplified triangle mesh collider |\n| `\"sdf\"`                 | SDF Mesh             | SDF (Signed-Distance-Field) use high-detail triangle meshes as collision shape            |\n| `\"sphereFill\"`          | Sphere Approximation | A sphere mesh decomposition is performed. This results in a set of sphere colliders       |\n\n*Warning:*\nSwitching to Convex Decomposition or SDF (Signed-Distance-Field) will have a simulation performance\nimpact due to higher computational cost\n\n**Args:**\n\n * `approximation_type` (str): approximation used for collision\n\n---\n**Example:**\n\n```python\n>>> prim.set_collision_approximation(\"convexDecomposition\")\n```\n",
"snippet":"fixed_capsule.set_collision_approximation(approximation_type=approximation_type)\n",
"category":"method"
},
{
"title":"set_collision_enabled",
"description":"Enable/disable the Collision API\n\n**Args:**\n\n * `enabled` (bool): Whether to enable or disable the Collision API\n\n---\n**Example:**\n\n```python\n>>> # disable collisions\n>>> prim.set_collision_enabled(False)\n```\n",
"snippet":"fixed_capsule.set_collision_enabled(enabled=enabled)\n",
"category":"method"
},
{
"title":"set_contact_offset",
"description":"Set the contact offset\n\nShapes whose distance is less than the sum of their contact offset values will generate contacts\n\nSearch for *Advanced Collision Detection* in for more details\n\n*Warning:*\nThe contact offset must be positive and greater than the rest offset\n\n**Args:**\n\n * `offset` (float): Contact offset of a collision shape. Allowed range \\[maximum(0, rest\\_offset), 0\\]. Default value is -inf, means default is picked by simulation based on the shape extent.\n\n---\n**Example:**\n\n```python\n>>> prim.set_contact_offset(0.02)\n```\n",
"snippet":"fixed_capsule.set_contact_offset(offset=offset)\n",
"category":"method"
},
{
"title":"set_default_state",
"description":"Set the default state of the prim (position and orientation), that will be used after each reset.\n\n**Args:**\n\n * `position` (Optional\\[Sequence\\[float\\]\\], optional): position in the world frame of the prim. shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the world frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n\n---\n**Example:**\n\n```python\n>>> # configure default state\n>>> prim.set_default_state(position=np.array([1.0, 0.5, 0.0]), orientation=np.array([1, 0, 0, 0]))\n>>>\n>>> # set default states during post-reset\n>>> prim.post_reset()\n```\n",
"snippet":"fixed_capsule.set_default_state()\n",
"category":"method"
},
{
"title":"set_height",
"description":"Set the capsule height\n\n**Args:**\n\n * `height` (float): capsule height\n\n---\n**Example:**\n\n```python\n>>> prim.set_height(2.0)\n```\n",
"snippet":"fixed_capsule.set_height(height=height)\n",
"category":"method"
},
{
"title":"set_local_pose",
"description":"Set prim's pose with respect to the local frame (the prim's parent frame).\n\n*Warning:*\nThis method will change (teleport) the prim pose immediately to the indicated value\n\n**Args:**\n\n * `translation` (Optional\\[Sequence\\[float\\]\\], optional): translation in the local frame of the prim (with respect to its parent prim). shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the local frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n\n*Hint:*\nThis method belongs to the methods used to set the prim state\n\n---\n**Example:**\n\n```python\n>>> prim.set_local_pose(translation=np.array([1.0, 0.5, 0.0]), orientation=np.array([1., 0., 0., 0.]))\n```\n",
"snippet":"fixed_capsule.set_local_pose()\n",
"category":"method"
},
{
"title":"set_local_scale",
"description":"Set prim's scale with respect to the local frame (the prim's parent frame).\n\n**Args:**\n\n * `scale` (Optional\\[Sequence\\[float\\]\\]): scale to be applied to the prim's dimensions. shape is (3, ). Defaults to None, which means left unchanged.\n\n---\n**Example:**\n\n```python\n>>> # scale prim 10 times smaller\n>>> prim.set_local_scale(np.array([0.1, 0.1, 0.1]))\n```\n",
"snippet":"fixed_capsule.set_local_scale(scale=scale)\n",
"category":"method"
},
{
"title":"set_min_torsional_patch_radius",
"description":"Set the minimum radius of the contact patch used to apply torsional friction\n\nSearch for *\"Torsional Patch Radius\"* in for more details\n\n**Args:**\n\n * `radius` (float): minimum radius of the contact patch used to apply torsional friction. Allowed range \\[0, max\\_float\\].\n\n---\n**Example:**\n\n```python\n>>> prim.set_min_torsional_patch_radius(0.05)\n```\n",
"snippet":"fixed_capsule.set_min_torsional_patch_radius(radius=radius)\n",
"category":"method"
},
{
"title":"set_radius",
"description":"Set the capsule radius\n\n**Args:**\n\n * `radius` (float): capsule radius\n\n---\n**Example:**\n\n```python\n>>> prim.set_radius(1.0)\n```\n",
"snippet":"fixed_capsule.set_radius(radius=radius)\n",
"category":"method"
},
{
"title":"set_rest_offset",
"description":"Set the rest offset\n\nTwo shapes will come to rest at a distance equal to the sum of their rest offset values.\nIf the rest offset is 0, they should converge to touching exactly\n\nSearch for *Advanced Collision Detection* in for more details\n\n*Warning:*\nThe contact offset must be positive and greater than the rest offset\n\n**Args:**\n\n * `offset` (float): Rest offset of a collision shape. Allowed range \\[-max\\_float, contact\\_offset. Default value is -inf, means default is picked by simulation. For rigid bodies its zero.\n\n---\n**Example:**\n\n```python\n>>> prim.set_rest_offset(0.01)\n```\n",
"snippet":"fixed_capsule.set_rest_offset(offset=offset)\n",
"category":"method"
},
{
"title":"set_torsional_patch_radius",
"description":"Set the radius of the contact patch used to apply torsional friction\n\nSearch for *\"Torsional Patch Radius\"* in for more details\n\n**Args:**\n\n * `radius` (float): radius of the contact patch used to apply torsional friction. Allowed range \\[0, max\\_float\\].\n\n---\n**Example:**\n\n```python\n>>> prim.set_torsional_patch_radius(0.1)\n```\n",
"snippet":"fixed_capsule.set_torsional_patch_radius(radius=radius)\n",
"category":"method"
},
{
"title":"set_visibility",
"description":"Set the visibility of the prim in stage\n\n**Args:**\n\n * `visible` (bool): flag to set the visibility of the usd prim in stage.\n\n---\n**Example:**\n\n```python\n>>> # make prim not visible in the stage\n>>> prim.set_visibility(visible=False)\n```\n",
"snippet":"fixed_capsule.set_visibility(visible=visible)\n",
"category":"method"
},
{
"title":"set_world_pose",
"description":"Ses prim's pose with respect to the world's frame\n\n*Warning:*\nThis method will change (teleport) the prim pose immediately to the indicated value\n\n**Args:**\n\n * `position` (Optional\\[Sequence\\[float\\]\\], optional): position in the world frame of the prim. shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the world frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n\n*Hint:*\nThis method belongs to the methods used to set the prim state\n\n---\n**Example:**\n\n```python\n>>> prim.set_world_pose(position=np.array([1.0, 0.5, 0.0]), orientation=np.array([1., 0., 0., 0.]))\n```\n",
"snippet":"fixed_capsule.set_world_pose()\n",
"category":"method"
}
]
},
{
"title":"FixedCone",
"snippets":[
{
"title":"import ...",
"description":"Import class",
"snippet":"from omni.isaac.core.objects import FixedCone\n",
"category":"import"
},
{
"title":"FixedCone",
"description":"High level wrapper to create/encapsulate a fixed cone\n\n*Note:*\nFixed cones (Cone shape) have collisions (Collider API) but no rigid body dynamics (Rigid Body API)\n\n**Args:**\n\n * `prim_path` (str): prim path of the Prim to encapsulate or create\n * `name` (str, optional): shortname to be used as a key by Scene class. Note: needs to be unique if the object is added to the Scene. Defaults to \"fixed\\_cone\".\n * `position` (Optional\\[Sequence\\[float\\]\\], optional): position in the world frame of the prim. shape is (3, ). Defaults to None, which means left unchanged.\n * `translation` (Optional\\[Sequence\\[float\\]\\], optional): translation in the local frame of the prim (with respect to its parent prim). shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the world/ local frame of the prim (depends if translation or position is specified). quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n * `scale` (Optional\\[Sequence\\[float\\]\\], optional): local scale to be applied to the prim's dimensions. shape is (3, ). Defaults to None, which means left unchanged.\n * `visible` (bool, optional): set to false for an invisible prim in the stage while rendering. Defaults to True.\n * `color` (Optional\\[np.ndarray\\], optional): color of the visual shape. Defaults to None, which means 50% gray\n * `radius` (Optional\\[float\\], optional): base radius. Defaults to None.\n * `height` (Optional\\[float\\], optional): cone height. Defaults to None.\n * `visual_material` (Optional\\[VisualMaterial\\], optional): visual material to be applied to the held prim. Defaults to None. If not specified, a default visual material will be added.\n * `physics_material` (Optional\\[PhysicsMaterial\\], optional): physics material to be applied to the held prim. Defaults to None. If not specified, a default physics material will be added.\n\n---\n**Example:**\n\n```python\n>>> from omni.isaac.core.objects import FixedCone\n>>> import numpy as np\n>>>\n>>> # create a red fixed cone at the given path\n>>> prim = FixedCone(\n...     prim_path=\"/World/Xform/Cone\",\n...     radius=0.5,\n...     height=1.0,\n...     color=np.array([1.0, 0.0, 0.0])\n... )\n>>> prim\n<omni.isaac.core.objects.cone.FixedCone object at 0x7f51489f09a0>\n```\n",
"snippet":"fixed_cone = FixedCone(prim_path=prim_path)\n",
"category":"class"
},
{
"title":"apply_physics_material",
"description":"Used to apply physics material to the held prim and optionally its descendants.\n\n**Args:**\n\n * `physics_material` (PhysicsMaterial): physics material to be applied to the held prim. This where you want to define friction, restitution..etc. Note: if a physics material is not defined, the defaults will be used from PhysX.\n * `weaker_than_descendants` (bool, optional): True if the material shouldn't override the descendants materials, otherwise False. Defaults to False.\n\n---\n**Example:**\n\n```python\n>>> from omni.isaac.core.materials import PhysicsMaterial\n>>>\n>>> # create a rigid body physical material\n>>> material = PhysicsMaterial(\n...     prim_path=\"/World/physics_material/aluminum\",  # path to the material prim to create\n...     dynamic_friction=0.4,\n...     static_friction=1.1,\n...     restitution=0.1\n... )\n>>> prim.apply_physics_material(material)\n```\n",
"snippet":"fixed_cone.apply_physics_material(physics_material=physics_material)\n",
"category":"method"
},
{
"title":"apply_visual_material",
"description":"Apply visual material to the held prim and optionally its descendants.\n\n**Args:**\n\n * `visual_material` (VisualMaterial): visual material to be applied to the held prim. Currently supports PreviewSurface, OmniPBR and OmniGlass.\n * `weaker_than_descendants` (bool, optional): True if the material shouldn't override the descendants materials, otherwise False. Defaults to False.\n\n---\n**Example:**\n\n```python\n>>> from omni.isaac.core.materials import OmniGlass\n>>>\n>>> # create a dark-red glass visual material\n>>> material = OmniGlass(\n...     prim_path=\"/World/material/glass\",  # path to the material prim to create\n...     ior=1.25,\n...     depth=0.001,\n...     thin_walled=False,\n...     color=np.array([0.5, 0.0, 0.0])\n... )\n>>> prim.apply_visual_material(material)\n```\n",
"snippet":"fixed_cone.apply_visual_material(visual_material=visual_material)\n",
"category":"method"
},
{
"title":"get_applied_physics_material",
"description":"Return the current applied physics material in case it was applied using apply\\_physics\\_material or not.\n\n**Returns:**\n\n * PhysicsMaterial: the current applied physics material.\n\n---\n**Example:**\n\n```python\n>>> # given a physics material applied\n>>> prim.get_applied_physics_material()\n<omni.isaac.core.materials.physics_material.PhysicsMaterial object at 0x7fb66c30cd30>\n```\n",
"snippet":"applied_physics_material = fixed_cone.get_applied_physics_material()\n",
"category":"method"
},
{
"title":"get_applied_visual_material",
"description":"Return the current applied visual material in case it was applied using apply\\_visual\\_material\nor it's one of the following materials that was already applied before: PreviewSurface, OmniPBR and OmniGlass.\n\n**Returns:**\n\n * VisualMaterial: the current applied visual material if its type is currently supported.\n\n---\n**Example:**\n\n```python\n>>> # given a visual material applied\n>>> prim.get_applied_visual_material()\n<omni.isaac.core.materials.omni_glass.OmniGlass object at 0x7f36263106a0>\n```\n",
"snippet":"applied_visual_material = fixed_cone.get_applied_visual_material()\n",
"category":"method"
},
{
"title":"get_collision_approximation",
"description":"Get the collision approximation\n\n| Approximation           | Full name            | Description                                                                               |\n|-------------------------|----------------------|-------------------------------------------------------------------------------------------|\n| `\"none\"`                | Triangle Mesh        | The mesh geometry is used directly as a collider without any approximation                |\n| `\"convexDecomposition\"` | Convex Decomposition | A convex mesh decomposition is performed. This results in a set of convex mesh colliders  |\n| `\"convexHull\"`          | Convex Hull          | A convex hull of the mesh is generated and used as the collider                           |\n| `\"boundingSphere\"`      | Bounding Sphere      | A bounding sphere is computed around the mesh and used as a collider                      |\n| `\"boundingCube\"`        | Bounding Cube        | An optimally fitting box collider is computed around the mesh                             |\n| `\"meshSimplification\"`  | Mesh Simplification  | A mesh simplification step is performed, resulting in a simplified triangle mesh collider |\n| `\"sdf\"`                 | SDF Mesh             | SDF (Signed-Distance-Field) use high-detail triangle meshes as collision shape            |\n| `\"sphereFill\"`          | Sphere Approximation | A sphere mesh decomposition is performed. This results in a set of sphere colliders       |\n\n**Returns:**\n\n * str: approximation used for collision\n\n---\n**Example:**\n\n```python\n>>> prim.get_collision_approximation()\nnone\n```\n",
"snippet":"collision_approximation = fixed_cone.get_collision_approximation()\n",
"category":"method"
},
{
"title":"get_collision_enabled",
"description":"Check if the Collision API is enabled\n\n**Returns:**\n\n * bool: True if the Collision API is enabled. Otherwise False\n\n---\n**Example:**\n\n```python\n>>> prim.get_collision_enabled()\nTrue\n```\n",
"snippet":"collision_enabled = fixed_cone.get_collision_enabled()\n",
"category":"method"
},
{
"title":"get_contact_force_matrix",
"description":"If the object is initialized with filter\\_paths\\_expr list, this method returns the contact forces between the prims\nin the view and the filter prims. i.e., a matrix of dimension (self.\\_contact\\_view.num\\_filters, 3)\nwhere num\\_filters is the determined according to the filter\\_paths\\_expr parameter.\n\n**Args:**\n\n * `dt` (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor\\]: Net contact forces of the prims with shape (self.\\_geometry\\_prim\\_view.\\_contact\\_view.num\\_filters, 3).\n",
"snippet":"contact_force_matrix = fixed_cone.get_contact_force_matrix()\n",
"category":"method"
},
{
"title":"get_contact_offset",
"description":"Get the contact offset\n\nShapes whose distance is less than the sum of their contact offset values will generate contacts\n\nSearch for *Advanced Collision Detection* in for more details\n\n**Returns:**\n\n * float: contact offset of the collision shape. Default value is -inf, means default is picked by simulation.\n\n---\n**Example:**\n\n```python\n>>> prim.get_contact_offset()\n-inf\n```\n",
"snippet":"contact_offset = fixed_cone.get_contact_offset()\n",
"category":"method"
},
{
"title":"get_default_state",
"description":"Get the default prim states (spatial position and orientation).\n\n**Returns:**\n\n * XFormPrimState: an object that contains the default state of the prim (position and orientation)\n\n---\n**Example:**\n\n```python\n>>> state = prim.get_default_state()\n>>> state\n<omni.isaac.core.utils.types.XFormPrimState object at 0x7f33addda650>\n>>>\n>>> state.position\n[-4.5299529e-08 -1.8347054e-09 -2.8610229e-08]\n>>> state.orientation\n[1. 0. 0. 0.]\n```\n",
"snippet":"default_state = fixed_cone.get_default_state()\n",
"category":"method"
},
{
"title":"get_height",
"description":"Get the cone height\n\n**Returns:**\n\n * float: cone height\n\n---\n**Example:**\n\n```python\n>>> prim.get_height()\n1.0\n```\n",
"snippet":"height = fixed_cone.get_height()\n",
"category":"method"
},
{
"title":"get_local_pose",
"description":"Get prim's pose with respect to the local frame (the prim's parent frame)\n\n**Returns:**\n\n * Tuple\\[np.ndarray, np.ndarray\\]: first index is the position in the local frame (with shape (3, )).\n    Second index is quaternion orientation (with shape (4, )) in the local frame\n\n---\n**Example:**\n\n```python\n>>> # if the prim is in position (1.0, 0.5, 0.0) with respect to the world frame\n>>> position, orientation = prim.get_local_pose()\n>>> position\n[0. 0. 0.]\n>>> orientation\n[0. 0. 0.]\n```\n",
"snippet":"local_pose = fixed_cone.get_local_pose()\n",
"category":"method"
},
{
"title":"get_local_scale",
"description":"Get prim's scale with respect to the local frame (the parent's frame)\n\n**Returns:**\n\n * np.ndarray: scale applied to the prim's dimensions in the local frame. shape is (3, ).\n\n---\n**Example:**\n\n```python\n>>> prim.get_local_scale()\n[1. 1. 1.]\n```\n",
"snippet":"local_scale = fixed_cone.get_local_scale()\n",
"category":"method"
},
{
"title":"get_min_torsional_patch_radius",
"description":"Get the minimum radius of the contact patch used to apply torsional friction\n\nSearch for *\"Torsional Patch Radius\"* in for more details\n\n**Returns:**\n\n * float: minimum radius of the contact patch used to apply torsional friction. Allowed range \\[0, max\\_float\\].\n\n---\n**Example:**\n\n```python\n>>> prim.get_min_torsional_patch_radius()\n0.0\n```\n",
"snippet":"min_torsional_patch_radius = fixed_cone.get_min_torsional_patch_radius()\n",
"category":"method"
},
{
"title":"get_net_contact_forces",
"description":"If contact forces of the prims in the view are tracked, this method returns the net contact forces on prims.\ni.e., a matrix of dimension (1, 3)\n\n**Args:**\n\n * `dt` (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor\\]: Net contact forces of the prims with shape (3).\n",
"snippet":"net_contact_forces = fixed_cone.get_net_contact_forces()\n",
"category":"method"
},
{
"title":"get_radius",
"description":"Get the base radius\n\n**Returns:**\n\n * float: base radius\n\n---\n**Example:**\n\n```python\n>>> prim.get_radius()\n0.5\n```\n",
"snippet":"radius = fixed_cone.get_radius()\n",
"category":"method"
},
{
"title":"get_rest_offset",
"description":"Get the rest offset\n\nTwo shapes will come to rest at a distance equal to the sum of their rest offset values.\nIf the rest offset is 0, they should converge to touching exactly\n\nSearch for *Advanced Collision Detection* in for more details\n\n**Returns:**\n\n * float: rest offset of the collision shape.\n\n---\n**Example:**\n\n```python\n>>> prim.get_rest_offset()\n-inf\n```\n",
"snippet":"rest_offset = fixed_cone.get_rest_offset()\n",
"category":"method"
},
{
"title":"get_torsional_patch_radius",
"description":"Get the radius of the contact patch used to apply torsional friction\n\nSearch for *\"Torsional Patch Radius\"* in for more details\n\n**Returns:**\n\n * float: radius of the contact patch used to apply torsional friction. Allowed range \\[0, max\\_float\\].\n\n---\n**Example:**\n\n```python\n>>> prim.get_torsional_patch_radius()\n0.0\n```\n",
"snippet":"torsional_patch_radius = fixed_cone.get_torsional_patch_radius()\n",
"category":"method"
},
{
"title":"get_visibility",
"description":"**Returns:**\n\n * bool: true if the prim is visible in stage. false otherwise.\n\n---\n**Example:**\n\n```python\n>>> # get the visible state of an visible prim on the stage\n>>> prim.get_visibility()\nTrue\n```\n",
"snippet":"visibility = fixed_cone.get_visibility()\n",
"category":"method"
},
{
"title":"get_world_pose",
"description":"Get prim's pose with respect to the world's frame\n\n**Returns:**\n\n * Tuple\\[np.ndarray, np.ndarray\\]: first index is the position in the world frame (with shape (3, )).\n    Second index is quaternion orientation (with shape (4, )) in the world frame\n\n---\n**Example:**\n\n```python\n>>> # if the prim is in position (1.0, 0.5, 0.0) with respect to the world frame\n>>> position, orientation = prim.get_world_pose()\n>>> position\n[1.  0.5 0. ]\n>>> orientation\n[1. 0. 0. 0.]\n```\n",
"snippet":"world_pose = fixed_cone.get_world_pose()\n",
"category":"method"
},
{
"title":"get_world_scale",
"description":"Get prim's scale with respect to the world's frame\n\n**Returns:**\n\n * np.ndarray: scale applied to the prim's dimensions in the world frame. shape is (3, ).\n\n---\n**Example:**\n\n```python\n>>> prim.get_world_scale()\n[1. 1. 1.]\n```\n",
"snippet":"world_scale = fixed_cone.get_world_scale()\n",
"category":"method"
},
{
"title":"initialize",
"description":"Create a physics simulation view if not passed and using PhysX tensor API\n\n*Note:*\nIf the prim has been added to the world scene (e.g., `world.scene.add(prim)`),\nit will be automatically initialized when the world is reset (e.g., `world.reset()`).\n\n**Args:**\n\n * `physics_sim_view` (omni.physics.tensors.SimulationView, optional): current physics simulation view. Defaults to None.\n\n---\n**Example:**\n\n```python\n>>> prim.initialize()\n```\n",
"snippet":"fixed_cone.initialize()\n",
"category":"method"
},
{
"title":"is_valid",
"description":"Check if the prim path has a valid USD Prim at it\n\n**Returns:**\n\n * bool: True is the current prim path corresponds to a valid prim in stage. False otherwise.\n\n---\n**Example:**\n\n```python\n>>> # given an existing and valid prim\n>>> prims.is_valid()\nTrue\n```\n",
"snippet":"value = fixed_cone.is_valid()\n",
"category":"method"
},
{
"title":"is_visual_material_applied",
"description":"Check if there is a visual material applied\n\n**Returns:**\n\n * bool: True if there is a visual material applied. False otherwise.\n\n---\n**Example:**\n\n```python\n>>> # given a visual material applied\n>>> prim.is_visual_material_applied()\nTrue\n```\n",
"snippet":"value = fixed_cone.is_visual_material_applied()\n",
"category":"method"
},
{
"title":"post_reset",
"description":"Reset the prim to its default state (position and orientation).\n\n*Note:*\nFor an articulation, in addition to configuring the root prim's default position and spatial orientation\n(defined via the `set_default_state` method), the joint's positions, velocities, and efforts\n(defined via the `set_joints_default_state` method) are imposed\n\n---\n**Example:**\n\n```python\n>>> prim.post_reset()\n```\n",
"snippet":"fixed_cone.post_reset()\n",
"category":"method"
},
{
"title":"set_collision_approximation",
"description":"Set the collision approximation\n\n| Approximation           | Full name            | Description                                                                               |\n|-------------------------|----------------------|-------------------------------------------------------------------------------------------|\n| `\"none\"`                | Triangle Mesh        | The mesh geometry is used directly as a collider without any approximation                |\n| `\"convexDecomposition\"` | Convex Decomposition | A convex mesh decomposition is performed. This results in a set of convex mesh colliders  |\n| `\"convexHull\"`          | Convex Hull          | A convex hull of the mesh is generated and used as the collider                           |\n| `\"boundingSphere\"`      | Bounding Sphere      | A bounding sphere is computed around the mesh and used as a collider                      |\n| `\"boundingCube\"`        | Bounding Cube        | An optimally fitting box collider is computed around the mesh                             |\n| `\"meshSimplification\"`  | Mesh Simplification  | A mesh simplification step is performed, resulting in a simplified triangle mesh collider |\n| `\"sdf\"`                 | SDF Mesh             | SDF (Signed-Distance-Field) use high-detail triangle meshes as collision shape            |\n| `\"sphereFill\"`          | Sphere Approximation | A sphere mesh decomposition is performed. This results in a set of sphere colliders       |\n\n*Warning:*\nSwitching to Convex Decomposition or SDF (Signed-Distance-Field) will have a simulation performance\nimpact due to higher computational cost\n\n**Args:**\n\n * `approximation_type` (str): approximation used for collision\n\n---\n**Example:**\n\n```python\n>>> prim.set_collision_approximation(\"convexDecomposition\")\n```\n",
"snippet":"fixed_cone.set_collision_approximation(approximation_type=approximation_type)\n",
"category":"method"
},
{
"title":"set_collision_enabled",
"description":"Enable/disable the Collision API\n\n**Args:**\n\n * `enabled` (bool): Whether to enable or disable the Collision API\n\n---\n**Example:**\n\n```python\n>>> # disable collisions\n>>> prim.set_collision_enabled(False)\n```\n",
"snippet":"fixed_cone.set_collision_enabled(enabled=enabled)\n",
"category":"method"
},
{
"title":"set_contact_offset",
"description":"Set the contact offset\n\nShapes whose distance is less than the sum of their contact offset values will generate contacts\n\nSearch for *Advanced Collision Detection* in for more details\n\n*Warning:*\nThe contact offset must be positive and greater than the rest offset\n\n**Args:**\n\n * `offset` (float): Contact offset of a collision shape. Allowed range \\[maximum(0, rest\\_offset), 0\\]. Default value is -inf, means default is picked by simulation based on the shape extent.\n\n---\n**Example:**\n\n```python\n>>> prim.set_contact_offset(0.02)\n```\n",
"snippet":"fixed_cone.set_contact_offset(offset=offset)\n",
"category":"method"
},
{
"title":"set_default_state",
"description":"Set the default state of the prim (position and orientation), that will be used after each reset.\n\n**Args:**\n\n * `position` (Optional\\[Sequence\\[float\\]\\], optional): position in the world frame of the prim. shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the world frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n\n---\n**Example:**\n\n```python\n>>> # configure default state\n>>> prim.set_default_state(position=np.array([1.0, 0.5, 0.0]), orientation=np.array([1, 0, 0, 0]))\n>>>\n>>> # set default states during post-reset\n>>> prim.post_reset()\n```\n",
"snippet":"fixed_cone.set_default_state()\n",
"category":"method"
},
{
"title":"set_height",
"description":"Set the cone height\n\n**Args:**\n\n * `height` (float): cone height\n\n---\n**Example:**\n\n```python\n>>> prim.set_height(2.0)\n```\n",
"snippet":"fixed_cone.set_height(height=height)\n",
"category":"method"
},
{
"title":"set_local_pose",
"description":"Set prim's pose with respect to the local frame (the prim's parent frame).\n\n*Warning:*\nThis method will change (teleport) the prim pose immediately to the indicated value\n\n**Args:**\n\n * `translation` (Optional\\[Sequence\\[float\\]\\], optional): translation in the local frame of the prim (with respect to its parent prim). shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the local frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n\n*Hint:*\nThis method belongs to the methods used to set the prim state\n\n---\n**Example:**\n\n```python\n>>> prim.set_local_pose(translation=np.array([1.0, 0.5, 0.0]), orientation=np.array([1., 0., 0., 0.]))\n```\n",
"snippet":"fixed_cone.set_local_pose()\n",
"category":"method"
},
{
"title":"set_local_scale",
"description":"Set prim's scale with respect to the local frame (the prim's parent frame).\n\n**Args:**\n\n * `scale` (Optional\\[Sequence\\[float\\]\\]): scale to be applied to the prim's dimensions. shape is (3, ). Defaults to None, which means left unchanged.\n\n---\n**Example:**\n\n```python\n>>> # scale prim 10 times smaller\n>>> prim.set_local_scale(np.array([0.1, 0.1, 0.1]))\n```\n",
"snippet":"fixed_cone.set_local_scale(scale=scale)\n",
"category":"method"
},
{
"title":"set_min_torsional_patch_radius",
"description":"Set the minimum radius of the contact patch used to apply torsional friction\n\nSearch for *\"Torsional Patch Radius\"* in for more details\n\n**Args:**\n\n * `radius` (float): minimum radius of the contact patch used to apply torsional friction. Allowed range \\[0, max\\_float\\].\n\n---\n**Example:**\n\n```python\n>>> prim.set_min_torsional_patch_radius(0.05)\n```\n",
"snippet":"fixed_cone.set_min_torsional_patch_radius(radius=radius)\n",
"category":"method"
},
{
"title":"set_radius",
"description":"Set the base radius\n\n**Args:**\n\n * `radius` (float): base radius\n\n---\n**Example:**\n\n```python\n>>> prim.set_radius(1.0)\n```\n",
"snippet":"fixed_cone.set_radius(radius=radius)\n",
"category":"method"
},
{
"title":"set_rest_offset",
"description":"Set the rest offset\n\nTwo shapes will come to rest at a distance equal to the sum of their rest offset values.\nIf the rest offset is 0, they should converge to touching exactly\n\nSearch for *Advanced Collision Detection* in for more details\n\n*Warning:*\nThe contact offset must be positive and greater than the rest offset\n\n**Args:**\n\n * `offset` (float): Rest offset of a collision shape. Allowed range \\[-max\\_float, contact\\_offset. Default value is -inf, means default is picked by simulation. For rigid bodies its zero.\n\n---\n**Example:**\n\n```python\n>>> prim.set_rest_offset(0.01)\n```\n",
"snippet":"fixed_cone.set_rest_offset(offset=offset)\n",
"category":"method"
},
{
"title":"set_torsional_patch_radius",
"description":"Set the radius of the contact patch used to apply torsional friction\n\nSearch for *\"Torsional Patch Radius\"* in for more details\n\n**Args:**\n\n * `radius` (float): radius of the contact patch used to apply torsional friction. Allowed range \\[0, max\\_float\\].\n\n---\n**Example:**\n\n```python\n>>> prim.set_torsional_patch_radius(0.1)\n```\n",
"snippet":"fixed_cone.set_torsional_patch_radius(radius=radius)\n",
"category":"method"
},
{
"title":"set_visibility",
"description":"Set the visibility of the prim in stage\n\n**Args:**\n\n * `visible` (bool): flag to set the visibility of the usd prim in stage.\n\n---\n**Example:**\n\n```python\n>>> # make prim not visible in the stage\n>>> prim.set_visibility(visible=False)\n```\n",
"snippet":"fixed_cone.set_visibility(visible=visible)\n",
"category":"method"
},
{
"title":"set_world_pose",
"description":"Ses prim's pose with respect to the world's frame\n\n*Warning:*\nThis method will change (teleport) the prim pose immediately to the indicated value\n\n**Args:**\n\n * `position` (Optional\\[Sequence\\[float\\]\\], optional): position in the world frame of the prim. shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the world frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n\n*Hint:*\nThis method belongs to the methods used to set the prim state\n\n---\n**Example:**\n\n```python\n>>> prim.set_world_pose(position=np.array([1.0, 0.5, 0.0]), orientation=np.array([1., 0., 0., 0.]))\n```\n",
"snippet":"fixed_cone.set_world_pose()\n",
"category":"method"
}
]
},
{
"title":"FixedCuboid",
"snippets":[
{
"title":"import ...",
"description":"Import class",
"snippet":"from omni.isaac.core.objects import FixedCuboid\n",
"category":"import"
},
{
"title":"FixedCuboid",
"description":"High level wrapper to create/encapsulate a fixed cuboid\n\n*Note:*\nFixed cuboids (Cube shape) have collisions (Collider API) but no rigid body dynamics (Rigid Body API)\n\n**Args:**\n\n * `prim_path` (str): prim path of the Prim to encapsulate or create\n * `name` (str, optional): shortname to be used as a key by Scene class. Note: needs to be unique if the object is added to the Scene. Defaults to \"fixed\\_cube\".\n * `position` (Optional\\[Sequence\\[float\\]\\], optional): position in the world frame of the prim. shape is (3, ). Defaults to None, which means left unchanged.\n * `translation` (Optional\\[Sequence\\[float\\]\\], optional): translation in the local frame of the prim (with respect to its parent prim). shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the world/ local frame of the prim (depends if translation or position is specified). quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n * `scale` (Optional\\[Sequence\\[float\\]\\], optional): local scale to be applied to the prim's dimensions. shape is (3, ). Defaults to None, which means left unchanged.\n * `visible` (bool, optional): set to false for an invisible prim in the stage while rendering. Defaults to True.\n * `color` (Optional\\[np.ndarray\\], optional): color of the visual shape. Defaults to None, which means 50% gray\n * `size` (Optional\\[float\\], optional): length of each cube edge. Defaults to None.\n * `visual_material` (Optional\\[VisualMaterial\\], optional): visual material to be applied to the held prim. Defaults to None. If not specified, a default visual material will be added.\n * `physics_material` (Optional\\[PhysicsMaterial\\], optional): physics material to be applied to the held prim. Defaults to None. If not specified, a default physics material will be added.\n\n---\n**Example:**\n\n```python\n>>> from omni.isaac.core.objects import FixedCuboid\n>>> import numpy as np\n>>>\n>>> # create a red fixed cube at the given path\n>>> prim = FixedCuboid(prim_path=\"/World/Xform/Cube\", color=np.array([1.0, 0.0, 0.0]))\n>>> prim\n<omni.isaac.core.objects.cuboid.FixedCuboid object at 0x7f7b4d91da80>\n```\n",
"snippet":"fixed_cuboid = FixedCuboid(prim_path=prim_path)\n",
"category":"class"
},
{
"title":"apply_physics_material",
"description":"Used to apply physics material to the held prim and optionally its descendants.\n\n**Args:**\n\n * `physics_material` (PhysicsMaterial): physics material to be applied to the held prim. This where you want to define friction, restitution..etc. Note: if a physics material is not defined, the defaults will be used from PhysX.\n * `weaker_than_descendants` (bool, optional): True if the material shouldn't override the descendants materials, otherwise False. Defaults to False.\n\n---\n**Example:**\n\n```python\n>>> from omni.isaac.core.materials import PhysicsMaterial\n>>>\n>>> # create a rigid body physical material\n>>> material = PhysicsMaterial(\n...     prim_path=\"/World/physics_material/aluminum\",  # path to the material prim to create\n...     dynamic_friction=0.4,\n...     static_friction=1.1,\n...     restitution=0.1\n... )\n>>> prim.apply_physics_material(material)\n```\n",
"snippet":"fixed_cuboid.apply_physics_material(physics_material=physics_material)\n",
"category":"method"
},
{
"title":"apply_visual_material",
"description":"Apply visual material to the held prim and optionally its descendants.\n\n**Args:**\n\n * `visual_material` (VisualMaterial): visual material to be applied to the held prim. Currently supports PreviewSurface, OmniPBR and OmniGlass.\n * `weaker_than_descendants` (bool, optional): True if the material shouldn't override the descendants materials, otherwise False. Defaults to False.\n\n---\n**Example:**\n\n```python\n>>> from omni.isaac.core.materials import OmniGlass\n>>>\n>>> # create a dark-red glass visual material\n>>> material = OmniGlass(\n...     prim_path=\"/World/material/glass\",  # path to the material prim to create\n...     ior=1.25,\n...     depth=0.001,\n...     thin_walled=False,\n...     color=np.array([0.5, 0.0, 0.0])\n... )\n>>> prim.apply_visual_material(material)\n```\n",
"snippet":"fixed_cuboid.apply_visual_material(visual_material=visual_material)\n",
"category":"method"
},
{
"title":"get_applied_physics_material",
"description":"Return the current applied physics material in case it was applied using apply\\_physics\\_material or not.\n\n**Returns:**\n\n * PhysicsMaterial: the current applied physics material.\n\n---\n**Example:**\n\n```python\n>>> # given a physics material applied\n>>> prim.get_applied_physics_material()\n<omni.isaac.core.materials.physics_material.PhysicsMaterial object at 0x7fb66c30cd30>\n```\n",
"snippet":"applied_physics_material = fixed_cuboid.get_applied_physics_material()\n",
"category":"method"
},
{
"title":"get_applied_visual_material",
"description":"Return the current applied visual material in case it was applied using apply\\_visual\\_material\nor it's one of the following materials that was already applied before: PreviewSurface, OmniPBR and OmniGlass.\n\n**Returns:**\n\n * VisualMaterial: the current applied visual material if its type is currently supported.\n\n---\n**Example:**\n\n```python\n>>> # given a visual material applied\n>>> prim.get_applied_visual_material()\n<omni.isaac.core.materials.omni_glass.OmniGlass object at 0x7f36263106a0>\n```\n",
"snippet":"applied_visual_material = fixed_cuboid.get_applied_visual_material()\n",
"category":"method"
},
{
"title":"get_collision_approximation",
"description":"Get the collision approximation\n\n| Approximation           | Full name            | Description                                                                               |\n|-------------------------|----------------------|-------------------------------------------------------------------------------------------|\n| `\"none\"`                | Triangle Mesh        | The mesh geometry is used directly as a collider without any approximation                |\n| `\"convexDecomposition\"` | Convex Decomposition | A convex mesh decomposition is performed. This results in a set of convex mesh colliders  |\n| `\"convexHull\"`          | Convex Hull          | A convex hull of the mesh is generated and used as the collider                           |\n| `\"boundingSphere\"`      | Bounding Sphere      | A bounding sphere is computed around the mesh and used as a collider                      |\n| `\"boundingCube\"`        | Bounding Cube        | An optimally fitting box collider is computed around the mesh                             |\n| `\"meshSimplification\"`  | Mesh Simplification  | A mesh simplification step is performed, resulting in a simplified triangle mesh collider |\n| `\"sdf\"`                 | SDF Mesh             | SDF (Signed-Distance-Field) use high-detail triangle meshes as collision shape            |\n| `\"sphereFill\"`          | Sphere Approximation | A sphere mesh decomposition is performed. This results in a set of sphere colliders       |\n\n**Returns:**\n\n * str: approximation used for collision\n\n---\n**Example:**\n\n```python\n>>> prim.get_collision_approximation()\nnone\n```\n",
"snippet":"collision_approximation = fixed_cuboid.get_collision_approximation()\n",
"category":"method"
},
{
"title":"get_collision_enabled",
"description":"Check if the Collision API is enabled\n\n**Returns:**\n\n * bool: True if the Collision API is enabled. Otherwise False\n\n---\n**Example:**\n\n```python\n>>> prim.get_collision_enabled()\nTrue\n```\n",
"snippet":"collision_enabled = fixed_cuboid.get_collision_enabled()\n",
"category":"method"
},
{
"title":"get_contact_force_matrix",
"description":"If the object is initialized with filter\\_paths\\_expr list, this method returns the contact forces between the prims\nin the view and the filter prims. i.e., a matrix of dimension (self.\\_contact\\_view.num\\_filters, 3)\nwhere num\\_filters is the determined according to the filter\\_paths\\_expr parameter.\n\n**Args:**\n\n * `dt` (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor\\]: Net contact forces of the prims with shape (self.\\_geometry\\_prim\\_view.\\_contact\\_view.num\\_filters, 3).\n",
"snippet":"contact_force_matrix = fixed_cuboid.get_contact_force_matrix()\n",
"category":"method"
},
{
"title":"get_contact_offset",
"description":"Get the contact offset\n\nShapes whose distance is less than the sum of their contact offset values will generate contacts\n\nSearch for *Advanced Collision Detection* in for more details\n\n**Returns:**\n\n * float: contact offset of the collision shape. Default value is -inf, means default is picked by simulation.\n\n---\n**Example:**\n\n```python\n>>> prim.get_contact_offset()\n-inf\n```\n",
"snippet":"contact_offset = fixed_cuboid.get_contact_offset()\n",
"category":"method"
},
{
"title":"get_default_state",
"description":"Get the default prim states (spatial position and orientation).\n\n**Returns:**\n\n * XFormPrimState: an object that contains the default state of the prim (position and orientation)\n\n---\n**Example:**\n\n```python\n>>> state = prim.get_default_state()\n>>> state\n<omni.isaac.core.utils.types.XFormPrimState object at 0x7f33addda650>\n>>>\n>>> state.position\n[-4.5299529e-08 -1.8347054e-09 -2.8610229e-08]\n>>> state.orientation\n[1. 0. 0. 0.]\n```\n",
"snippet":"default_state = fixed_cuboid.get_default_state()\n",
"category":"method"
},
{
"title":"get_local_pose",
"description":"Get prim's pose with respect to the local frame (the prim's parent frame)\n\n**Returns:**\n\n * Tuple\\[np.ndarray, np.ndarray\\]: first index is the position in the local frame (with shape (3, )).\n    Second index is quaternion orientation (with shape (4, )) in the local frame\n\n---\n**Example:**\n\n```python\n>>> # if the prim is in position (1.0, 0.5, 0.0) with respect to the world frame\n>>> position, orientation = prim.get_local_pose()\n>>> position\n[0. 0. 0.]\n>>> orientation\n[0. 0. 0.]\n```\n",
"snippet":"local_pose = fixed_cuboid.get_local_pose()\n",
"category":"method"
},
{
"title":"get_local_scale",
"description":"Get prim's scale with respect to the local frame (the parent's frame)\n\n**Returns:**\n\n * np.ndarray: scale applied to the prim's dimensions in the local frame. shape is (3, ).\n\n---\n**Example:**\n\n```python\n>>> prim.get_local_scale()\n[1. 1. 1.]\n```\n",
"snippet":"local_scale = fixed_cuboid.get_local_scale()\n",
"category":"method"
},
{
"title":"get_min_torsional_patch_radius",
"description":"Get the minimum radius of the contact patch used to apply torsional friction\n\nSearch for *\"Torsional Patch Radius\"* in for more details\n\n**Returns:**\n\n * float: minimum radius of the contact patch used to apply torsional friction. Allowed range \\[0, max\\_float\\].\n\n---\n**Example:**\n\n```python\n>>> prim.get_min_torsional_patch_radius()\n0.0\n```\n",
"snippet":"min_torsional_patch_radius = fixed_cuboid.get_min_torsional_patch_radius()\n",
"category":"method"
},
{
"title":"get_net_contact_forces",
"description":"If contact forces of the prims in the view are tracked, this method returns the net contact forces on prims.\ni.e., a matrix of dimension (1, 3)\n\n**Args:**\n\n * `dt` (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor\\]: Net contact forces of the prims with shape (3).\n",
"snippet":"net_contact_forces = fixed_cuboid.get_net_contact_forces()\n",
"category":"method"
},
{
"title":"get_rest_offset",
"description":"Get the rest offset\n\nTwo shapes will come to rest at a distance equal to the sum of their rest offset values.\nIf the rest offset is 0, they should converge to touching exactly\n\nSearch for *Advanced Collision Detection* in for more details\n\n**Returns:**\n\n * float: rest offset of the collision shape.\n\n---\n**Example:**\n\n```python\n>>> prim.get_rest_offset()\n-inf\n```\n",
"snippet":"rest_offset = fixed_cuboid.get_rest_offset()\n",
"category":"method"
},
{
"title":"get_size",
"description":"Get the length of each cube edge\n\n**Returns:**\n\n * float: edge length\n\n---\n**Example:**\n\n```python\n>>> prim.get_size()\n1.0\n```\n",
"snippet":"size = fixed_cuboid.get_size()\n",
"category":"method"
},
{
"title":"get_torsional_patch_radius",
"description":"Get the radius of the contact patch used to apply torsional friction\n\nSearch for *\"Torsional Patch Radius\"* in for more details\n\n**Returns:**\n\n * float: radius of the contact patch used to apply torsional friction. Allowed range \\[0, max\\_float\\].\n\n---\n**Example:**\n\n```python\n>>> prim.get_torsional_patch_radius()\n0.0\n```\n",
"snippet":"torsional_patch_radius = fixed_cuboid.get_torsional_patch_radius()\n",
"category":"method"
},
{
"title":"get_visibility",
"description":"**Returns:**\n\n * bool: true if the prim is visible in stage. false otherwise.\n\n---\n**Example:**\n\n```python\n>>> # get the visible state of an visible prim on the stage\n>>> prim.get_visibility()\nTrue\n```\n",
"snippet":"visibility = fixed_cuboid.get_visibility()\n",
"category":"method"
},
{
"title":"get_world_pose",
"description":"Get prim's pose with respect to the world's frame\n\n**Returns:**\n\n * Tuple\\[np.ndarray, np.ndarray\\]: first index is the position in the world frame (with shape (3, )).\n    Second index is quaternion orientation (with shape (4, )) in the world frame\n\n---\n**Example:**\n\n```python\n>>> # if the prim is in position (1.0, 0.5, 0.0) with respect to the world frame\n>>> position, orientation = prim.get_world_pose()\n>>> position\n[1.  0.5 0. ]\n>>> orientation\n[1. 0. 0. 0.]\n```\n",
"snippet":"world_pose = fixed_cuboid.get_world_pose()\n",
"category":"method"
},
{
"title":"get_world_scale",
"description":"Get prim's scale with respect to the world's frame\n\n**Returns:**\n\n * np.ndarray: scale applied to the prim's dimensions in the world frame. shape is (3, ).\n\n---\n**Example:**\n\n```python\n>>> prim.get_world_scale()\n[1. 1. 1.]\n```\n",
"snippet":"world_scale = fixed_cuboid.get_world_scale()\n",
"category":"method"
},
{
"title":"initialize",
"description":"Create a physics simulation view if not passed and using PhysX tensor API\n\n*Note:*\nIf the prim has been added to the world scene (e.g., `world.scene.add(prim)`),\nit will be automatically initialized when the world is reset (e.g., `world.reset()`).\n\n**Args:**\n\n * `physics_sim_view` (omni.physics.tensors.SimulationView, optional): current physics simulation view. Defaults to None.\n\n---\n**Example:**\n\n```python\n>>> prim.initialize()\n```\n",
"snippet":"fixed_cuboid.initialize()\n",
"category":"method"
},
{
"title":"is_valid",
"description":"Check if the prim path has a valid USD Prim at it\n\n**Returns:**\n\n * bool: True is the current prim path corresponds to a valid prim in stage. False otherwise.\n\n---\n**Example:**\n\n```python\n>>> # given an existing and valid prim\n>>> prims.is_valid()\nTrue\n```\n",
"snippet":"value = fixed_cuboid.is_valid()\n",
"category":"method"
},
{
"title":"is_visual_material_applied",
"description":"Check if there is a visual material applied\n\n**Returns:**\n\n * bool: True if there is a visual material applied. False otherwise.\n\n---\n**Example:**\n\n```python\n>>> # given a visual material applied\n>>> prim.is_visual_material_applied()\nTrue\n```\n",
"snippet":"value = fixed_cuboid.is_visual_material_applied()\n",
"category":"method"
},
{
"title":"post_reset",
"description":"Reset the prim to its default state (position and orientation).\n\n*Note:*\nFor an articulation, in addition to configuring the root prim's default position and spatial orientation\n(defined via the `set_default_state` method), the joint's positions, velocities, and efforts\n(defined via the `set_joints_default_state` method) are imposed\n\n---\n**Example:**\n\n```python\n>>> prim.post_reset()\n```\n",
"snippet":"fixed_cuboid.post_reset()\n",
"category":"method"
},
{
"title":"set_collision_approximation",
"description":"Set the collision approximation\n\n| Approximation           | Full name            | Description                                                                               |\n|-------------------------|----------------------|-------------------------------------------------------------------------------------------|\n| `\"none\"`                | Triangle Mesh        | The mesh geometry is used directly as a collider without any approximation                |\n| `\"convexDecomposition\"` | Convex Decomposition | A convex mesh decomposition is performed. This results in a set of convex mesh colliders  |\n| `\"convexHull\"`          | Convex Hull          | A convex hull of the mesh is generated and used as the collider                           |\n| `\"boundingSphere\"`      | Bounding Sphere      | A bounding sphere is computed around the mesh and used as a collider                      |\n| `\"boundingCube\"`        | Bounding Cube        | An optimally fitting box collider is computed around the mesh                             |\n| `\"meshSimplification\"`  | Mesh Simplification  | A mesh simplification step is performed, resulting in a simplified triangle mesh collider |\n| `\"sdf\"`                 | SDF Mesh             | SDF (Signed-Distance-Field) use high-detail triangle meshes as collision shape            |\n| `\"sphereFill\"`          | Sphere Approximation | A sphere mesh decomposition is performed. This results in a set of sphere colliders       |\n\n*Warning:*\nSwitching to Convex Decomposition or SDF (Signed-Distance-Field) will have a simulation performance\nimpact due to higher computational cost\n\n**Args:**\n\n * `approximation_type` (str): approximation used for collision\n\n---\n**Example:**\n\n```python\n>>> prim.set_collision_approximation(\"convexDecomposition\")\n```\n",
"snippet":"fixed_cuboid.set_collision_approximation(approximation_type=approximation_type)\n",
"category":"method"
},
{
"title":"set_collision_enabled",
"description":"Enable/disable the Collision API\n\n**Args:**\n\n * `enabled` (bool): Whether to enable or disable the Collision API\n\n---\n**Example:**\n\n```python\n>>> # disable collisions\n>>> prim.set_collision_enabled(False)\n```\n",
"snippet":"fixed_cuboid.set_collision_enabled(enabled=enabled)\n",
"category":"method"
},
{
"title":"set_contact_offset",
"description":"Set the contact offset\n\nShapes whose distance is less than the sum of their contact offset values will generate contacts\n\nSearch for *Advanced Collision Detection* in for more details\n\n*Warning:*\nThe contact offset must be positive and greater than the rest offset\n\n**Args:**\n\n * `offset` (float): Contact offset of a collision shape. Allowed range \\[maximum(0, rest\\_offset), 0\\]. Default value is -inf, means default is picked by simulation based on the shape extent.\n\n---\n**Example:**\n\n```python\n>>> prim.set_contact_offset(0.02)\n```\n",
"snippet":"fixed_cuboid.set_contact_offset(offset=offset)\n",
"category":"method"
},
{
"title":"set_default_state",
"description":"Set the default state of the prim (position and orientation), that will be used after each reset.\n\n**Args:**\n\n * `position` (Optional\\[Sequence\\[float\\]\\], optional): position in the world frame of the prim. shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the world frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n\n---\n**Example:**\n\n```python\n>>> # configure default state\n>>> prim.set_default_state(position=np.array([1.0, 0.5, 0.0]), orientation=np.array([1, 0, 0, 0]))\n>>>\n>>> # set default states during post-reset\n>>> prim.post_reset()\n```\n",
"snippet":"fixed_cuboid.set_default_state()\n",
"category":"method"
},
{
"title":"set_local_pose",
"description":"Set prim's pose with respect to the local frame (the prim's parent frame).\n\n*Warning:*\nThis method will change (teleport) the prim pose immediately to the indicated value\n\n**Args:**\n\n * `translation` (Optional\\[Sequence\\[float\\]\\], optional): translation in the local frame of the prim (with respect to its parent prim). shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the local frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n\n*Hint:*\nThis method belongs to the methods used to set the prim state\n\n---\n**Example:**\n\n```python\n>>> prim.set_local_pose(translation=np.array([1.0, 0.5, 0.0]), orientation=np.array([1., 0., 0., 0.]))\n```\n",
"snippet":"fixed_cuboid.set_local_pose()\n",
"category":"method"
},
{
"title":"set_local_scale",
"description":"Set prim's scale with respect to the local frame (the prim's parent frame).\n\n**Args:**\n\n * `scale` (Optional\\[Sequence\\[float\\]\\]): scale to be applied to the prim's dimensions. shape is (3, ). Defaults to None, which means left unchanged.\n\n---\n**Example:**\n\n```python\n>>> # scale prim 10 times smaller\n>>> prim.set_local_scale(np.array([0.1, 0.1, 0.1]))\n```\n",
"snippet":"fixed_cuboid.set_local_scale(scale=scale)\n",
"category":"method"
},
{
"title":"set_min_torsional_patch_radius",
"description":"Set the minimum radius of the contact patch used to apply torsional friction\n\nSearch for *\"Torsional Patch Radius\"* in for more details\n\n**Args:**\n\n * `radius` (float): minimum radius of the contact patch used to apply torsional friction. Allowed range \\[0, max\\_float\\].\n\n---\n**Example:**\n\n```python\n>>> prim.set_min_torsional_patch_radius(0.05)\n```\n",
"snippet":"fixed_cuboid.set_min_torsional_patch_radius(radius=radius)\n",
"category":"method"
},
{
"title":"set_rest_offset",
"description":"Set the rest offset\n\nTwo shapes will come to rest at a distance equal to the sum of their rest offset values.\nIf the rest offset is 0, they should converge to touching exactly\n\nSearch for *Advanced Collision Detection* in for more details\n\n*Warning:*\nThe contact offset must be positive and greater than the rest offset\n\n**Args:**\n\n * `offset` (float): Rest offset of a collision shape. Allowed range \\[-max\\_float, contact\\_offset. Default value is -inf, means default is picked by simulation. For rigid bodies its zero.\n\n---\n**Example:**\n\n```python\n>>> prim.set_rest_offset(0.01)\n```\n",
"snippet":"fixed_cuboid.set_rest_offset(offset=offset)\n",
"category":"method"
},
{
"title":"set_size",
"description":"Set the length of each cube edge\n\n**Args:**\n\n * `size` (float): edge length\n\n---\n**Example:**\n\n```python\n>>> prim.set_size(2.0)\n```\n",
"snippet":"fixed_cuboid.set_size(size=size)\n",
"category":"method"
},
{
"title":"set_torsional_patch_radius",
"description":"Set the radius of the contact patch used to apply torsional friction\n\nSearch for *\"Torsional Patch Radius\"* in for more details\n\n**Args:**\n\n * `radius` (float): radius of the contact patch used to apply torsional friction. Allowed range \\[0, max\\_float\\].\n\n---\n**Example:**\n\n```python\n>>> prim.set_torsional_patch_radius(0.1)\n```\n",
"snippet":"fixed_cuboid.set_torsional_patch_radius(radius=radius)\n",
"category":"method"
},
{
"title":"set_visibility",
"description":"Set the visibility of the prim in stage\n\n**Args:**\n\n * `visible` (bool): flag to set the visibility of the usd prim in stage.\n\n---\n**Example:**\n\n```python\n>>> # make prim not visible in the stage\n>>> prim.set_visibility(visible=False)\n```\n",
"snippet":"fixed_cuboid.set_visibility(visible=visible)\n",
"category":"method"
},
{
"title":"set_world_pose",
"description":"Ses prim's pose with respect to the world's frame\n\n*Warning:*\nThis method will change (teleport) the prim pose immediately to the indicated value\n\n**Args:**\n\n * `position` (Optional\\[Sequence\\[float\\]\\], optional): position in the world frame of the prim. shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the world frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n\n*Hint:*\nThis method belongs to the methods used to set the prim state\n\n---\n**Example:**\n\n```python\n>>> prim.set_world_pose(position=np.array([1.0, 0.5, 0.0]), orientation=np.array([1., 0., 0., 0.]))\n```\n",
"snippet":"fixed_cuboid.set_world_pose()\n",
"category":"method"
}
]
},
{
"title":"FixedCylinder",
"snippets":[
{
"title":"import ...",
"description":"Import class",
"snippet":"from omni.isaac.core.objects import FixedCylinder\n",
"category":"import"
},
{
"title":"FixedCylinder",
"description":"High level wrapper to create/encapsulate a fixed cylinder\n\n*Note:*\nFixed cylinders (Cylinder shape) have collisions (Collider API) but no rigid body dynamics (Rigid Body API)\n\n**Args:**\n\n * `prim_path` (str): prim path of the Prim to encapsulate or create\n * `name` (str, optional): shortname to be used as a key by Scene class. Note: needs to be unique if the object is added to the Scene. Defaults to \"fixed\\_cylinder\".\n * `position` (Optional\\[Sequence\\[float\\]\\], optional): position in the world frame of the prim. shape is (3, ). Defaults to None, which means left unchanged.\n * `translation` (Optional\\[Sequence\\[float\\]\\], optional): translation in the local frame of the prim (with respect to its parent prim). shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the world/ local frame of the prim (depends if translation or position is specified). quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n * `scale` (Optional\\[Sequence\\[float\\]\\], optional): local scale to be applied to the prim's dimensions. shape is (3, ). Defaults to None, which means left unchanged.\n * `visible` (bool, optional): set to false for an invisible prim in the stage while rendering. Defaults to True.\n * `color` (Optional\\[np.ndarray\\], optional): color of the visual shape. Defaults to None, which means 50% gray\n * `radius` (Optional\\[float\\], optional): base radius. Defaults to None.\n * `height` (Optional\\[float\\], optional): cylinder height. Defaults to None.\n * `visual_material` (Optional\\[VisualMaterial\\], optional): visual material to be applied to the held prim. Defaults to None. If not specified, a default visual material will be added.\n * `physics_material` (Optional\\[PhysicsMaterial\\], optional): physics material to be applied to the held prim. Defaults to None. If not specified, a default physics material will be added.\n\n---\n**Example:**\n\n```python\n>>> from omni.isaac.core.objects import FixedCylinder\n>>> import numpy as np\n>>>\n>>> # create a red fixed cylinder at the given path\n>>> prim = FixedCylinder(\n...     prim_path=\"/World/Xform/Cylinder\",\n...     radius=0.5,\n...     height=1.0,\n...     color=np.array([1.0, 0.0, 0.0])\n... )\n>>> print(prim)\n<omni.isaac.core.objects.cylinder.FixedCylinder object at 0x7f4f24144f40>\n```\n",
"snippet":"fixed_cylinder = FixedCylinder(prim_path=prim_path)\n",
"category":"class"
},
{
"title":"apply_physics_material",
"description":"Used to apply physics material to the held prim and optionally its descendants.\n\n**Args:**\n\n * `physics_material` (PhysicsMaterial): physics material to be applied to the held prim. This where you want to define friction, restitution..etc. Note: if a physics material is not defined, the defaults will be used from PhysX.\n * `weaker_than_descendants` (bool, optional): True if the material shouldn't override the descendants materials, otherwise False. Defaults to False.\n\n---\n**Example:**\n\n```python\n>>> from omni.isaac.core.materials import PhysicsMaterial\n>>>\n>>> # create a rigid body physical material\n>>> material = PhysicsMaterial(\n...     prim_path=\"/World/physics_material/aluminum\",  # path to the material prim to create\n...     dynamic_friction=0.4,\n...     static_friction=1.1,\n...     restitution=0.1\n... )\n>>> prim.apply_physics_material(material)\n```\n",
"snippet":"fixed_cylinder.apply_physics_material(physics_material=physics_material)\n",
"category":"method"
},
{
"title":"apply_visual_material",
"description":"Apply visual material to the held prim and optionally its descendants.\n\n**Args:**\n\n * `visual_material` (VisualMaterial): visual material to be applied to the held prim. Currently supports PreviewSurface, OmniPBR and OmniGlass.\n * `weaker_than_descendants` (bool, optional): True if the material shouldn't override the descendants materials, otherwise False. Defaults to False.\n\n---\n**Example:**\n\n```python\n>>> from omni.isaac.core.materials import OmniGlass\n>>>\n>>> # create a dark-red glass visual material\n>>> material = OmniGlass(\n...     prim_path=\"/World/material/glass\",  # path to the material prim to create\n...     ior=1.25,\n...     depth=0.001,\n...     thin_walled=False,\n...     color=np.array([0.5, 0.0, 0.0])\n... )\n>>> prim.apply_visual_material(material)\n```\n",
"snippet":"fixed_cylinder.apply_visual_material(visual_material=visual_material)\n",
"category":"method"
},
{
"title":"get_applied_physics_material",
"description":"Return the current applied physics material in case it was applied using apply\\_physics\\_material or not.\n\n**Returns:**\n\n * PhysicsMaterial: the current applied physics material.\n\n---\n**Example:**\n\n```python\n>>> # given a physics material applied\n>>> prim.get_applied_physics_material()\n<omni.isaac.core.materials.physics_material.PhysicsMaterial object at 0x7fb66c30cd30>\n```\n",
"snippet":"applied_physics_material = fixed_cylinder.get_applied_physics_material()\n",
"category":"method"
},
{
"title":"get_applied_visual_material",
"description":"Return the current applied visual material in case it was applied using apply\\_visual\\_material\nor it's one of the following materials that was already applied before: PreviewSurface, OmniPBR and OmniGlass.\n\n**Returns:**\n\n * VisualMaterial: the current applied visual material if its type is currently supported.\n\n---\n**Example:**\n\n```python\n>>> # given a visual material applied\n>>> prim.get_applied_visual_material()\n<omni.isaac.core.materials.omni_glass.OmniGlass object at 0x7f36263106a0>\n```\n",
"snippet":"applied_visual_material = fixed_cylinder.get_applied_visual_material()\n",
"category":"method"
},
{
"title":"get_collision_approximation",
"description":"Get the collision approximation\n\n| Approximation           | Full name            | Description                                                                               |\n|-------------------------|----------------------|-------------------------------------------------------------------------------------------|\n| `\"none\"`                | Triangle Mesh        | The mesh geometry is used directly as a collider without any approximation                |\n| `\"convexDecomposition\"` | Convex Decomposition | A convex mesh decomposition is performed. This results in a set of convex mesh colliders  |\n| `\"convexHull\"`          | Convex Hull          | A convex hull of the mesh is generated and used as the collider                           |\n| `\"boundingSphere\"`      | Bounding Sphere      | A bounding sphere is computed around the mesh and used as a collider                      |\n| `\"boundingCube\"`        | Bounding Cube        | An optimally fitting box collider is computed around the mesh                             |\n| `\"meshSimplification\"`  | Mesh Simplification  | A mesh simplification step is performed, resulting in a simplified triangle mesh collider |\n| `\"sdf\"`                 | SDF Mesh             | SDF (Signed-Distance-Field) use high-detail triangle meshes as collision shape            |\n| `\"sphereFill\"`          | Sphere Approximation | A sphere mesh decomposition is performed. This results in a set of sphere colliders       |\n\n**Returns:**\n\n * str: approximation used for collision\n\n---\n**Example:**\n\n```python\n>>> prim.get_collision_approximation()\nnone\n```\n",
"snippet":"collision_approximation = fixed_cylinder.get_collision_approximation()\n",
"category":"method"
},
{
"title":"get_collision_enabled",
"description":"Check if the Collision API is enabled\n\n**Returns:**\n\n * bool: True if the Collision API is enabled. Otherwise False\n\n---\n**Example:**\n\n```python\n>>> prim.get_collision_enabled()\nTrue\n```\n",
"snippet":"collision_enabled = fixed_cylinder.get_collision_enabled()\n",
"category":"method"
},
{
"title":"get_contact_force_matrix",
"description":"If the object is initialized with filter\\_paths\\_expr list, this method returns the contact forces between the prims\nin the view and the filter prims. i.e., a matrix of dimension (self.\\_contact\\_view.num\\_filters, 3)\nwhere num\\_filters is the determined according to the filter\\_paths\\_expr parameter.\n\n**Args:**\n\n * `dt` (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor\\]: Net contact forces of the prims with shape (self.\\_geometry\\_prim\\_view.\\_contact\\_view.num\\_filters, 3).\n",
"snippet":"contact_force_matrix = fixed_cylinder.get_contact_force_matrix()\n",
"category":"method"
},
{
"title":"get_contact_offset",
"description":"Get the contact offset\n\nShapes whose distance is less than the sum of their contact offset values will generate contacts\n\nSearch for *Advanced Collision Detection* in for more details\n\n**Returns:**\n\n * float: contact offset of the collision shape. Default value is -inf, means default is picked by simulation.\n\n---\n**Example:**\n\n```python\n>>> prim.get_contact_offset()\n-inf\n```\n",
"snippet":"contact_offset = fixed_cylinder.get_contact_offset()\n",
"category":"method"
},
{
"title":"get_default_state",
"description":"Get the default prim states (spatial position and orientation).\n\n**Returns:**\n\n * XFormPrimState: an object that contains the default state of the prim (position and orientation)\n\n---\n**Example:**\n\n```python\n>>> state = prim.get_default_state()\n>>> state\n<omni.isaac.core.utils.types.XFormPrimState object at 0x7f33addda650>\n>>>\n>>> state.position\n[-4.5299529e-08 -1.8347054e-09 -2.8610229e-08]\n>>> state.orientation\n[1. 0. 0. 0.]\n```\n",
"snippet":"default_state = fixed_cylinder.get_default_state()\n",
"category":"method"
},
{
"title":"get_height",
"description":"Get the cylinder height\n\n**Returns:**\n\n * float: cylinder height\n\n---\n**Example:**\n\n```python\n>>> prim.get_height()\n1.0\n```\n",
"snippet":"height = fixed_cylinder.get_height()\n",
"category":"method"
},
{
"title":"get_local_pose",
"description":"Get prim's pose with respect to the local frame (the prim's parent frame)\n\n**Returns:**\n\n * Tuple\\[np.ndarray, np.ndarray\\]: first index is the position in the local frame (with shape (3, )).\n    Second index is quaternion orientation (with shape (4, )) in the local frame\n\n---\n**Example:**\n\n```python\n>>> # if the prim is in position (1.0, 0.5, 0.0) with respect to the world frame\n>>> position, orientation = prim.get_local_pose()\n>>> position\n[0. 0. 0.]\n>>> orientation\n[0. 0. 0.]\n```\n",
"snippet":"local_pose = fixed_cylinder.get_local_pose()\n",
"category":"method"
},
{
"title":"get_local_scale",
"description":"Get prim's scale with respect to the local frame (the parent's frame)\n\n**Returns:**\n\n * np.ndarray: scale applied to the prim's dimensions in the local frame. shape is (3, ).\n\n---\n**Example:**\n\n```python\n>>> prim.get_local_scale()\n[1. 1. 1.]\n```\n",
"snippet":"local_scale = fixed_cylinder.get_local_scale()\n",
"category":"method"
},
{
"title":"get_min_torsional_patch_radius",
"description":"Get the minimum radius of the contact patch used to apply torsional friction\n\nSearch for *\"Torsional Patch Radius\"* in for more details\n\n**Returns:**\n\n * float: minimum radius of the contact patch used to apply torsional friction. Allowed range \\[0, max\\_float\\].\n\n---\n**Example:**\n\n```python\n>>> prim.get_min_torsional_patch_radius()\n0.0\n```\n",
"snippet":"min_torsional_patch_radius = fixed_cylinder.get_min_torsional_patch_radius()\n",
"category":"method"
},
{
"title":"get_net_contact_forces",
"description":"If contact forces of the prims in the view are tracked, this method returns the net contact forces on prims.\ni.e., a matrix of dimension (1, 3)\n\n**Args:**\n\n * `dt` (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor\\]: Net contact forces of the prims with shape (3).\n",
"snippet":"net_contact_forces = fixed_cylinder.get_net_contact_forces()\n",
"category":"method"
},
{
"title":"get_radius",
"description":"Get the base radius\n\n**Returns:**\n\n * float: base radius\n\n---\n**Example:**\n\n```python\n>>> prim.get_radius()\n0.5\n```\n",
"snippet":"radius = fixed_cylinder.get_radius()\n",
"category":"method"
},
{
"title":"get_rest_offset",
"description":"Get the rest offset\n\nTwo shapes will come to rest at a distance equal to the sum of their rest offset values.\nIf the rest offset is 0, they should converge to touching exactly\n\nSearch for *Advanced Collision Detection* in for more details\n\n**Returns:**\n\n * float: rest offset of the collision shape.\n\n---\n**Example:**\n\n```python\n>>> prim.get_rest_offset()\n-inf\n```\n",
"snippet":"rest_offset = fixed_cylinder.get_rest_offset()\n",
"category":"method"
},
{
"title":"get_torsional_patch_radius",
"description":"Get the radius of the contact patch used to apply torsional friction\n\nSearch for *\"Torsional Patch Radius\"* in for more details\n\n**Returns:**\n\n * float: radius of the contact patch used to apply torsional friction. Allowed range \\[0, max\\_float\\].\n\n---\n**Example:**\n\n```python\n>>> prim.get_torsional_patch_radius()\n0.0\n```\n",
"snippet":"torsional_patch_radius = fixed_cylinder.get_torsional_patch_radius()\n",
"category":"method"
},
{
"title":"get_visibility",
"description":"**Returns:**\n\n * bool: true if the prim is visible in stage. false otherwise.\n\n---\n**Example:**\n\n```python\n>>> # get the visible state of an visible prim on the stage\n>>> prim.get_visibility()\nTrue\n```\n",
"snippet":"visibility = fixed_cylinder.get_visibility()\n",
"category":"method"
},
{
"title":"get_world_pose",
"description":"Get prim's pose with respect to the world's frame\n\n**Returns:**\n\n * Tuple\\[np.ndarray, np.ndarray\\]: first index is the position in the world frame (with shape (3, )).\n    Second index is quaternion orientation (with shape (4, )) in the world frame\n\n---\n**Example:**\n\n```python\n>>> # if the prim is in position (1.0, 0.5, 0.0) with respect to the world frame\n>>> position, orientation = prim.get_world_pose()\n>>> position\n[1.  0.5 0. ]\n>>> orientation\n[1. 0. 0. 0.]\n```\n",
"snippet":"world_pose = fixed_cylinder.get_world_pose()\n",
"category":"method"
},
{
"title":"get_world_scale",
"description":"Get prim's scale with respect to the world's frame\n\n**Returns:**\n\n * np.ndarray: scale applied to the prim's dimensions in the world frame. shape is (3, ).\n\n---\n**Example:**\n\n```python\n>>> prim.get_world_scale()\n[1. 1. 1.]\n```\n",
"snippet":"world_scale = fixed_cylinder.get_world_scale()\n",
"category":"method"
},
{
"title":"initialize",
"description":"Create a physics simulation view if not passed and using PhysX tensor API\n\n*Note:*\nIf the prim has been added to the world scene (e.g., `world.scene.add(prim)`),\nit will be automatically initialized when the world is reset (e.g., `world.reset()`).\n\n**Args:**\n\n * `physics_sim_view` (omni.physics.tensors.SimulationView, optional): current physics simulation view. Defaults to None.\n\n---\n**Example:**\n\n```python\n>>> prim.initialize()\n```\n",
"snippet":"fixed_cylinder.initialize()\n",
"category":"method"
},
{
"title":"is_valid",
"description":"Check if the prim path has a valid USD Prim at it\n\n**Returns:**\n\n * bool: True is the current prim path corresponds to a valid prim in stage. False otherwise.\n\n---\n**Example:**\n\n```python\n>>> # given an existing and valid prim\n>>> prims.is_valid()\nTrue\n```\n",
"snippet":"value = fixed_cylinder.is_valid()\n",
"category":"method"
},
{
"title":"is_visual_material_applied",
"description":"Check if there is a visual material applied\n\n**Returns:**\n\n * bool: True if there is a visual material applied. False otherwise.\n\n---\n**Example:**\n\n```python\n>>> # given a visual material applied\n>>> prim.is_visual_material_applied()\nTrue\n```\n",
"snippet":"value = fixed_cylinder.is_visual_material_applied()\n",
"category":"method"
},
{
"title":"post_reset",
"description":"Reset the prim to its default state (position and orientation).\n\n*Note:*\nFor an articulation, in addition to configuring the root prim's default position and spatial orientation\n(defined via the `set_default_state` method), the joint's positions, velocities, and efforts\n(defined via the `set_joints_default_state` method) are imposed\n\n---\n**Example:**\n\n```python\n>>> prim.post_reset()\n```\n",
"snippet":"fixed_cylinder.post_reset()\n",
"category":"method"
},
{
"title":"set_collision_approximation",
"description":"Set the collision approximation\n\n| Approximation           | Full name            | Description                                                                               |\n|-------------------------|----------------------|-------------------------------------------------------------------------------------------|\n| `\"none\"`                | Triangle Mesh        | The mesh geometry is used directly as a collider without any approximation                |\n| `\"convexDecomposition\"` | Convex Decomposition | A convex mesh decomposition is performed. This results in a set of convex mesh colliders  |\n| `\"convexHull\"`          | Convex Hull          | A convex hull of the mesh is generated and used as the collider                           |\n| `\"boundingSphere\"`      | Bounding Sphere      | A bounding sphere is computed around the mesh and used as a collider                      |\n| `\"boundingCube\"`        | Bounding Cube        | An optimally fitting box collider is computed around the mesh                             |\n| `\"meshSimplification\"`  | Mesh Simplification  | A mesh simplification step is performed, resulting in a simplified triangle mesh collider |\n| `\"sdf\"`                 | SDF Mesh             | SDF (Signed-Distance-Field) use high-detail triangle meshes as collision shape            |\n| `\"sphereFill\"`          | Sphere Approximation | A sphere mesh decomposition is performed. This results in a set of sphere colliders       |\n\n*Warning:*\nSwitching to Convex Decomposition or SDF (Signed-Distance-Field) will have a simulation performance\nimpact due to higher computational cost\n\n**Args:**\n\n * `approximation_type` (str): approximation used for collision\n\n---\n**Example:**\n\n```python\n>>> prim.set_collision_approximation(\"convexDecomposition\")\n```\n",
"snippet":"fixed_cylinder.set_collision_approximation(approximation_type=approximation_type)\n",
"category":"method"
},
{
"title":"set_collision_enabled",
"description":"Enable/disable the Collision API\n\n**Args:**\n\n * `enabled` (bool): Whether to enable or disable the Collision API\n\n---\n**Example:**\n\n```python\n>>> # disable collisions\n>>> prim.set_collision_enabled(False)\n```\n",
"snippet":"fixed_cylinder.set_collision_enabled(enabled=enabled)\n",
"category":"method"
},
{
"title":"set_contact_offset",
"description":"Set the contact offset\n\nShapes whose distance is less than the sum of their contact offset values will generate contacts\n\nSearch for *Advanced Collision Detection* in for more details\n\n*Warning:*\nThe contact offset must be positive and greater than the rest offset\n\n**Args:**\n\n * `offset` (float): Contact offset of a collision shape. Allowed range \\[maximum(0, rest\\_offset), 0\\]. Default value is -inf, means default is picked by simulation based on the shape extent.\n\n---\n**Example:**\n\n```python\n>>> prim.set_contact_offset(0.02)\n```\n",
"snippet":"fixed_cylinder.set_contact_offset(offset=offset)\n",
"category":"method"
},
{
"title":"set_default_state",
"description":"Set the default state of the prim (position and orientation), that will be used after each reset.\n\n**Args:**\n\n * `position` (Optional\\[Sequence\\[float\\]\\], optional): position in the world frame of the prim. shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the world frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n\n---\n**Example:**\n\n```python\n>>> # configure default state\n>>> prim.set_default_state(position=np.array([1.0, 0.5, 0.0]), orientation=np.array([1, 0, 0, 0]))\n>>>\n>>> # set default states during post-reset\n>>> prim.post_reset()\n```\n",
"snippet":"fixed_cylinder.set_default_state()\n",
"category":"method"
},
{
"title":"set_height",
"description":"Set the cylinder height\n\n**Args:**\n\n * `height` (float): cylinder height\n\n---\n**Example:**\n\n```python\n>>> prim.set_height(2.0)\n```\n",
"snippet":"fixed_cylinder.set_height(height=height)\n",
"category":"method"
},
{
"title":"set_local_pose",
"description":"Set prim's pose with respect to the local frame (the prim's parent frame).\n\n*Warning:*\nThis method will change (teleport) the prim pose immediately to the indicated value\n\n**Args:**\n\n * `translation` (Optional\\[Sequence\\[float\\]\\], optional): translation in the local frame of the prim (with respect to its parent prim). shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the local frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n\n*Hint:*\nThis method belongs to the methods used to set the prim state\n\n---\n**Example:**\n\n```python\n>>> prim.set_local_pose(translation=np.array([1.0, 0.5, 0.0]), orientation=np.array([1., 0., 0., 0.]))\n```\n",
"snippet":"fixed_cylinder.set_local_pose()\n",
"category":"method"
},
{
"title":"set_local_scale",
"description":"Set prim's scale with respect to the local frame (the prim's parent frame).\n\n**Args:**\n\n * `scale` (Optional\\[Sequence\\[float\\]\\]): scale to be applied to the prim's dimensions. shape is (3, ). Defaults to None, which means left unchanged.\n\n---\n**Example:**\n\n```python\n>>> # scale prim 10 times smaller\n>>> prim.set_local_scale(np.array([0.1, 0.1, 0.1]))\n```\n",
"snippet":"fixed_cylinder.set_local_scale(scale=scale)\n",
"category":"method"
},
{
"title":"set_min_torsional_patch_radius",
"description":"Set the minimum radius of the contact patch used to apply torsional friction\n\nSearch for *\"Torsional Patch Radius\"* in for more details\n\n**Args:**\n\n * `radius` (float): minimum radius of the contact patch used to apply torsional friction. Allowed range \\[0, max\\_float\\].\n\n---\n**Example:**\n\n```python\n>>> prim.set_min_torsional_patch_radius(0.05)\n```\n",
"snippet":"fixed_cylinder.set_min_torsional_patch_radius(radius=radius)\n",
"category":"method"
},
{
"title":"set_radius",
"description":"Set the base radius\n\n**Args:**\n\n * `radius` (float): base radius\n\n---\n**Example:**\n\n```python\n>>> prim.set_radius(1.0)\n```\n",
"snippet":"fixed_cylinder.set_radius(radius=radius)\n",
"category":"method"
},
{
"title":"set_rest_offset",
"description":"Set the rest offset\n\nTwo shapes will come to rest at a distance equal to the sum of their rest offset values.\nIf the rest offset is 0, they should converge to touching exactly\n\nSearch for *Advanced Collision Detection* in for more details\n\n*Warning:*\nThe contact offset must be positive and greater than the rest offset\n\n**Args:**\n\n * `offset` (float): Rest offset of a collision shape. Allowed range \\[-max\\_float, contact\\_offset. Default value is -inf, means default is picked by simulation. For rigid bodies its zero.\n\n---\n**Example:**\n\n```python\n>>> prim.set_rest_offset(0.01)\n```\n",
"snippet":"fixed_cylinder.set_rest_offset(offset=offset)\n",
"category":"method"
},
{
"title":"set_torsional_patch_radius",
"description":"Set the radius of the contact patch used to apply torsional friction\n\nSearch for *\"Torsional Patch Radius\"* in for more details\n\n**Args:**\n\n * `radius` (float): radius of the contact patch used to apply torsional friction. Allowed range \\[0, max\\_float\\].\n\n---\n**Example:**\n\n```python\n>>> prim.set_torsional_patch_radius(0.1)\n```\n",
"snippet":"fixed_cylinder.set_torsional_patch_radius(radius=radius)\n",
"category":"method"
},
{
"title":"set_visibility",
"description":"Set the visibility of the prim in stage\n\n**Args:**\n\n * `visible` (bool): flag to set the visibility of the usd prim in stage.\n\n---\n**Example:**\n\n```python\n>>> # make prim not visible in the stage\n>>> prim.set_visibility(visible=False)\n```\n",
"snippet":"fixed_cylinder.set_visibility(visible=visible)\n",
"category":"method"
},
{
"title":"set_world_pose",
"description":"Ses prim's pose with respect to the world's frame\n\n*Warning:*\nThis method will change (teleport) the prim pose immediately to the indicated value\n\n**Args:**\n\n * `position` (Optional\\[Sequence\\[float\\]\\], optional): position in the world frame of the prim. shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the world frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n\n*Hint:*\nThis method belongs to the methods used to set the prim state\n\n---\n**Example:**\n\n```python\n>>> prim.set_world_pose(position=np.array([1.0, 0.5, 0.0]), orientation=np.array([1., 0., 0., 0.]))\n```\n",
"snippet":"fixed_cylinder.set_world_pose()\n",
"category":"method"
}
]
},
{
"title":"FixedSphere",
"snippets":[
{
"title":"import ...",
"description":"Import class",
"snippet":"from omni.isaac.core.objects import FixedSphere\n",
"category":"import"
},
{
"title":"FixedSphere",
"description":"High level wrapper to create/encapsulate a fixed sphere\n\n*Note:*\nFixed spheres (Sphere shape) have collisions (Collider API) but no rigid body dynamics (Rigid Body API)\n\n**Args:**\n\n * `prim_path` (str): prim path of the Prim to encapsulate or create\n * `name` (str, optional): shortname to be used as a key by Scene class. Note: needs to be unique if the object is added to the Scene. Defaults to \"fixed\\_sphere\".\n * `position` (Optional\\[Sequence\\[float\\]\\], optional): position in the world frame of the prim. shape is (3, ). Defaults to None, which means left unchanged.\n * `translation` (Optional\\[Sequence\\[float\\]\\], optional): translation in the local frame of the prim (with respect to its parent prim). shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the world/ local frame of the prim (depends if translation or position is specified). quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n * `scale` (Optional\\[Sequence\\[float\\]\\], optional): local scale to be applied to the prim's dimensions. shape is (3, ). Defaults to None, which means left unchanged.\n * `visible` (bool, optional): set to false for an invisible prim in the stage while rendering. Defaults to True.\n * `color` (Optional\\[np.ndarray\\], optional): color of the visual shape. Defaults to None, which means 50% gray\n * `radius` (Optional\\[float\\], optional): sphere radius. Defaults to None.\n * `visual_material` (Optional\\[VisualMaterial\\], optional): visual material to be applied to the held prim. Defaults to None. If not specified, a default visual material will be added.\n * `physics_material` (Optional\\[PhysicsMaterial\\], optional): physics material to be applied to the held prim. Defaults to None. If not specified, a default physics material will be added.\n\n---\n**Example:**\n\n```python\n>>> from omni.isaac.core.objects import FixedSphere\n>>> import numpy as np\n>>>\n>>> # create a red fixed sphere at the given path\n>>> prim = FixedSphere(prim_path=\"/World/Xform/Sphere\", color=np.array([1.0, 0.0, 0.0]))\n>>> prim\n<omni.isaac.core.objects.sphere.FixedSphere object at 0x7f4e433f2140>\n```\n",
"snippet":"fixed_sphere = FixedSphere(prim_path=prim_path)\n",
"category":"class"
},
{
"title":"apply_physics_material",
"description":"Used to apply physics material to the held prim and optionally its descendants.\n\n**Args:**\n\n * `physics_material` (PhysicsMaterial): physics material to be applied to the held prim. This where you want to define friction, restitution..etc. Note: if a physics material is not defined, the defaults will be used from PhysX.\n * `weaker_than_descendants` (bool, optional): True if the material shouldn't override the descendants materials, otherwise False. Defaults to False.\n\n---\n**Example:**\n\n```python\n>>> from omni.isaac.core.materials import PhysicsMaterial\n>>>\n>>> # create a rigid body physical material\n>>> material = PhysicsMaterial(\n...     prim_path=\"/World/physics_material/aluminum\",  # path to the material prim to create\n...     dynamic_friction=0.4,\n...     static_friction=1.1,\n...     restitution=0.1\n... )\n>>> prim.apply_physics_material(material)\n```\n",
"snippet":"fixed_sphere.apply_physics_material(physics_material=physics_material)\n",
"category":"method"
},
{
"title":"apply_visual_material",
"description":"Apply visual material to the held prim and optionally its descendants.\n\n**Args:**\n\n * `visual_material` (VisualMaterial): visual material to be applied to the held prim. Currently supports PreviewSurface, OmniPBR and OmniGlass.\n * `weaker_than_descendants` (bool, optional): True if the material shouldn't override the descendants materials, otherwise False. Defaults to False.\n\n---\n**Example:**\n\n```python\n>>> from omni.isaac.core.materials import OmniGlass\n>>>\n>>> # create a dark-red glass visual material\n>>> material = OmniGlass(\n...     prim_path=\"/World/material/glass\",  # path to the material prim to create\n...     ior=1.25,\n...     depth=0.001,\n...     thin_walled=False,\n...     color=np.array([0.5, 0.0, 0.0])\n... )\n>>> prim.apply_visual_material(material)\n```\n",
"snippet":"fixed_sphere.apply_visual_material(visual_material=visual_material)\n",
"category":"method"
},
{
"title":"get_applied_physics_material",
"description":"Return the current applied physics material in case it was applied using apply\\_physics\\_material or not.\n\n**Returns:**\n\n * PhysicsMaterial: the current applied physics material.\n\n---\n**Example:**\n\n```python\n>>> # given a physics material applied\n>>> prim.get_applied_physics_material()\n<omni.isaac.core.materials.physics_material.PhysicsMaterial object at 0x7fb66c30cd30>\n```\n",
"snippet":"applied_physics_material = fixed_sphere.get_applied_physics_material()\n",
"category":"method"
},
{
"title":"get_applied_visual_material",
"description":"Return the current applied visual material in case it was applied using apply\\_visual\\_material\nor it's one of the following materials that was already applied before: PreviewSurface, OmniPBR and OmniGlass.\n\n**Returns:**\n\n * VisualMaterial: the current applied visual material if its type is currently supported.\n\n---\n**Example:**\n\n```python\n>>> # given a visual material applied\n>>> prim.get_applied_visual_material()\n<omni.isaac.core.materials.omni_glass.OmniGlass object at 0x7f36263106a0>\n```\n",
"snippet":"applied_visual_material = fixed_sphere.get_applied_visual_material()\n",
"category":"method"
},
{
"title":"get_collision_approximation",
"description":"Get the collision approximation\n\n| Approximation           | Full name            | Description                                                                               |\n|-------------------------|----------------------|-------------------------------------------------------------------------------------------|\n| `\"none\"`                | Triangle Mesh        | The mesh geometry is used directly as a collider without any approximation                |\n| `\"convexDecomposition\"` | Convex Decomposition | A convex mesh decomposition is performed. This results in a set of convex mesh colliders  |\n| `\"convexHull\"`          | Convex Hull          | A convex hull of the mesh is generated and used as the collider                           |\n| `\"boundingSphere\"`      | Bounding Sphere      | A bounding sphere is computed around the mesh and used as a collider                      |\n| `\"boundingCube\"`        | Bounding Cube        | An optimally fitting box collider is computed around the mesh                             |\n| `\"meshSimplification\"`  | Mesh Simplification  | A mesh simplification step is performed, resulting in a simplified triangle mesh collider |\n| `\"sdf\"`                 | SDF Mesh             | SDF (Signed-Distance-Field) use high-detail triangle meshes as collision shape            |\n| `\"sphereFill\"`          | Sphere Approximation | A sphere mesh decomposition is performed. This results in a set of sphere colliders       |\n\n**Returns:**\n\n * str: approximation used for collision\n\n---\n**Example:**\n\n```python\n>>> prim.get_collision_approximation()\nnone\n```\n",
"snippet":"collision_approximation = fixed_sphere.get_collision_approximation()\n",
"category":"method"
},
{
"title":"get_collision_enabled",
"description":"Check if the Collision API is enabled\n\n**Returns:**\n\n * bool: True if the Collision API is enabled. Otherwise False\n\n---\n**Example:**\n\n```python\n>>> prim.get_collision_enabled()\nTrue\n```\n",
"snippet":"collision_enabled = fixed_sphere.get_collision_enabled()\n",
"category":"method"
},
{
"title":"get_contact_force_matrix",
"description":"If the object is initialized with filter\\_paths\\_expr list, this method returns the contact forces between the prims\nin the view and the filter prims. i.e., a matrix of dimension (self.\\_contact\\_view.num\\_filters, 3)\nwhere num\\_filters is the determined according to the filter\\_paths\\_expr parameter.\n\n**Args:**\n\n * `dt` (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor\\]: Net contact forces of the prims with shape (self.\\_geometry\\_prim\\_view.\\_contact\\_view.num\\_filters, 3).\n",
"snippet":"contact_force_matrix = fixed_sphere.get_contact_force_matrix()\n",
"category":"method"
},
{
"title":"get_contact_offset",
"description":"Get the contact offset\n\nShapes whose distance is less than the sum of their contact offset values will generate contacts\n\nSearch for *Advanced Collision Detection* in for more details\n\n**Returns:**\n\n * float: contact offset of the collision shape. Default value is -inf, means default is picked by simulation.\n\n---\n**Example:**\n\n```python\n>>> prim.get_contact_offset()\n-inf\n```\n",
"snippet":"contact_offset = fixed_sphere.get_contact_offset()\n",
"category":"method"
},
{
"title":"get_default_state",
"description":"Get the default prim states (spatial position and orientation).\n\n**Returns:**\n\n * XFormPrimState: an object that contains the default state of the prim (position and orientation)\n\n---\n**Example:**\n\n```python\n>>> state = prim.get_default_state()\n>>> state\n<omni.isaac.core.utils.types.XFormPrimState object at 0x7f33addda650>\n>>>\n>>> state.position\n[-4.5299529e-08 -1.8347054e-09 -2.8610229e-08]\n>>> state.orientation\n[1. 0. 0. 0.]\n```\n",
"snippet":"default_state = fixed_sphere.get_default_state()\n",
"category":"method"
},
{
"title":"get_local_pose",
"description":"Get prim's pose with respect to the local frame (the prim's parent frame)\n\n**Returns:**\n\n * Tuple\\[np.ndarray, np.ndarray\\]: first index is the position in the local frame (with shape (3, )).\n    Second index is quaternion orientation (with shape (4, )) in the local frame\n\n---\n**Example:**\n\n```python\n>>> # if the prim is in position (1.0, 0.5, 0.0) with respect to the world frame\n>>> position, orientation = prim.get_local_pose()\n>>> position\n[0. 0. 0.]\n>>> orientation\n[0. 0. 0.]\n```\n",
"snippet":"local_pose = fixed_sphere.get_local_pose()\n",
"category":"method"
},
{
"title":"get_local_scale",
"description":"Get prim's scale with respect to the local frame (the parent's frame)\n\n**Returns:**\n\n * np.ndarray: scale applied to the prim's dimensions in the local frame. shape is (3, ).\n\n---\n**Example:**\n\n```python\n>>> prim.get_local_scale()\n[1. 1. 1.]\n```\n",
"snippet":"local_scale = fixed_sphere.get_local_scale()\n",
"category":"method"
},
{
"title":"get_min_torsional_patch_radius",
"description":"Get the minimum radius of the contact patch used to apply torsional friction\n\nSearch for *\"Torsional Patch Radius\"* in for more details\n\n**Returns:**\n\n * float: minimum radius of the contact patch used to apply torsional friction. Allowed range \\[0, max\\_float\\].\n\n---\n**Example:**\n\n```python\n>>> prim.get_min_torsional_patch_radius()\n0.0\n```\n",
"snippet":"min_torsional_patch_radius = fixed_sphere.get_min_torsional_patch_radius()\n",
"category":"method"
},
{
"title":"get_net_contact_forces",
"description":"If contact forces of the prims in the view are tracked, this method returns the net contact forces on prims.\ni.e., a matrix of dimension (1, 3)\n\n**Args:**\n\n * `dt` (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor\\]: Net contact forces of the prims with shape (3).\n",
"snippet":"net_contact_forces = fixed_sphere.get_net_contact_forces()\n",
"category":"method"
},
{
"title":"get_radius",
"description":"Get the sphere radius\n\n**Returns:**\n\n * float: sphere radius\n\n---\n**Example:**\n\n```python\n>>> prim.get_radius()\n1.0\n```\n",
"snippet":"radius = fixed_sphere.get_radius()\n",
"category":"method"
},
{
"title":"get_rest_offset",
"description":"Get the rest offset\n\nTwo shapes will come to rest at a distance equal to the sum of their rest offset values.\nIf the rest offset is 0, they should converge to touching exactly\n\nSearch for *Advanced Collision Detection* in for more details\n\n**Returns:**\n\n * float: rest offset of the collision shape.\n\n---\n**Example:**\n\n```python\n>>> prim.get_rest_offset()\n-inf\n```\n",
"snippet":"rest_offset = fixed_sphere.get_rest_offset()\n",
"category":"method"
},
{
"title":"get_torsional_patch_radius",
"description":"Get the radius of the contact patch used to apply torsional friction\n\nSearch for *\"Torsional Patch Radius\"* in for more details\n\n**Returns:**\n\n * float: radius of the contact patch used to apply torsional friction. Allowed range \\[0, max\\_float\\].\n\n---\n**Example:**\n\n```python\n>>> prim.get_torsional_patch_radius()\n0.0\n```\n",
"snippet":"torsional_patch_radius = fixed_sphere.get_torsional_patch_radius()\n",
"category":"method"
},
{
"title":"get_visibility",
"description":"**Returns:**\n\n * bool: true if the prim is visible in stage. false otherwise.\n\n---\n**Example:**\n\n```python\n>>> # get the visible state of an visible prim on the stage\n>>> prim.get_visibility()\nTrue\n```\n",
"snippet":"visibility = fixed_sphere.get_visibility()\n",
"category":"method"
},
{
"title":"get_world_pose",
"description":"Get prim's pose with respect to the world's frame\n\n**Returns:**\n\n * Tuple\\[np.ndarray, np.ndarray\\]: first index is the position in the world frame (with shape (3, )).\n    Second index is quaternion orientation (with shape (4, )) in the world frame\n\n---\n**Example:**\n\n```python\n>>> # if the prim is in position (1.0, 0.5, 0.0) with respect to the world frame\n>>> position, orientation = prim.get_world_pose()\n>>> position\n[1.  0.5 0. ]\n>>> orientation\n[1. 0. 0. 0.]\n```\n",
"snippet":"world_pose = fixed_sphere.get_world_pose()\n",
"category":"method"
},
{
"title":"get_world_scale",
"description":"Get prim's scale with respect to the world's frame\n\n**Returns:**\n\n * np.ndarray: scale applied to the prim's dimensions in the world frame. shape is (3, ).\n\n---\n**Example:**\n\n```python\n>>> prim.get_world_scale()\n[1. 1. 1.]\n```\n",
"snippet":"world_scale = fixed_sphere.get_world_scale()\n",
"category":"method"
},
{
"title":"initialize",
"description":"Create a physics simulation view if not passed and using PhysX tensor API\n\n*Note:*\nIf the prim has been added to the world scene (e.g., `world.scene.add(prim)`),\nit will be automatically initialized when the world is reset (e.g., `world.reset()`).\n\n**Args:**\n\n * `physics_sim_view` (omni.physics.tensors.SimulationView, optional): current physics simulation view. Defaults to None.\n\n---\n**Example:**\n\n```python\n>>> prim.initialize()\n```\n",
"snippet":"fixed_sphere.initialize()\n",
"category":"method"
},
{
"title":"is_valid",
"description":"Check if the prim path has a valid USD Prim at it\n\n**Returns:**\n\n * bool: True is the current prim path corresponds to a valid prim in stage. False otherwise.\n\n---\n**Example:**\n\n```python\n>>> # given an existing and valid prim\n>>> prims.is_valid()\nTrue\n```\n",
"snippet":"value = fixed_sphere.is_valid()\n",
"category":"method"
},
{
"title":"is_visual_material_applied",
"description":"Check if there is a visual material applied\n\n**Returns:**\n\n * bool: True if there is a visual material applied. False otherwise.\n\n---\n**Example:**\n\n```python\n>>> # given a visual material applied\n>>> prim.is_visual_material_applied()\nTrue\n```\n",
"snippet":"value = fixed_sphere.is_visual_material_applied()\n",
"category":"method"
},
{
"title":"post_reset",
"description":"Reset the prim to its default state (position and orientation).\n\n*Note:*\nFor an articulation, in addition to configuring the root prim's default position and spatial orientation\n(defined via the `set_default_state` method), the joint's positions, velocities, and efforts\n(defined via the `set_joints_default_state` method) are imposed\n\n---\n**Example:**\n\n```python\n>>> prim.post_reset()\n```\n",
"snippet":"fixed_sphere.post_reset()\n",
"category":"method"
},
{
"title":"set_collision_approximation",
"description":"Set the collision approximation\n\n| Approximation           | Full name            | Description                                                                               |\n|-------------------------|----------------------|-------------------------------------------------------------------------------------------|\n| `\"none\"`                | Triangle Mesh        | The mesh geometry is used directly as a collider without any approximation                |\n| `\"convexDecomposition\"` | Convex Decomposition | A convex mesh decomposition is performed. This results in a set of convex mesh colliders  |\n| `\"convexHull\"`          | Convex Hull          | A convex hull of the mesh is generated and used as the collider                           |\n| `\"boundingSphere\"`      | Bounding Sphere      | A bounding sphere is computed around the mesh and used as a collider                      |\n| `\"boundingCube\"`        | Bounding Cube        | An optimally fitting box collider is computed around the mesh                             |\n| `\"meshSimplification\"`  | Mesh Simplification  | A mesh simplification step is performed, resulting in a simplified triangle mesh collider |\n| `\"sdf\"`                 | SDF Mesh             | SDF (Signed-Distance-Field) use high-detail triangle meshes as collision shape            |\n| `\"sphereFill\"`          | Sphere Approximation | A sphere mesh decomposition is performed. This results in a set of sphere colliders       |\n\n*Warning:*\nSwitching to Convex Decomposition or SDF (Signed-Distance-Field) will have a simulation performance\nimpact due to higher computational cost\n\n**Args:**\n\n * `approximation_type` (str): approximation used for collision\n\n---\n**Example:**\n\n```python\n>>> prim.set_collision_approximation(\"convexDecomposition\")\n```\n",
"snippet":"fixed_sphere.set_collision_approximation(approximation_type=approximation_type)\n",
"category":"method"
},
{
"title":"set_collision_enabled",
"description":"Enable/disable the Collision API\n\n**Args:**\n\n * `enabled` (bool): Whether to enable or disable the Collision API\n\n---\n**Example:**\n\n```python\n>>> # disable collisions\n>>> prim.set_collision_enabled(False)\n```\n",
"snippet":"fixed_sphere.set_collision_enabled(enabled=enabled)\n",
"category":"method"
},
{
"title":"set_contact_offset",
"description":"Set the contact offset\n\nShapes whose distance is less than the sum of their contact offset values will generate contacts\n\nSearch for *Advanced Collision Detection* in for more details\n\n*Warning:*\nThe contact offset must be positive and greater than the rest offset\n\n**Args:**\n\n * `offset` (float): Contact offset of a collision shape. Allowed range \\[maximum(0, rest\\_offset), 0\\]. Default value is -inf, means default is picked by simulation based on the shape extent.\n\n---\n**Example:**\n\n```python\n>>> prim.set_contact_offset(0.02)\n```\n",
"snippet":"fixed_sphere.set_contact_offset(offset=offset)\n",
"category":"method"
},
{
"title":"set_default_state",
"description":"Set the default state of the prim (position and orientation), that will be used after each reset.\n\n**Args:**\n\n * `position` (Optional\\[Sequence\\[float\\]\\], optional): position in the world frame of the prim. shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the world frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n\n---\n**Example:**\n\n```python\n>>> # configure default state\n>>> prim.set_default_state(position=np.array([1.0, 0.5, 0.0]), orientation=np.array([1, 0, 0, 0]))\n>>>\n>>> # set default states during post-reset\n>>> prim.post_reset()\n```\n",
"snippet":"fixed_sphere.set_default_state()\n",
"category":"method"
},
{
"title":"set_local_pose",
"description":"Set prim's pose with respect to the local frame (the prim's parent frame).\n\n*Warning:*\nThis method will change (teleport) the prim pose immediately to the indicated value\n\n**Args:**\n\n * `translation` (Optional\\[Sequence\\[float\\]\\], optional): translation in the local frame of the prim (with respect to its parent prim). shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the local frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n\n*Hint:*\nThis method belongs to the methods used to set the prim state\n\n---\n**Example:**\n\n```python\n>>> prim.set_local_pose(translation=np.array([1.0, 0.5, 0.0]), orientation=np.array([1., 0., 0., 0.]))\n```\n",
"snippet":"fixed_sphere.set_local_pose()\n",
"category":"method"
},
{
"title":"set_local_scale",
"description":"Set prim's scale with respect to the local frame (the prim's parent frame).\n\n**Args:**\n\n * `scale` (Optional\\[Sequence\\[float\\]\\]): scale to be applied to the prim's dimensions. shape is (3, ). Defaults to None, which means left unchanged.\n\n---\n**Example:**\n\n```python\n>>> # scale prim 10 times smaller\n>>> prim.set_local_scale(np.array([0.1, 0.1, 0.1]))\n```\n",
"snippet":"fixed_sphere.set_local_scale(scale=scale)\n",
"category":"method"
},
{
"title":"set_min_torsional_patch_radius",
"description":"Set the minimum radius of the contact patch used to apply torsional friction\n\nSearch for *\"Torsional Patch Radius\"* in for more details\n\n**Args:**\n\n * `radius` (float): minimum radius of the contact patch used to apply torsional friction. Allowed range \\[0, max\\_float\\].\n\n---\n**Example:**\n\n```python\n>>> prim.set_min_torsional_patch_radius(0.05)\n```\n",
"snippet":"fixed_sphere.set_min_torsional_patch_radius(radius=radius)\n",
"category":"method"
},
{
"title":"set_radius",
"description":"Set the sphere radius\n\n**Args:**\n\n * `radius` (float): sphere radius\n\n---\n**Example:**\n\n```python\n>>> prim.set_radius(2.0)\n```\n",
"snippet":"fixed_sphere.set_radius(radius=radius)\n",
"category":"method"
},
{
"title":"set_rest_offset",
"description":"Set the rest offset\n\nTwo shapes will come to rest at a distance equal to the sum of their rest offset values.\nIf the rest offset is 0, they should converge to touching exactly\n\nSearch for *Advanced Collision Detection* in for more details\n\n*Warning:*\nThe contact offset must be positive and greater than the rest offset\n\n**Args:**\n\n * `offset` (float): Rest offset of a collision shape. Allowed range \\[-max\\_float, contact\\_offset. Default value is -inf, means default is picked by simulation. For rigid bodies its zero.\n\n---\n**Example:**\n\n```python\n>>> prim.set_rest_offset(0.01)\n```\n",
"snippet":"fixed_sphere.set_rest_offset(offset=offset)\n",
"category":"method"
},
{
"title":"set_torsional_patch_radius",
"description":"Set the radius of the contact patch used to apply torsional friction\n\nSearch for *\"Torsional Patch Radius\"* in for more details\n\n**Args:**\n\n * `radius` (float): radius of the contact patch used to apply torsional friction. Allowed range \\[0, max\\_float\\].\n\n---\n**Example:**\n\n```python\n>>> prim.set_torsional_patch_radius(0.1)\n```\n",
"snippet":"fixed_sphere.set_torsional_patch_radius(radius=radius)\n",
"category":"method"
},
{
"title":"set_visibility",
"description":"Set the visibility of the prim in stage\n\n**Args:**\n\n * `visible` (bool): flag to set the visibility of the usd prim in stage.\n\n---\n**Example:**\n\n```python\n>>> # make prim not visible in the stage\n>>> prim.set_visibility(visible=False)\n```\n",
"snippet":"fixed_sphere.set_visibility(visible=visible)\n",
"category":"method"
},
{
"title":"set_world_pose",
"description":"Ses prim's pose with respect to the world's frame\n\n*Warning:*\nThis method will change (teleport) the prim pose immediately to the indicated value\n\n**Args:**\n\n * `position` (Optional\\[Sequence\\[float\\]\\], optional): position in the world frame of the prim. shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the world frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n\n*Hint:*\nThis method belongs to the methods used to set the prim state\n\n---\n**Example:**\n\n```python\n>>> prim.set_world_pose(position=np.array([1.0, 0.5, 0.0]), orientation=np.array([1., 0., 0., 0.]))\n```\n",
"snippet":"fixed_sphere.set_world_pose()\n",
"category":"method"
}
]
},
{
"title":"GroundPlane",
"snippets":[
{
"title":"import ...",
"description":"Import class",
"snippet":"from omni.isaac.core.objects import GroundPlane\n",
"category":"import"
},
{
"title":"GroundPlane",
"description":"High level wrapper to create/encapsulate a ground plane\n\n**Args:**\n\n * `prim_path` (str): prim path of the Prim to encapsulate or create\n * `name` (str, optional): shortname to be used as a key by Scene class. Note: needs to be unique if the object is added to the Scene. Defaults to \"ground\\_plane\".\n * `size` (Optional\\[float\\], optional): length of each edge. Defaults to 5000.0.\n * `z_position` (float, optional): ground plane position in the z-axis. Defaults to 0.\n * `scale` (Optional\\[np.ndarray\\], optional): local scale to be applied to the prim's dimensions. Defaults to None.\n * `visible` (bool, optional): set to false for an invisible prim in the stage while rendering. Defaults to True.\n * `color` (Optional\\[np.ndarray\\], optional): color of the visual plane. Defaults to None.\n * `physics_material_path` (Optional\\[PhysicsMaterial\\], optional): path of the physics material to be applied to the held prim. Defaults to None. If not specified, a default physics material will be added.\n * `visual_material` (Optional\\[VisualMaterial\\], optional): visual material to be applied to the held prim. Defaults to None. If not specified, a default visual material will be added.\n * `static_friction` (float, optional): static friction coefficient. Defaults to 0.5.\n * `dynamic_friction` (float, optional): dynamic friction coefficient. Defaults to 0.5.\n * `restitution` (float, optional): restitution coefficient. Defaults to 0.8.\n\n---\n**Example:**\n\n```python\n>>> from omni.isaac.core.objects import GroundPlane\n>>> import numpy as np\n>>>\n>>> # create a ground plane placed at 0 in the z-axis\n>>> plane = GroundPlane(prim_path=\"/World/GroundPlane\", z_position=0)\n>>> plane\n<omni.isaac.core.objects.ground_plane.GroundPlane object at 0x7f15d003fb50>\n```\n",
"snippet":"ground_plane = GroundPlane(prim_path=prim_path)\n",
"category":"class"
},
{
"title":"apply_physics_material",
"description":"Used to apply physics material to the held prim and optionally its descendants.\n\n**Args:**\n\n * `physics_material` (PhysicsMaterial): physics material to be applied to the held prim. This where you want to define friction, restitution..etc. Note: if a physics material is not defined, the defaults will be used from PhysX.\n * `weaker_than_descendants` (bool, optional): True if the material shouldn't override the descendants materials, otherwise False. Defaults to False.\n\n---\n**Example:**\n\n```python\n>>> from omni.isaac.core.materials import PhysicsMaterial\n>>>\n>>> # create a rigid body physical material\n>>> material = PhysicsMaterial(\n...     prim_path=\"/World/physics_material/aluminum\",  # path to the material prim to create\n...     dynamic_friction=0.4,\n...     static_friction=1.1,\n...     restitution=0.1\n... )\n>>> plane.apply_physics_material(material)\n```\n",
"snippet":"ground_plane.apply_physics_material(physics_material=physics_material)\n",
"category":"method"
},
{
"title":"collision_geometry_prim",
"description":"**Returns:**\n\n * GeometryPrim: wrapped object as a GeometryPrim\n\n---\n**Example:**\n\n```python\n>>> plane.collision_geometry_prim\n<omni.isaac.core.prims.geometry_prim.GeometryPrim object at 0x7f15ff3461a0>\n```\n",
"snippet":"collision_geometry_prim = ground_plane.collision_geometry_prim\n",
"category":"property"
},
{
"title":"get_applied_physics_material",
"description":"Returns the current applied physics material in case it was applied using apply\\_physics\\_material or not.\n\n**Returns:**\n\n * PhysicsMaterial: the current applied physics material.\n\n---\n**Example:**\n\n```python\n>>> plane.get_applied_physics_material()\n<omni.isaac.core.materials.physics_material.PhysicsMaterial object at 0x7f517ff62920>\n```\n",
"snippet":"applied_physics_material = ground_plane.get_applied_physics_material()\n",
"category":"method"
},
{
"title":"get_default_state",
"description":"Get the default prim states (spatial position and orientation).\n\n**Returns:**\n\n * XFormPrimState: an object that contains the default state of the prim (position and orientation)\n\n---\n**Example:**\n\n```python\n>>> state = plane.get_default_state()\n>>> state\n<omni.isaac.core.utils.types.XFormPrimState object at 0x7f6efff41cf0>\n>>>\n>>> state.position\n[0. 0. 0.]\n>>> state.orientation\n[1. 0. 0. 0.]\n```\n",
"snippet":"default_state = ground_plane.get_default_state()\n",
"category":"method"
},
{
"title":"get_world_pose",
"description":"Get prim's pose with respect to the world's frame\n\n**Returns:**\n\n * Tuple\\[np.ndarray, np.ndarray\\]: first index is the position in the world frame (with shape (3, )).\n    Second index is quaternion orientation (with shape (4, )) in the world frame\n\n---\n**Example:**\n\n```python\n>>> # if the prim is in position (0.0, 0.0, 0.0) with respect to the world frame\n>>> position, orientation = prim.get_world_pose()\n>>> position\n[0. 0. 0.]\n>>> orientation\n[1. 0. 0. 0.]\n```\n",
"snippet":"world_pose = ground_plane.get_world_pose()\n",
"category":"method"
},
{
"title":"initialize",
"description":"Create a physics simulation view if not passed and using PhysX tensor API\n\n*Note:*\nIf the prim has been added to the world scene (e.g., `world.scene.add(prim)`),\nit will be automatically initialized when the world is reset (e.g., `world.reset()`).\n\n**Args:**\n\n * `physics_sim_view` (omni.physics.tensors.SimulationView, optional): current physics simulation view. Defaults to None.\n\n---\n**Example:**\n\n```python\n>>> plane.initialize()\n```\n",
"snippet":"ground_plane.initialize()\n",
"category":"method"
},
{
"title":"is_valid",
"description":"Check if the prim path has a valid USD Prim at it\n\n**Returns:**\n\n * bool: True is the current prim path corresponds to a valid prim in stage. False otherwise.\n\n---\n**Example:**\n\n```python\n>>> # given an existing and valid prim\n>>> plane.is_valid()\nTrue\n```\n",
"snippet":"value = ground_plane.is_valid()\n",
"category":"method"
},
{
"title":"name",
"description":"**Returns:**\n\n * str: name given to the prim when instantiating it. Otherwise None.\n\n---\n**Example:**\n\n```python\n>>> plane.name\nground_plane\n```\n",
"snippet":"name = ground_plane.name\n",
"category":"property"
},
{
"title":"post_reset",
"description":"Reset the prim to its default state (position and orientation).\n\n---\n**Example:**\n\n```python\n>>> plane.post_reset()\n```\n",
"snippet":"ground_plane.post_reset()\n",
"category":"method"
},
{
"title":"prim",
"description":"**Returns:**\n\n * Usd.Prim: USD Prim object that this object holds.\n\n---\n**Example:**\n\n```python\n>>> plane.prim\nUsd.Prim(</World/GroundPlane>)\n```\n",
"snippet":"prim = ground_plane.prim\n",
"category":"property"
},
{
"title":"prim_path",
"description":"**Returns:**\n\n * str: prim path in the stage.\n\n---\n**Example:**\n\n```python\n>>> plane.prim_path\n/World/GroundPlane\n```\n",
"snippet":"prim_path = ground_plane.prim_path\n",
"category":"property"
},
{
"title":"set_default_state",
"description":"Sets the default state of the prim (position and orientation), that will be used after each reset.\n\n**Args:**\n\n * `position` (Optional\\[Sequence\\[float\\]\\], optional): position in the world frame of the prim. shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the world frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n\n---\n**Example:**\n\n```python\n>>> # configure default state\n>>> plane.set_default_state(position=np.array([0.0, 0.0, -1.0]), orientation=np.array([1, 0, 0, 0]))\n>>>\n>>> # set default states during post-reset\n>>> plane.post_reset()\n```\n",
"snippet":"ground_plane.set_default_state()\n",
"category":"method"
},
{
"title":"set_world_pose",
"description":"Ses prim's pose with respect to the world's frame\n\n*Warning:*\nThis method will change (teleport) the prim pose immediately to the indicated value\n\n**Args:**\n\n * `position` (Optional\\[Sequence\\[float\\]\\], optional): position in the world frame of the prim. shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the world frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n\n*Hint:*\nThis method belongs to the methods used to set the prim state\n\n---\n**Example:**\n\n```python\n>>> plane.set_world_pose(position=np.array([0.0, 0.0, 0.5]), orientation=np.array([1., 0., 0., 0.]))\n```\n",
"snippet":"ground_plane.set_world_pose()\n",
"category":"method"
},
{
"title":"xform_prim",
"description":"**Returns:**\n\n * XFormPrim: wrapped object as a XFormPrim\n\n---\n**Example:**\n\n```python\n>>> plane.xform_prim\n<omni.isaac.core.prims.xform_prim.XFormPrim object at 0x7f1578d32560>\n```\n",
"snippet":"xform_prim = ground_plane.xform_prim\n",
"category":"property"
}
]
},
{
"title":"VisualCapsule",
"snippets":[
{
"title":"import ...",
"description":"Import class",
"snippet":"from omni.isaac.core.objects import VisualCapsule\n",
"category":"import"
},
{
"title":"VisualCapsule",
"description":"High level wrapper to create/encapsulate a visual capsule\n\n*Note:*\nVisual capsules (Capsule shape) have no collisions (Collider API) or rigid body dynamics (Rigid Body API)\n\n**Args:**\n\n * `prim_path` (str): prim path of the Prim to encapsulate or create\n * `name` (str, optional): shortname to be used as a key by Scene class. Note: needs to be unique if the object is added to the Scene. Defaults to \"visual\\_capsule\".\n * `position` (Optional\\[Sequence\\[float\\]\\], optional): position in the world frame of the prim. shape is (3, ). Defaults to None, which means left unchanged.\n * `translation` (Optional\\[Sequence\\[float\\]\\], optional): translation in the local frame of the prim (with respect to its parent prim). shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the world/ local frame of the prim (depends if translation or position is specified). quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n * `scale` (Optional\\[Sequence\\[float\\]\\], optional): local scale to be applied to the prim's dimensions. shape is (3, ). Defaults to None, which means left unchanged.\n * `visible` (bool, optional): set to false for an invisible prim in the stage while rendering. Defaults to True.\n * `color` (Optional\\[np.ndarray\\], optional): color of the visual shape. Defaults to None, which means 50% gray\n * `radius` (Optional\\[float\\], optional): capsule radius. Defaults to None.\n * `height` (Optional\\[float\\], optional): capsule height. Defaults to None.\n * `visual_material` (Optional\\[VisualMaterial\\], optional): visual material to be applied to the held prim. Defaults to None. If not specified, a default visual material will be added.\n\n---\n**Example:**\n\n```python\n>>> from omni.isaac.core.objects import VisualCapsule\n>>> import numpy as np\n>>>\n>>> # create a red visual capsule at the given path\n... prim = VisualCapsule(\n...     prim_path=\"/World/Xform/Capsule\",\n...     radius=0.5,\n...     height=1.0,\n...     color=np.array([1.0, 0.0, 0.0])\n... )\n>>> prim\n<omni.isaac.core.objects.capsule.VisualCapsule object at 0x7f4ff958b0d0>\n```\n",
"snippet":"visual_capsule = VisualCapsule(prim_path=prim_path)\n",
"category":"class"
},
{
"title":"apply_physics_material",
"description":"Used to apply physics material to the held prim and optionally its descendants.\n\n**Args:**\n\n * `physics_material` (PhysicsMaterial): physics material to be applied to the held prim. This where you want to define friction, restitution..etc. Note: if a physics material is not defined, the defaults will be used from PhysX.\n * `weaker_than_descendants` (bool, optional): True if the material shouldn't override the descendants materials, otherwise False. Defaults to False.\n\n---\n**Example:**\n\n```python\n>>> from omni.isaac.core.materials import PhysicsMaterial\n>>>\n>>> # create a rigid body physical material\n>>> material = PhysicsMaterial(\n...     prim_path=\"/World/physics_material/aluminum\",  # path to the material prim to create\n...     dynamic_friction=0.4,\n...     static_friction=1.1,\n...     restitution=0.1\n... )\n>>> prim.apply_physics_material(material)\n```\n",
"snippet":"visual_capsule.apply_physics_material(physics_material=physics_material)\n",
"category":"method"
},
{
"title":"apply_visual_material",
"description":"Apply visual material to the held prim and optionally its descendants.\n\n**Args:**\n\n * `visual_material` (VisualMaterial): visual material to be applied to the held prim. Currently supports PreviewSurface, OmniPBR and OmniGlass.\n * `weaker_than_descendants` (bool, optional): True if the material shouldn't override the descendants materials, otherwise False. Defaults to False.\n\n---\n**Example:**\n\n```python\n>>> from omni.isaac.core.materials import OmniGlass\n>>>\n>>> # create a dark-red glass visual material\n>>> material = OmniGlass(\n...     prim_path=\"/World/material/glass\",  # path to the material prim to create\n...     ior=1.25,\n...     depth=0.001,\n...     thin_walled=False,\n...     color=np.array([0.5, 0.0, 0.0])\n... )\n>>> prim.apply_visual_material(material)\n```\n",
"snippet":"visual_capsule.apply_visual_material(visual_material=visual_material)\n",
"category":"method"
},
{
"title":"get_applied_physics_material",
"description":"Return the current applied physics material in case it was applied using apply\\_physics\\_material or not.\n\n**Returns:**\n\n * PhysicsMaterial: the current applied physics material.\n\n---\n**Example:**\n\n```python\n>>> # given a physics material applied\n>>> prim.get_applied_physics_material()\n<omni.isaac.core.materials.physics_material.PhysicsMaterial object at 0x7fb66c30cd30>\n```\n",
"snippet":"applied_physics_material = visual_capsule.get_applied_physics_material()\n",
"category":"method"
},
{
"title":"get_applied_visual_material",
"description":"Return the current applied visual material in case it was applied using apply\\_visual\\_material\nor it's one of the following materials that was already applied before: PreviewSurface, OmniPBR and OmniGlass.\n\n**Returns:**\n\n * VisualMaterial: the current applied visual material if its type is currently supported.\n\n---\n**Example:**\n\n```python\n>>> # given a visual material applied\n>>> prim.get_applied_visual_material()\n<omni.isaac.core.materials.omni_glass.OmniGlass object at 0x7f36263106a0>\n```\n",
"snippet":"applied_visual_material = visual_capsule.get_applied_visual_material()\n",
"category":"method"
},
{
"title":"get_collision_approximation",
"description":"Get the collision approximation\n\n| Approximation           | Full name            | Description                                                                               |\n|-------------------------|----------------------|-------------------------------------------------------------------------------------------|\n| `\"none\"`                | Triangle Mesh        | The mesh geometry is used directly as a collider without any approximation                |\n| `\"convexDecomposition\"` | Convex Decomposition | A convex mesh decomposition is performed. This results in a set of convex mesh colliders  |\n| `\"convexHull\"`          | Convex Hull          | A convex hull of the mesh is generated and used as the collider                           |\n| `\"boundingSphere\"`      | Bounding Sphere      | A bounding sphere is computed around the mesh and used as a collider                      |\n| `\"boundingCube\"`        | Bounding Cube        | An optimally fitting box collider is computed around the mesh                             |\n| `\"meshSimplification\"`  | Mesh Simplification  | A mesh simplification step is performed, resulting in a simplified triangle mesh collider |\n| `\"sdf\"`                 | SDF Mesh             | SDF (Signed-Distance-Field) use high-detail triangle meshes as collision shape            |\n| `\"sphereFill\"`          | Sphere Approximation | A sphere mesh decomposition is performed. This results in a set of sphere colliders       |\n\n**Returns:**\n\n * str: approximation used for collision\n\n---\n**Example:**\n\n```python\n>>> prim.get_collision_approximation()\nnone\n```\n",
"snippet":"collision_approximation = visual_capsule.get_collision_approximation()\n",
"category":"method"
},
{
"title":"get_collision_enabled",
"description":"Check if the Collision API is enabled\n\n**Returns:**\n\n * bool: True if the Collision API is enabled. Otherwise False\n\n---\n**Example:**\n\n```python\n>>> prim.get_collision_enabled()\nTrue\n```\n",
"snippet":"collision_enabled = visual_capsule.get_collision_enabled()\n",
"category":"method"
},
{
"title":"get_contact_force_matrix",
"description":"If the object is initialized with filter\\_paths\\_expr list, this method returns the contact forces between the prims\nin the view and the filter prims. i.e., a matrix of dimension (self.\\_contact\\_view.num\\_filters, 3)\nwhere num\\_filters is the determined according to the filter\\_paths\\_expr parameter.\n\n**Args:**\n\n * `dt` (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor\\]: Net contact forces of the prims with shape (self.\\_geometry\\_prim\\_view.\\_contact\\_view.num\\_filters, 3).\n",
"snippet":"contact_force_matrix = visual_capsule.get_contact_force_matrix()\n",
"category":"method"
},
{
"title":"get_contact_offset",
"description":"Get the contact offset\n\nShapes whose distance is less than the sum of their contact offset values will generate contacts\n\nSearch for *Advanced Collision Detection* in for more details\n\n**Returns:**\n\n * float: contact offset of the collision shape. Default value is -inf, means default is picked by simulation.\n\n---\n**Example:**\n\n```python\n>>> prim.get_contact_offset()\n-inf\n```\n",
"snippet":"contact_offset = visual_capsule.get_contact_offset()\n",
"category":"method"
},
{
"title":"get_default_state",
"description":"Get the default prim states (spatial position and orientation).\n\n**Returns:**\n\n * XFormPrimState: an object that contains the default state of the prim (position and orientation)\n\n---\n**Example:**\n\n```python\n>>> state = prim.get_default_state()\n>>> state\n<omni.isaac.core.utils.types.XFormPrimState object at 0x7f33addda650>\n>>>\n>>> state.position\n[-4.5299529e-08 -1.8347054e-09 -2.8610229e-08]\n>>> state.orientation\n[1. 0. 0. 0.]\n```\n",
"snippet":"default_state = visual_capsule.get_default_state()\n",
"category":"method"
},
{
"title":"get_height",
"description":"Get the capsule height\n\n**Returns:**\n\n * float: capsule height\n\n---\n**Example:**\n\n```python\n>>> prim.get_height()\n1.0\n```\n",
"snippet":"height = visual_capsule.get_height()\n",
"category":"method"
},
{
"title":"get_local_pose",
"description":"Get prim's pose with respect to the local frame (the prim's parent frame)\n\n**Returns:**\n\n * Tuple\\[np.ndarray, np.ndarray\\]: first index is the position in the local frame (with shape (3, )).\n    Second index is quaternion orientation (with shape (4, )) in the local frame\n\n---\n**Example:**\n\n```python\n>>> # if the prim is in position (1.0, 0.5, 0.0) with respect to the world frame\n>>> position, orientation = prim.get_local_pose()\n>>> position\n[0. 0. 0.]\n>>> orientation\n[0. 0. 0.]\n```\n",
"snippet":"local_pose = visual_capsule.get_local_pose()\n",
"category":"method"
},
{
"title":"get_local_scale",
"description":"Get prim's scale with respect to the local frame (the parent's frame)\n\n**Returns:**\n\n * np.ndarray: scale applied to the prim's dimensions in the local frame. shape is (3, ).\n\n---\n**Example:**\n\n```python\n>>> prim.get_local_scale()\n[1. 1. 1.]\n```\n",
"snippet":"local_scale = visual_capsule.get_local_scale()\n",
"category":"method"
},
{
"title":"get_min_torsional_patch_radius",
"description":"Get the minimum radius of the contact patch used to apply torsional friction\n\nSearch for *\"Torsional Patch Radius\"* in for more details\n\n**Returns:**\n\n * float: minimum radius of the contact patch used to apply torsional friction. Allowed range \\[0, max\\_float\\].\n\n---\n**Example:**\n\n```python\n>>> prim.get_min_torsional_patch_radius()\n0.0\n```\n",
"snippet":"min_torsional_patch_radius = visual_capsule.get_min_torsional_patch_radius()\n",
"category":"method"
},
{
"title":"get_net_contact_forces",
"description":"If contact forces of the prims in the view are tracked, this method returns the net contact forces on prims.\ni.e., a matrix of dimension (1, 3)\n\n**Args:**\n\n * `dt` (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor\\]: Net contact forces of the prims with shape (3).\n",
"snippet":"net_contact_forces = visual_capsule.get_net_contact_forces()\n",
"category":"method"
},
{
"title":"get_radius",
"description":"Get the capsule radius\n\n**Returns:**\n\n * float: capsule radius\n\n---\n**Example:**\n\n```python\n>>> prim.get_radius()\n0.5\n```\n",
"snippet":"radius = visual_capsule.get_radius()\n",
"category":"method"
},
{
"title":"get_rest_offset",
"description":"Get the rest offset\n\nTwo shapes will come to rest at a distance equal to the sum of their rest offset values.\nIf the rest offset is 0, they should converge to touching exactly\n\nSearch for *Advanced Collision Detection* in for more details\n\n**Returns:**\n\n * float: rest offset of the collision shape.\n\n---\n**Example:**\n\n```python\n>>> prim.get_rest_offset()\n-inf\n```\n",
"snippet":"rest_offset = visual_capsule.get_rest_offset()\n",
"category":"method"
},
{
"title":"get_torsional_patch_radius",
"description":"Get the radius of the contact patch used to apply torsional friction\n\nSearch for *\"Torsional Patch Radius\"* in for more details\n\n**Returns:**\n\n * float: radius of the contact patch used to apply torsional friction. Allowed range \\[0, max\\_float\\].\n\n---\n**Example:**\n\n```python\n>>> prim.get_torsional_patch_radius()\n0.0\n```\n",
"snippet":"torsional_patch_radius = visual_capsule.get_torsional_patch_radius()\n",
"category":"method"
},
{
"title":"get_visibility",
"description":"**Returns:**\n\n * bool: true if the prim is visible in stage. false otherwise.\n\n---\n**Example:**\n\n```python\n>>> # get the visible state of an visible prim on the stage\n>>> prim.get_visibility()\nTrue\n```\n",
"snippet":"visibility = visual_capsule.get_visibility()\n",
"category":"method"
},
{
"title":"get_world_pose",
"description":"Get prim's pose with respect to the world's frame\n\n**Returns:**\n\n * Tuple\\[np.ndarray, np.ndarray\\]: first index is the position in the world frame (with shape (3, )).\n    Second index is quaternion orientation (with shape (4, )) in the world frame\n\n---\n**Example:**\n\n```python\n>>> # if the prim is in position (1.0, 0.5, 0.0) with respect to the world frame\n>>> position, orientation = prim.get_world_pose()\n>>> position\n[1.  0.5 0. ]\n>>> orientation\n[1. 0. 0. 0.]\n```\n",
"snippet":"world_pose = visual_capsule.get_world_pose()\n",
"category":"method"
},
{
"title":"get_world_scale",
"description":"Get prim's scale with respect to the world's frame\n\n**Returns:**\n\n * np.ndarray: scale applied to the prim's dimensions in the world frame. shape is (3, ).\n\n---\n**Example:**\n\n```python\n>>> prim.get_world_scale()\n[1. 1. 1.]\n```\n",
"snippet":"world_scale = visual_capsule.get_world_scale()\n",
"category":"method"
},
{
"title":"initialize",
"description":"Create a physics simulation view if not passed and using PhysX tensor API\n\n*Note:*\nIf the prim has been added to the world scene (e.g., `world.scene.add(prim)`),\nit will be automatically initialized when the world is reset (e.g., `world.reset()`).\n\n**Args:**\n\n * `physics_sim_view` (omni.physics.tensors.SimulationView, optional): current physics simulation view. Defaults to None.\n\n---\n**Example:**\n\n```python\n>>> prim.initialize()\n```\n",
"snippet":"visual_capsule.initialize()\n",
"category":"method"
},
{
"title":"is_valid",
"description":"Check if the prim path has a valid USD Prim at it\n\n**Returns:**\n\n * bool: True is the current prim path corresponds to a valid prim in stage. False otherwise.\n\n---\n**Example:**\n\n```python\n>>> # given an existing and valid prim\n>>> prims.is_valid()\nTrue\n```\n",
"snippet":"value = visual_capsule.is_valid()\n",
"category":"method"
},
{
"title":"is_visual_material_applied",
"description":"Check if there is a visual material applied\n\n**Returns:**\n\n * bool: True if there is a visual material applied. False otherwise.\n\n---\n**Example:**\n\n```python\n>>> # given a visual material applied\n>>> prim.is_visual_material_applied()\nTrue\n```\n",
"snippet":"value = visual_capsule.is_visual_material_applied()\n",
"category":"method"
},
{
"title":"post_reset",
"description":"Reset the prim to its default state (position and orientation).\n\n*Note:*\nFor an articulation, in addition to configuring the root prim's default position and spatial orientation\n(defined via the `set_default_state` method), the joint's positions, velocities, and efforts\n(defined via the `set_joints_default_state` method) are imposed\n\n---\n**Example:**\n\n```python\n>>> prim.post_reset()\n```\n",
"snippet":"visual_capsule.post_reset()\n",
"category":"method"
},
{
"title":"set_collision_approximation",
"description":"Set the collision approximation\n\n| Approximation           | Full name            | Description                                                                               |\n|-------------------------|----------------------|-------------------------------------------------------------------------------------------|\n| `\"none\"`                | Triangle Mesh        | The mesh geometry is used directly as a collider without any approximation                |\n| `\"convexDecomposition\"` | Convex Decomposition | A convex mesh decomposition is performed. This results in a set of convex mesh colliders  |\n| `\"convexHull\"`          | Convex Hull          | A convex hull of the mesh is generated and used as the collider                           |\n| `\"boundingSphere\"`      | Bounding Sphere      | A bounding sphere is computed around the mesh and used as a collider                      |\n| `\"boundingCube\"`        | Bounding Cube        | An optimally fitting box collider is computed around the mesh                             |\n| `\"meshSimplification\"`  | Mesh Simplification  | A mesh simplification step is performed, resulting in a simplified triangle mesh collider |\n| `\"sdf\"`                 | SDF Mesh             | SDF (Signed-Distance-Field) use high-detail triangle meshes as collision shape            |\n| `\"sphereFill\"`          | Sphere Approximation | A sphere mesh decomposition is performed. This results in a set of sphere colliders       |\n\n*Warning:*\nSwitching to Convex Decomposition or SDF (Signed-Distance-Field) will have a simulation performance\nimpact due to higher computational cost\n\n**Args:**\n\n * `approximation_type` (str): approximation used for collision\n\n---\n**Example:**\n\n```python\n>>> prim.set_collision_approximation(\"convexDecomposition\")\n```\n",
"snippet":"visual_capsule.set_collision_approximation(approximation_type=approximation_type)\n",
"category":"method"
},
{
"title":"set_collision_enabled",
"description":"Enable/disable the Collision API\n\n**Args:**\n\n * `enabled` (bool): Whether to enable or disable the Collision API\n\n---\n**Example:**\n\n```python\n>>> # disable collisions\n>>> prim.set_collision_enabled(False)\n```\n",
"snippet":"visual_capsule.set_collision_enabled(enabled=enabled)\n",
"category":"method"
},
{
"title":"set_contact_offset",
"description":"Set the contact offset\n\nShapes whose distance is less than the sum of their contact offset values will generate contacts\n\nSearch for *Advanced Collision Detection* in for more details\n\n*Warning:*\nThe contact offset must be positive and greater than the rest offset\n\n**Args:**\n\n * `offset` (float): Contact offset of a collision shape. Allowed range \\[maximum(0, rest\\_offset), 0\\]. Default value is -inf, means default is picked by simulation based on the shape extent.\n\n---\n**Example:**\n\n```python\n>>> prim.set_contact_offset(0.02)\n```\n",
"snippet":"visual_capsule.set_contact_offset(offset=offset)\n",
"category":"method"
},
{
"title":"set_default_state",
"description":"Set the default state of the prim (position and orientation), that will be used after each reset.\n\n**Args:**\n\n * `position` (Optional\\[Sequence\\[float\\]\\], optional): position in the world frame of the prim. shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the world frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n\n---\n**Example:**\n\n```python\n>>> # configure default state\n>>> prim.set_default_state(position=np.array([1.0, 0.5, 0.0]), orientation=np.array([1, 0, 0, 0]))\n>>>\n>>> # set default states during post-reset\n>>> prim.post_reset()\n```\n",
"snippet":"visual_capsule.set_default_state()\n",
"category":"method"
},
{
"title":"set_height",
"description":"Set the capsule height\n\n**Args:**\n\n * `height` (float): capsule height\n\n---\n**Example:**\n\n```python\n>>> prim.set_height(2.0)\n```\n",
"snippet":"visual_capsule.set_height(height=height)\n",
"category":"method"
},
{
"title":"set_local_pose",
"description":"Set prim's pose with respect to the local frame (the prim's parent frame).\n\n*Warning:*\nThis method will change (teleport) the prim pose immediately to the indicated value\n\n**Args:**\n\n * `translation` (Optional\\[Sequence\\[float\\]\\], optional): translation in the local frame of the prim (with respect to its parent prim). shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the local frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n\n*Hint:*\nThis method belongs to the methods used to set the prim state\n\n---\n**Example:**\n\n```python\n>>> prim.set_local_pose(translation=np.array([1.0, 0.5, 0.0]), orientation=np.array([1., 0., 0., 0.]))\n```\n",
"snippet":"visual_capsule.set_local_pose()\n",
"category":"method"
},
{
"title":"set_local_scale",
"description":"Set prim's scale with respect to the local frame (the prim's parent frame).\n\n**Args:**\n\n * `scale` (Optional\\[Sequence\\[float\\]\\]): scale to be applied to the prim's dimensions. shape is (3, ). Defaults to None, which means left unchanged.\n\n---\n**Example:**\n\n```python\n>>> # scale prim 10 times smaller\n>>> prim.set_local_scale(np.array([0.1, 0.1, 0.1]))\n```\n",
"snippet":"visual_capsule.set_local_scale(scale=scale)\n",
"category":"method"
},
{
"title":"set_min_torsional_patch_radius",
"description":"Set the minimum radius of the contact patch used to apply torsional friction\n\nSearch for *\"Torsional Patch Radius\"* in for more details\n\n**Args:**\n\n * `radius` (float): minimum radius of the contact patch used to apply torsional friction. Allowed range \\[0, max\\_float\\].\n\n---\n**Example:**\n\n```python\n>>> prim.set_min_torsional_patch_radius(0.05)\n```\n",
"snippet":"visual_capsule.set_min_torsional_patch_radius(radius=radius)\n",
"category":"method"
},
{
"title":"set_radius",
"description":"Set the capsule radius\n\n**Args:**\n\n * `radius` (float): capsule radius\n\n---\n**Example:**\n\n```python\n>>> prim.set_radius(1.0)\n```\n",
"snippet":"visual_capsule.set_radius(radius=radius)\n",
"category":"method"
},
{
"title":"set_rest_offset",
"description":"Set the rest offset\n\nTwo shapes will come to rest at a distance equal to the sum of their rest offset values.\nIf the rest offset is 0, they should converge to touching exactly\n\nSearch for *Advanced Collision Detection* in for more details\n\n*Warning:*\nThe contact offset must be positive and greater than the rest offset\n\n**Args:**\n\n * `offset` (float): Rest offset of a collision shape. Allowed range \\[-max\\_float, contact\\_offset. Default value is -inf, means default is picked by simulation. For rigid bodies its zero.\n\n---\n**Example:**\n\n```python\n>>> prim.set_rest_offset(0.01)\n```\n",
"snippet":"visual_capsule.set_rest_offset(offset=offset)\n",
"category":"method"
},
{
"title":"set_torsional_patch_radius",
"description":"Set the radius of the contact patch used to apply torsional friction\n\nSearch for *\"Torsional Patch Radius\"* in for more details\n\n**Args:**\n\n * `radius` (float): radius of the contact patch used to apply torsional friction. Allowed range \\[0, max\\_float\\].\n\n---\n**Example:**\n\n```python\n>>> prim.set_torsional_patch_radius(0.1)\n```\n",
"snippet":"visual_capsule.set_torsional_patch_radius(radius=radius)\n",
"category":"method"
},
{
"title":"set_visibility",
"description":"Set the visibility of the prim in stage\n\n**Args:**\n\n * `visible` (bool): flag to set the visibility of the usd prim in stage.\n\n---\n**Example:**\n\n```python\n>>> # make prim not visible in the stage\n>>> prim.set_visibility(visible=False)\n```\n",
"snippet":"visual_capsule.set_visibility(visible=visible)\n",
"category":"method"
},
{
"title":"set_world_pose",
"description":"Ses prim's pose with respect to the world's frame\n\n*Warning:*\nThis method will change (teleport) the prim pose immediately to the indicated value\n\n**Args:**\n\n * `position` (Optional\\[Sequence\\[float\\]\\], optional): position in the world frame of the prim. shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the world frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n\n*Hint:*\nThis method belongs to the methods used to set the prim state\n\n---\n**Example:**\n\n```python\n>>> prim.set_world_pose(position=np.array([1.0, 0.5, 0.0]), orientation=np.array([1., 0., 0., 0.]))\n```\n",
"snippet":"visual_capsule.set_world_pose()\n",
"category":"method"
}
]
},
{
"title":"VisualCone",
"snippets":[
{
"title":"import ...",
"description":"Import class",
"snippet":"from omni.isaac.core.objects import VisualCone\n",
"category":"import"
},
{
"title":"VisualCone",
"description":"High level wrapper to create/encapsulate a visual cone\n\n*Note:*\nVisual cones (Cone shape) have no collisions (Collider API) or rigid body dynamics (Rigid Body API)\n\n**Args:**\n\n * `prim_path` (str): prim path of the Prim to encapsulate or create\n * `name` (str, optional): shortname to be used as a key by Scene class. Note: needs to be unique if the object is added to the Scene. Defaults to \"visual\\_cone\".\n * `position` (Optional\\[Sequence\\[float\\]\\], optional): position in the world frame of the prim. shape is (3, ). Defaults to None, which means left unchanged.\n * `translation` (Optional\\[Sequence\\[float\\]\\], optional): translation in the local frame of the prim (with respect to its parent prim). shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the world/ local frame of the prim (depends if translation or position is specified). quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n * `scale` (Optional\\[Sequence\\[float\\]\\], optional): local scale to be applied to the prim's dimensions. shape is (3, ). Defaults to None, which means left unchanged.\n * `visible` (bool, optional): set to false for an invisible prim in the stage while rendering. Defaults to True.\n * `color` (Optional\\[np.ndarray\\], optional): color of the visual shape. Defaults to None, which means 50% gray\n * `radius` (Optional\\[float\\], optional): base radius. Defaults to None.\n * `height` (Optional\\[float\\], optional): cone height. Defaults to None.\n * `visual_material` (Optional\\[VisualMaterial\\], optional): visual material to be applied to the held prim. Defaults to None. If not specified, a default visual material will be added.\n\n---\n**Example:**\n\n```python\n>>> from omni.isaac.core.objects import VisualCone\n>>> import numpy as np\n>>>\n>>> # create a red visual cone at the given path\n>>> prim = VisualCone(\n...     prim_path=\"/World/Xform/Cone\",\n...     radius=0.5,\n...     height=1.0,\n...     color=np.array([1.0, 0.0, 0.0])\n... )\n>>> prim\n<omni.isaac.core.objects.cone.VisualCone object at 0x7f513413aa70>\n```\n",
"snippet":"visual_cone = VisualCone(prim_path=prim_path)\n",
"category":"class"
},
{
"title":"apply_physics_material",
"description":"Used to apply physics material to the held prim and optionally its descendants.\n\n**Args:**\n\n * `physics_material` (PhysicsMaterial): physics material to be applied to the held prim. This where you want to define friction, restitution..etc. Note: if a physics material is not defined, the defaults will be used from PhysX.\n * `weaker_than_descendants` (bool, optional): True if the material shouldn't override the descendants materials, otherwise False. Defaults to False.\n\n---\n**Example:**\n\n```python\n>>> from omni.isaac.core.materials import PhysicsMaterial\n>>>\n>>> # create a rigid body physical material\n>>> material = PhysicsMaterial(\n...     prim_path=\"/World/physics_material/aluminum\",  # path to the material prim to create\n...     dynamic_friction=0.4,\n...     static_friction=1.1,\n...     restitution=0.1\n... )\n>>> prim.apply_physics_material(material)\n```\n",
"snippet":"visual_cone.apply_physics_material(physics_material=physics_material)\n",
"category":"method"
},
{
"title":"apply_visual_material",
"description":"Apply visual material to the held prim and optionally its descendants.\n\n**Args:**\n\n * `visual_material` (VisualMaterial): visual material to be applied to the held prim. Currently supports PreviewSurface, OmniPBR and OmniGlass.\n * `weaker_than_descendants` (bool, optional): True if the material shouldn't override the descendants materials, otherwise False. Defaults to False.\n\n---\n**Example:**\n\n```python\n>>> from omni.isaac.core.materials import OmniGlass\n>>>\n>>> # create a dark-red glass visual material\n>>> material = OmniGlass(\n...     prim_path=\"/World/material/glass\",  # path to the material prim to create\n...     ior=1.25,\n...     depth=0.001,\n...     thin_walled=False,\n...     color=np.array([0.5, 0.0, 0.0])\n... )\n>>> prim.apply_visual_material(material)\n```\n",
"snippet":"visual_cone.apply_visual_material(visual_material=visual_material)\n",
"category":"method"
},
{
"title":"get_applied_physics_material",
"description":"Return the current applied physics material in case it was applied using apply\\_physics\\_material or not.\n\n**Returns:**\n\n * PhysicsMaterial: the current applied physics material.\n\n---\n**Example:**\n\n```python\n>>> # given a physics material applied\n>>> prim.get_applied_physics_material()\n<omni.isaac.core.materials.physics_material.PhysicsMaterial object at 0x7fb66c30cd30>\n```\n",
"snippet":"applied_physics_material = visual_cone.get_applied_physics_material()\n",
"category":"method"
},
{
"title":"get_applied_visual_material",
"description":"Return the current applied visual material in case it was applied using apply\\_visual\\_material\nor it's one of the following materials that was already applied before: PreviewSurface, OmniPBR and OmniGlass.\n\n**Returns:**\n\n * VisualMaterial: the current applied visual material if its type is currently supported.\n\n---\n**Example:**\n\n```python\n>>> # given a visual material applied\n>>> prim.get_applied_visual_material()\n<omni.isaac.core.materials.omni_glass.OmniGlass object at 0x7f36263106a0>\n```\n",
"snippet":"applied_visual_material = visual_cone.get_applied_visual_material()\n",
"category":"method"
},
{
"title":"get_collision_approximation",
"description":"Get the collision approximation\n\n| Approximation           | Full name            | Description                                                                               |\n|-------------------------|----------------------|-------------------------------------------------------------------------------------------|\n| `\"none\"`                | Triangle Mesh        | The mesh geometry is used directly as a collider without any approximation                |\n| `\"convexDecomposition\"` | Convex Decomposition | A convex mesh decomposition is performed. This results in a set of convex mesh colliders  |\n| `\"convexHull\"`          | Convex Hull          | A convex hull of the mesh is generated and used as the collider                           |\n| `\"boundingSphere\"`      | Bounding Sphere      | A bounding sphere is computed around the mesh and used as a collider                      |\n| `\"boundingCube\"`        | Bounding Cube        | An optimally fitting box collider is computed around the mesh                             |\n| `\"meshSimplification\"`  | Mesh Simplification  | A mesh simplification step is performed, resulting in a simplified triangle mesh collider |\n| `\"sdf\"`                 | SDF Mesh             | SDF (Signed-Distance-Field) use high-detail triangle meshes as collision shape            |\n| `\"sphereFill\"`          | Sphere Approximation | A sphere mesh decomposition is performed. This results in a set of sphere colliders       |\n\n**Returns:**\n\n * str: approximation used for collision\n\n---\n**Example:**\n\n```python\n>>> prim.get_collision_approximation()\nnone\n```\n",
"snippet":"collision_approximation = visual_cone.get_collision_approximation()\n",
"category":"method"
},
{
"title":"get_collision_enabled",
"description":"Check if the Collision API is enabled\n\n**Returns:**\n\n * bool: True if the Collision API is enabled. Otherwise False\n\n---\n**Example:**\n\n```python\n>>> prim.get_collision_enabled()\nTrue\n```\n",
"snippet":"collision_enabled = visual_cone.get_collision_enabled()\n",
"category":"method"
},
{
"title":"get_contact_force_matrix",
"description":"If the object is initialized with filter\\_paths\\_expr list, this method returns the contact forces between the prims\nin the view and the filter prims. i.e., a matrix of dimension (self.\\_contact\\_view.num\\_filters, 3)\nwhere num\\_filters is the determined according to the filter\\_paths\\_expr parameter.\n\n**Args:**\n\n * `dt` (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor\\]: Net contact forces of the prims with shape (self.\\_geometry\\_prim\\_view.\\_contact\\_view.num\\_filters, 3).\n",
"snippet":"contact_force_matrix = visual_cone.get_contact_force_matrix()\n",
"category":"method"
},
{
"title":"get_contact_offset",
"description":"Get the contact offset\n\nShapes whose distance is less than the sum of their contact offset values will generate contacts\n\nSearch for *Advanced Collision Detection* in for more details\n\n**Returns:**\n\n * float: contact offset of the collision shape. Default value is -inf, means default is picked by simulation.\n\n---\n**Example:**\n\n```python\n>>> prim.get_contact_offset()\n-inf\n```\n",
"snippet":"contact_offset = visual_cone.get_contact_offset()\n",
"category":"method"
},
{
"title":"get_default_state",
"description":"Get the default prim states (spatial position and orientation).\n\n**Returns:**\n\n * XFormPrimState: an object that contains the default state of the prim (position and orientation)\n\n---\n**Example:**\n\n```python\n>>> state = prim.get_default_state()\n>>> state\n<omni.isaac.core.utils.types.XFormPrimState object at 0x7f33addda650>\n>>>\n>>> state.position\n[-4.5299529e-08 -1.8347054e-09 -2.8610229e-08]\n>>> state.orientation\n[1. 0. 0. 0.]\n```\n",
"snippet":"default_state = visual_cone.get_default_state()\n",
"category":"method"
},
{
"title":"get_height",
"description":"Get the cone height\n\n**Returns:**\n\n * float: cone height\n\n---\n**Example:**\n\n```python\n>>> prim.get_height()\n1.0\n```\n",
"snippet":"height = visual_cone.get_height()\n",
"category":"method"
},
{
"title":"get_local_pose",
"description":"Get prim's pose with respect to the local frame (the prim's parent frame)\n\n**Returns:**\n\n * Tuple\\[np.ndarray, np.ndarray\\]: first index is the position in the local frame (with shape (3, )).\n    Second index is quaternion orientation (with shape (4, )) in the local frame\n\n---\n**Example:**\n\n```python\n>>> # if the prim is in position (1.0, 0.5, 0.0) with respect to the world frame\n>>> position, orientation = prim.get_local_pose()\n>>> position\n[0. 0. 0.]\n>>> orientation\n[0. 0. 0.]\n```\n",
"snippet":"local_pose = visual_cone.get_local_pose()\n",
"category":"method"
},
{
"title":"get_local_scale",
"description":"Get prim's scale with respect to the local frame (the parent's frame)\n\n**Returns:**\n\n * np.ndarray: scale applied to the prim's dimensions in the local frame. shape is (3, ).\n\n---\n**Example:**\n\n```python\n>>> prim.get_local_scale()\n[1. 1. 1.]\n```\n",
"snippet":"local_scale = visual_cone.get_local_scale()\n",
"category":"method"
},
{
"title":"get_min_torsional_patch_radius",
"description":"Get the minimum radius of the contact patch used to apply torsional friction\n\nSearch for *\"Torsional Patch Radius\"* in for more details\n\n**Returns:**\n\n * float: minimum radius of the contact patch used to apply torsional friction. Allowed range \\[0, max\\_float\\].\n\n---\n**Example:**\n\n```python\n>>> prim.get_min_torsional_patch_radius()\n0.0\n```\n",
"snippet":"min_torsional_patch_radius = visual_cone.get_min_torsional_patch_radius()\n",
"category":"method"
},
{
"title":"get_net_contact_forces",
"description":"If contact forces of the prims in the view are tracked, this method returns the net contact forces on prims.\ni.e., a matrix of dimension (1, 3)\n\n**Args:**\n\n * `dt` (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor\\]: Net contact forces of the prims with shape (3).\n",
"snippet":"net_contact_forces = visual_cone.get_net_contact_forces()\n",
"category":"method"
},
{
"title":"get_radius",
"description":"Get the base radius\n\n**Returns:**\n\n * float: base radius\n\n---\n**Example:**\n\n```python\n>>> prim.get_radius()\n0.5\n```\n",
"snippet":"radius = visual_cone.get_radius()\n",
"category":"method"
},
{
"title":"get_rest_offset",
"description":"Get the rest offset\n\nTwo shapes will come to rest at a distance equal to the sum of their rest offset values.\nIf the rest offset is 0, they should converge to touching exactly\n\nSearch for *Advanced Collision Detection* in for more details\n\n**Returns:**\n\n * float: rest offset of the collision shape.\n\n---\n**Example:**\n\n```python\n>>> prim.get_rest_offset()\n-inf\n```\n",
"snippet":"rest_offset = visual_cone.get_rest_offset()\n",
"category":"method"
},
{
"title":"get_torsional_patch_radius",
"description":"Get the radius of the contact patch used to apply torsional friction\n\nSearch for *\"Torsional Patch Radius\"* in for more details\n\n**Returns:**\n\n * float: radius of the contact patch used to apply torsional friction. Allowed range \\[0, max\\_float\\].\n\n---\n**Example:**\n\n```python\n>>> prim.get_torsional_patch_radius()\n0.0\n```\n",
"snippet":"torsional_patch_radius = visual_cone.get_torsional_patch_radius()\n",
"category":"method"
},
{
"title":"get_visibility",
"description":"**Returns:**\n\n * bool: true if the prim is visible in stage. false otherwise.\n\n---\n**Example:**\n\n```python\n>>> # get the visible state of an visible prim on the stage\n>>> prim.get_visibility()\nTrue\n```\n",
"snippet":"visibility = visual_cone.get_visibility()\n",
"category":"method"
},
{
"title":"get_world_pose",
"description":"Get prim's pose with respect to the world's frame\n\n**Returns:**\n\n * Tuple\\[np.ndarray, np.ndarray\\]: first index is the position in the world frame (with shape (3, )).\n    Second index is quaternion orientation (with shape (4, )) in the world frame\n\n---\n**Example:**\n\n```python\n>>> # if the prim is in position (1.0, 0.5, 0.0) with respect to the world frame\n>>> position, orientation = prim.get_world_pose()\n>>> position\n[1.  0.5 0. ]\n>>> orientation\n[1. 0. 0. 0.]\n```\n",
"snippet":"world_pose = visual_cone.get_world_pose()\n",
"category":"method"
},
{
"title":"get_world_scale",
"description":"Get prim's scale with respect to the world's frame\n\n**Returns:**\n\n * np.ndarray: scale applied to the prim's dimensions in the world frame. shape is (3, ).\n\n---\n**Example:**\n\n```python\n>>> prim.get_world_scale()\n[1. 1. 1.]\n```\n",
"snippet":"world_scale = visual_cone.get_world_scale()\n",
"category":"method"
},
{
"title":"initialize",
"description":"Create a physics simulation view if not passed and using PhysX tensor API\n\n*Note:*\nIf the prim has been added to the world scene (e.g., `world.scene.add(prim)`),\nit will be automatically initialized when the world is reset (e.g., `world.reset()`).\n\n**Args:**\n\n * `physics_sim_view` (omni.physics.tensors.SimulationView, optional): current physics simulation view. Defaults to None.\n\n---\n**Example:**\n\n```python\n>>> prim.initialize()\n```\n",
"snippet":"visual_cone.initialize()\n",
"category":"method"
},
{
"title":"is_valid",
"description":"Check if the prim path has a valid USD Prim at it\n\n**Returns:**\n\n * bool: True is the current prim path corresponds to a valid prim in stage. False otherwise.\n\n---\n**Example:**\n\n```python\n>>> # given an existing and valid prim\n>>> prims.is_valid()\nTrue\n```\n",
"snippet":"value = visual_cone.is_valid()\n",
"category":"method"
},
{
"title":"is_visual_material_applied",
"description":"Check if there is a visual material applied\n\n**Returns:**\n\n * bool: True if there is a visual material applied. False otherwise.\n\n---\n**Example:**\n\n```python\n>>> # given a visual material applied\n>>> prim.is_visual_material_applied()\nTrue\n```\n",
"snippet":"value = visual_cone.is_visual_material_applied()\n",
"category":"method"
},
{
"title":"post_reset",
"description":"Reset the prim to its default state (position and orientation).\n\n*Note:*\nFor an articulation, in addition to configuring the root prim's default position and spatial orientation\n(defined via the `set_default_state` method), the joint's positions, velocities, and efforts\n(defined via the `set_joints_default_state` method) are imposed\n\n---\n**Example:**\n\n```python\n>>> prim.post_reset()\n```\n",
"snippet":"visual_cone.post_reset()\n",
"category":"method"
},
{
"title":"set_collision_approximation",
"description":"Set the collision approximation\n\n| Approximation           | Full name            | Description                                                                               |\n|-------------------------|----------------------|-------------------------------------------------------------------------------------------|\n| `\"none\"`                | Triangle Mesh        | The mesh geometry is used directly as a collider without any approximation                |\n| `\"convexDecomposition\"` | Convex Decomposition | A convex mesh decomposition is performed. This results in a set of convex mesh colliders  |\n| `\"convexHull\"`          | Convex Hull          | A convex hull of the mesh is generated and used as the collider                           |\n| `\"boundingSphere\"`      | Bounding Sphere      | A bounding sphere is computed around the mesh and used as a collider                      |\n| `\"boundingCube\"`        | Bounding Cube        | An optimally fitting box collider is computed around the mesh                             |\n| `\"meshSimplification\"`  | Mesh Simplification  | A mesh simplification step is performed, resulting in a simplified triangle mesh collider |\n| `\"sdf\"`                 | SDF Mesh             | SDF (Signed-Distance-Field) use high-detail triangle meshes as collision shape            |\n| `\"sphereFill\"`          | Sphere Approximation | A sphere mesh decomposition is performed. This results in a set of sphere colliders       |\n\n*Warning:*\nSwitching to Convex Decomposition or SDF (Signed-Distance-Field) will have a simulation performance\nimpact due to higher computational cost\n\n**Args:**\n\n * `approximation_type` (str): approximation used for collision\n\n---\n**Example:**\n\n```python\n>>> prim.set_collision_approximation(\"convexDecomposition\")\n```\n",
"snippet":"visual_cone.set_collision_approximation(approximation_type=approximation_type)\n",
"category":"method"
},
{
"title":"set_collision_enabled",
"description":"Enable/disable the Collision API\n\n**Args:**\n\n * `enabled` (bool): Whether to enable or disable the Collision API\n\n---\n**Example:**\n\n```python\n>>> # disable collisions\n>>> prim.set_collision_enabled(False)\n```\n",
"snippet":"visual_cone.set_collision_enabled(enabled=enabled)\n",
"category":"method"
},
{
"title":"set_contact_offset",
"description":"Set the contact offset\n\nShapes whose distance is less than the sum of their contact offset values will generate contacts\n\nSearch for *Advanced Collision Detection* in for more details\n\n*Warning:*\nThe contact offset must be positive and greater than the rest offset\n\n**Args:**\n\n * `offset` (float): Contact offset of a collision shape. Allowed range \\[maximum(0, rest\\_offset), 0\\]. Default value is -inf, means default is picked by simulation based on the shape extent.\n\n---\n**Example:**\n\n```python\n>>> prim.set_contact_offset(0.02)\n```\n",
"snippet":"visual_cone.set_contact_offset(offset=offset)\n",
"category":"method"
},
{
"title":"set_default_state",
"description":"Set the default state of the prim (position and orientation), that will be used after each reset.\n\n**Args:**\n\n * `position` (Optional\\[Sequence\\[float\\]\\], optional): position in the world frame of the prim. shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the world frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n\n---\n**Example:**\n\n```python\n>>> # configure default state\n>>> prim.set_default_state(position=np.array([1.0, 0.5, 0.0]), orientation=np.array([1, 0, 0, 0]))\n>>>\n>>> # set default states during post-reset\n>>> prim.post_reset()\n```\n",
"snippet":"visual_cone.set_default_state()\n",
"category":"method"
},
{
"title":"set_height",
"description":"Set the cone height\n\n**Args:**\n\n * `height` (float): cone height\n\n---\n**Example:**\n\n```python\n>>> prim.set_height(2.0)\n```\n",
"snippet":"visual_cone.set_height(height=height)\n",
"category":"method"
},
{
"title":"set_local_pose",
"description":"Set prim's pose with respect to the local frame (the prim's parent frame).\n\n*Warning:*\nThis method will change (teleport) the prim pose immediately to the indicated value\n\n**Args:**\n\n * `translation` (Optional\\[Sequence\\[float\\]\\], optional): translation in the local frame of the prim (with respect to its parent prim). shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the local frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n\n*Hint:*\nThis method belongs to the methods used to set the prim state\n\n---\n**Example:**\n\n```python\n>>> prim.set_local_pose(translation=np.array([1.0, 0.5, 0.0]), orientation=np.array([1., 0., 0., 0.]))\n```\n",
"snippet":"visual_cone.set_local_pose()\n",
"category":"method"
},
{
"title":"set_local_scale",
"description":"Set prim's scale with respect to the local frame (the prim's parent frame).\n\n**Args:**\n\n * `scale` (Optional\\[Sequence\\[float\\]\\]): scale to be applied to the prim's dimensions. shape is (3, ). Defaults to None, which means left unchanged.\n\n---\n**Example:**\n\n```python\n>>> # scale prim 10 times smaller\n>>> prim.set_local_scale(np.array([0.1, 0.1, 0.1]))\n```\n",
"snippet":"visual_cone.set_local_scale(scale=scale)\n",
"category":"method"
},
{
"title":"set_min_torsional_patch_radius",
"description":"Set the minimum radius of the contact patch used to apply torsional friction\n\nSearch for *\"Torsional Patch Radius\"* in for more details\n\n**Args:**\n\n * `radius` (float): minimum radius of the contact patch used to apply torsional friction. Allowed range \\[0, max\\_float\\].\n\n---\n**Example:**\n\n```python\n>>> prim.set_min_torsional_patch_radius(0.05)\n```\n",
"snippet":"visual_cone.set_min_torsional_patch_radius(radius=radius)\n",
"category":"method"
},
{
"title":"set_radius",
"description":"Set the base radius\n\n**Args:**\n\n * `radius` (float): base radius\n\n---\n**Example:**\n\n```python\n>>> prim.set_radius(1.0)\n```\n",
"snippet":"visual_cone.set_radius(radius=radius)\n",
"category":"method"
},
{
"title":"set_rest_offset",
"description":"Set the rest offset\n\nTwo shapes will come to rest at a distance equal to the sum of their rest offset values.\nIf the rest offset is 0, they should converge to touching exactly\n\nSearch for *Advanced Collision Detection* in for more details\n\n*Warning:*\nThe contact offset must be positive and greater than the rest offset\n\n**Args:**\n\n * `offset` (float): Rest offset of a collision shape. Allowed range \\[-max\\_float, contact\\_offset. Default value is -inf, means default is picked by simulation. For rigid bodies its zero.\n\n---\n**Example:**\n\n```python\n>>> prim.set_rest_offset(0.01)\n```\n",
"snippet":"visual_cone.set_rest_offset(offset=offset)\n",
"category":"method"
},
{
"title":"set_torsional_patch_radius",
"description":"Set the radius of the contact patch used to apply torsional friction\n\nSearch for *\"Torsional Patch Radius\"* in for more details\n\n**Args:**\n\n * `radius` (float): radius of the contact patch used to apply torsional friction. Allowed range \\[0, max\\_float\\].\n\n---\n**Example:**\n\n```python\n>>> prim.set_torsional_patch_radius(0.1)\n```\n",
"snippet":"visual_cone.set_torsional_patch_radius(radius=radius)\n",
"category":"method"
},
{
"title":"set_visibility",
"description":"Set the visibility of the prim in stage\n\n**Args:**\n\n * `visible` (bool): flag to set the visibility of the usd prim in stage.\n\n---\n**Example:**\n\n```python\n>>> # make prim not visible in the stage\n>>> prim.set_visibility(visible=False)\n```\n",
"snippet":"visual_cone.set_visibility(visible=visible)\n",
"category":"method"
},
{
"title":"set_world_pose",
"description":"Ses prim's pose with respect to the world's frame\n\n*Warning:*\nThis method will change (teleport) the prim pose immediately to the indicated value\n\n**Args:**\n\n * `position` (Optional\\[Sequence\\[float\\]\\], optional): position in the world frame of the prim. shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the world frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n\n*Hint:*\nThis method belongs to the methods used to set the prim state\n\n---\n**Example:**\n\n```python\n>>> prim.set_world_pose(position=np.array([1.0, 0.5, 0.0]), orientation=np.array([1., 0., 0., 0.]))\n```\n",
"snippet":"visual_cone.set_world_pose()\n",
"category":"method"
}
]
},
{
"title":"VisualCuboid",
"snippets":[
{
"title":"import ...",
"description":"Import class",
"snippet":"from omni.isaac.core.objects import VisualCuboid\n",
"category":"import"
},
{
"title":"VisualCuboid",
"description":"High level wrapper to create/encapsulate a visual cuboid\n\n*Note:*\nVisual cuboids (Cube shape) have no collisions (Collider API) or rigid body dynamics (Rigid Body API)\n\n**Args:**\n\n * `prim_path` (str): prim path of the Prim to encapsulate or create\n * `name` (str, optional): shortname to be used as a key by Scene class. Note: needs to be unique if the object is added to the Scene. Defaults to \"visual\\_cube\".\n * `position` (Optional\\[Sequence\\[float\\]\\], optional): position in the world frame of the prim. shape is (3, ). Defaults to None, which means left unchanged.\n * `translation` (Optional\\[Sequence\\[float\\]\\], optional): translation in the local frame of the prim (with respect to its parent prim). shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the world/ local frame of the prim (depends if translation or position is specified). quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n * `scale` (Optional\\[Sequence\\[float\\]\\], optional): local scale to be applied to the prim's dimensions. shape is (3, ). Defaults to None, which means left unchanged.\n * `visible` (bool, optional): set to false for an invisible prim in the stage while rendering. Defaults to True.\n * `color` (Optional\\[np.ndarray\\], optional): color of the visual shape. Defaults to None, which means 50% gray\n * `size` (Optional\\[float\\], optional): length of each cube edge. Defaults to None.\n * `visual_material` (Optional\\[VisualMaterial\\], optional): visual material to be applied to the held prim. Defaults to None. If not specified, a default visual material will be added.\n\n---\n**Example:**\n\n```python\n>>> from omni.isaac.core.objects import VisualCuboid\n>>> import numpy as np\n>>>\n>>> # create a red visual cube at the given path\n>>> prim = VisualCuboid(prim_path=\"/World/Xform/Cube\", color=np.array([1.0, 0.0, 0.0]))\n>>> prim\n<omni.isaac.core.objects.cuboid.VisualCuboid object at 0x7f12e756fa00>\n```\n",
"snippet":"visual_cuboid = VisualCuboid(prim_path=prim_path)\n",
"category":"class"
},
{
"title":"apply_physics_material",
"description":"Used to apply physics material to the held prim and optionally its descendants.\n\n**Args:**\n\n * `physics_material` (PhysicsMaterial): physics material to be applied to the held prim. This where you want to define friction, restitution..etc. Note: if a physics material is not defined, the defaults will be used from PhysX.\n * `weaker_than_descendants` (bool, optional): True if the material shouldn't override the descendants materials, otherwise False. Defaults to False.\n\n---\n**Example:**\n\n```python\n>>> from omni.isaac.core.materials import PhysicsMaterial\n>>>\n>>> # create a rigid body physical material\n>>> material = PhysicsMaterial(\n...     prim_path=\"/World/physics_material/aluminum\",  # path to the material prim to create\n...     dynamic_friction=0.4,\n...     static_friction=1.1,\n...     restitution=0.1\n... )\n>>> prim.apply_physics_material(material)\n```\n",
"snippet":"visual_cuboid.apply_physics_material(physics_material=physics_material)\n",
"category":"method"
},
{
"title":"apply_visual_material",
"description":"Apply visual material to the held prim and optionally its descendants.\n\n**Args:**\n\n * `visual_material` (VisualMaterial): visual material to be applied to the held prim. Currently supports PreviewSurface, OmniPBR and OmniGlass.\n * `weaker_than_descendants` (bool, optional): True if the material shouldn't override the descendants materials, otherwise False. Defaults to False.\n\n---\n**Example:**\n\n```python\n>>> from omni.isaac.core.materials import OmniGlass\n>>>\n>>> # create a dark-red glass visual material\n>>> material = OmniGlass(\n...     prim_path=\"/World/material/glass\",  # path to the material prim to create\n...     ior=1.25,\n...     depth=0.001,\n...     thin_walled=False,\n...     color=np.array([0.5, 0.0, 0.0])\n... )\n>>> prim.apply_visual_material(material)\n```\n",
"snippet":"visual_cuboid.apply_visual_material(visual_material=visual_material)\n",
"category":"method"
},
{
"title":"get_applied_physics_material",
"description":"Return the current applied physics material in case it was applied using apply\\_physics\\_material or not.\n\n**Returns:**\n\n * PhysicsMaterial: the current applied physics material.\n\n---\n**Example:**\n\n```python\n>>> # given a physics material applied\n>>> prim.get_applied_physics_material()\n<omni.isaac.core.materials.physics_material.PhysicsMaterial object at 0x7fb66c30cd30>\n```\n",
"snippet":"applied_physics_material = visual_cuboid.get_applied_physics_material()\n",
"category":"method"
},
{
"title":"get_applied_visual_material",
"description":"Return the current applied visual material in case it was applied using apply\\_visual\\_material\nor it's one of the following materials that was already applied before: PreviewSurface, OmniPBR and OmniGlass.\n\n**Returns:**\n\n * VisualMaterial: the current applied visual material if its type is currently supported.\n\n---\n**Example:**\n\n```python\n>>> # given a visual material applied\n>>> prim.get_applied_visual_material()\n<omni.isaac.core.materials.omni_glass.OmniGlass object at 0x7f36263106a0>\n```\n",
"snippet":"applied_visual_material = visual_cuboid.get_applied_visual_material()\n",
"category":"method"
},
{
"title":"get_collision_approximation",
"description":"Get the collision approximation\n\n| Approximation           | Full name            | Description                                                                               |\n|-------------------------|----------------------|-------------------------------------------------------------------------------------------|\n| `\"none\"`                | Triangle Mesh        | The mesh geometry is used directly as a collider without any approximation                |\n| `\"convexDecomposition\"` | Convex Decomposition | A convex mesh decomposition is performed. This results in a set of convex mesh colliders  |\n| `\"convexHull\"`          | Convex Hull          | A convex hull of the mesh is generated and used as the collider                           |\n| `\"boundingSphere\"`      | Bounding Sphere      | A bounding sphere is computed around the mesh and used as a collider                      |\n| `\"boundingCube\"`        | Bounding Cube        | An optimally fitting box collider is computed around the mesh                             |\n| `\"meshSimplification\"`  | Mesh Simplification  | A mesh simplification step is performed, resulting in a simplified triangle mesh collider |\n| `\"sdf\"`                 | SDF Mesh             | SDF (Signed-Distance-Field) use high-detail triangle meshes as collision shape            |\n| `\"sphereFill\"`          | Sphere Approximation | A sphere mesh decomposition is performed. This results in a set of sphere colliders       |\n\n**Returns:**\n\n * str: approximation used for collision\n\n---\n**Example:**\n\n```python\n>>> prim.get_collision_approximation()\nnone\n```\n",
"snippet":"collision_approximation = visual_cuboid.get_collision_approximation()\n",
"category":"method"
},
{
"title":"get_collision_enabled",
"description":"Check if the Collision API is enabled\n\n**Returns:**\n\n * bool: True if the Collision API is enabled. Otherwise False\n\n---\n**Example:**\n\n```python\n>>> prim.get_collision_enabled()\nTrue\n```\n",
"snippet":"collision_enabled = visual_cuboid.get_collision_enabled()\n",
"category":"method"
},
{
"title":"get_contact_force_matrix",
"description":"If the object is initialized with filter\\_paths\\_expr list, this method returns the contact forces between the prims\nin the view and the filter prims. i.e., a matrix of dimension (self.\\_contact\\_view.num\\_filters, 3)\nwhere num\\_filters is the determined according to the filter\\_paths\\_expr parameter.\n\n**Args:**\n\n * `dt` (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor\\]: Net contact forces of the prims with shape (self.\\_geometry\\_prim\\_view.\\_contact\\_view.num\\_filters, 3).\n",
"snippet":"contact_force_matrix = visual_cuboid.get_contact_force_matrix()\n",
"category":"method"
},
{
"title":"get_contact_offset",
"description":"Get the contact offset\n\nShapes whose distance is less than the sum of their contact offset values will generate contacts\n\nSearch for *Advanced Collision Detection* in for more details\n\n**Returns:**\n\n * float: contact offset of the collision shape. Default value is -inf, means default is picked by simulation.\n\n---\n**Example:**\n\n```python\n>>> prim.get_contact_offset()\n-inf\n```\n",
"snippet":"contact_offset = visual_cuboid.get_contact_offset()\n",
"category":"method"
},
{
"title":"get_default_state",
"description":"Get the default prim states (spatial position and orientation).\n\n**Returns:**\n\n * XFormPrimState: an object that contains the default state of the prim (position and orientation)\n\n---\n**Example:**\n\n```python\n>>> state = prim.get_default_state()\n>>> state\n<omni.isaac.core.utils.types.XFormPrimState object at 0x7f33addda650>\n>>>\n>>> state.position\n[-4.5299529e-08 -1.8347054e-09 -2.8610229e-08]\n>>> state.orientation\n[1. 0. 0. 0.]\n```\n",
"snippet":"default_state = visual_cuboid.get_default_state()\n",
"category":"method"
},
{
"title":"get_local_pose",
"description":"Get prim's pose with respect to the local frame (the prim's parent frame)\n\n**Returns:**\n\n * Tuple\\[np.ndarray, np.ndarray\\]: first index is the position in the local frame (with shape (3, )).\n    Second index is quaternion orientation (with shape (4, )) in the local frame\n\n---\n**Example:**\n\n```python\n>>> # if the prim is in position (1.0, 0.5, 0.0) with respect to the world frame\n>>> position, orientation = prim.get_local_pose()\n>>> position\n[0. 0. 0.]\n>>> orientation\n[0. 0. 0.]\n```\n",
"snippet":"local_pose = visual_cuboid.get_local_pose()\n",
"category":"method"
},
{
"title":"get_local_scale",
"description":"Get prim's scale with respect to the local frame (the parent's frame)\n\n**Returns:**\n\n * np.ndarray: scale applied to the prim's dimensions in the local frame. shape is (3, ).\n\n---\n**Example:**\n\n```python\n>>> prim.get_local_scale()\n[1. 1. 1.]\n```\n",
"snippet":"local_scale = visual_cuboid.get_local_scale()\n",
"category":"method"
},
{
"title":"get_min_torsional_patch_radius",
"description":"Get the minimum radius of the contact patch used to apply torsional friction\n\nSearch for *\"Torsional Patch Radius\"* in for more details\n\n**Returns:**\n\n * float: minimum radius of the contact patch used to apply torsional friction. Allowed range \\[0, max\\_float\\].\n\n---\n**Example:**\n\n```python\n>>> prim.get_min_torsional_patch_radius()\n0.0\n```\n",
"snippet":"min_torsional_patch_radius = visual_cuboid.get_min_torsional_patch_radius()\n",
"category":"method"
},
{
"title":"get_net_contact_forces",
"description":"If contact forces of the prims in the view are tracked, this method returns the net contact forces on prims.\ni.e., a matrix of dimension (1, 3)\n\n**Args:**\n\n * `dt` (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor\\]: Net contact forces of the prims with shape (3).\n",
"snippet":"net_contact_forces = visual_cuboid.get_net_contact_forces()\n",
"category":"method"
},
{
"title":"get_rest_offset",
"description":"Get the rest offset\n\nTwo shapes will come to rest at a distance equal to the sum of their rest offset values.\nIf the rest offset is 0, they should converge to touching exactly\n\nSearch for *Advanced Collision Detection* in for more details\n\n**Returns:**\n\n * float: rest offset of the collision shape.\n\n---\n**Example:**\n\n```python\n>>> prim.get_rest_offset()\n-inf\n```\n",
"snippet":"rest_offset = visual_cuboid.get_rest_offset()\n",
"category":"method"
},
{
"title":"get_size",
"description":"Get the length of each cube edge\n\n**Returns:**\n\n * float: edge length\n\n---\n**Example:**\n\n```python\n>>> prim.get_size()\n1.0\n```\n",
"snippet":"size = visual_cuboid.get_size()\n",
"category":"method"
},
{
"title":"get_torsional_patch_radius",
"description":"Get the radius of the contact patch used to apply torsional friction\n\nSearch for *\"Torsional Patch Radius\"* in for more details\n\n**Returns:**\n\n * float: radius of the contact patch used to apply torsional friction. Allowed range \\[0, max\\_float\\].\n\n---\n**Example:**\n\n```python\n>>> prim.get_torsional_patch_radius()\n0.0\n```\n",
"snippet":"torsional_patch_radius = visual_cuboid.get_torsional_patch_radius()\n",
"category":"method"
},
{
"title":"get_visibility",
"description":"**Returns:**\n\n * bool: true if the prim is visible in stage. false otherwise.\n\n---\n**Example:**\n\n```python\n>>> # get the visible state of an visible prim on the stage\n>>> prim.get_visibility()\nTrue\n```\n",
"snippet":"visibility = visual_cuboid.get_visibility()\n",
"category":"method"
},
{
"title":"get_world_pose",
"description":"Get prim's pose with respect to the world's frame\n\n**Returns:**\n\n * Tuple\\[np.ndarray, np.ndarray\\]: first index is the position in the world frame (with shape (3, )).\n    Second index is quaternion orientation (with shape (4, )) in the world frame\n\n---\n**Example:**\n\n```python\n>>> # if the prim is in position (1.0, 0.5, 0.0) with respect to the world frame\n>>> position, orientation = prim.get_world_pose()\n>>> position\n[1.  0.5 0. ]\n>>> orientation\n[1. 0. 0. 0.]\n```\n",
"snippet":"world_pose = visual_cuboid.get_world_pose()\n",
"category":"method"
},
{
"title":"get_world_scale",
"description":"Get prim's scale with respect to the world's frame\n\n**Returns:**\n\n * np.ndarray: scale applied to the prim's dimensions in the world frame. shape is (3, ).\n\n---\n**Example:**\n\n```python\n>>> prim.get_world_scale()\n[1. 1. 1.]\n```\n",
"snippet":"world_scale = visual_cuboid.get_world_scale()\n",
"category":"method"
},
{
"title":"initialize",
"description":"Create a physics simulation view if not passed and using PhysX tensor API\n\n*Note:*\nIf the prim has been added to the world scene (e.g., `world.scene.add(prim)`),\nit will be automatically initialized when the world is reset (e.g., `world.reset()`).\n\n**Args:**\n\n * `physics_sim_view` (omni.physics.tensors.SimulationView, optional): current physics simulation view. Defaults to None.\n\n---\n**Example:**\n\n```python\n>>> prim.initialize()\n```\n",
"snippet":"visual_cuboid.initialize()\n",
"category":"method"
},
{
"title":"is_valid",
"description":"Check if the prim path has a valid USD Prim at it\n\n**Returns:**\n\n * bool: True is the current prim path corresponds to a valid prim in stage. False otherwise.\n\n---\n**Example:**\n\n```python\n>>> # given an existing and valid prim\n>>> prims.is_valid()\nTrue\n```\n",
"snippet":"value = visual_cuboid.is_valid()\n",
"category":"method"
},
{
"title":"is_visual_material_applied",
"description":"Check if there is a visual material applied\n\n**Returns:**\n\n * bool: True if there is a visual material applied. False otherwise.\n\n---\n**Example:**\n\n```python\n>>> # given a visual material applied\n>>> prim.is_visual_material_applied()\nTrue\n```\n",
"snippet":"value = visual_cuboid.is_visual_material_applied()\n",
"category":"method"
},
{
"title":"post_reset",
"description":"Reset the prim to its default state (position and orientation).\n\n*Note:*\nFor an articulation, in addition to configuring the root prim's default position and spatial orientation\n(defined via the `set_default_state` method), the joint's positions, velocities, and efforts\n(defined via the `set_joints_default_state` method) are imposed\n\n---\n**Example:**\n\n```python\n>>> prim.post_reset()\n```\n",
"snippet":"visual_cuboid.post_reset()\n",
"category":"method"
},
{
"title":"set_collision_approximation",
"description":"Set the collision approximation\n\n| Approximation           | Full name            | Description                                                                               |\n|-------------------------|----------------------|-------------------------------------------------------------------------------------------|\n| `\"none\"`                | Triangle Mesh        | The mesh geometry is used directly as a collider without any approximation                |\n| `\"convexDecomposition\"` | Convex Decomposition | A convex mesh decomposition is performed. This results in a set of convex mesh colliders  |\n| `\"convexHull\"`          | Convex Hull          | A convex hull of the mesh is generated and used as the collider                           |\n| `\"boundingSphere\"`      | Bounding Sphere      | A bounding sphere is computed around the mesh and used as a collider                      |\n| `\"boundingCube\"`        | Bounding Cube        | An optimally fitting box collider is computed around the mesh                             |\n| `\"meshSimplification\"`  | Mesh Simplification  | A mesh simplification step is performed, resulting in a simplified triangle mesh collider |\n| `\"sdf\"`                 | SDF Mesh             | SDF (Signed-Distance-Field) use high-detail triangle meshes as collision shape            |\n| `\"sphereFill\"`          | Sphere Approximation | A sphere mesh decomposition is performed. This results in a set of sphere colliders       |\n\n*Warning:*\nSwitching to Convex Decomposition or SDF (Signed-Distance-Field) will have a simulation performance\nimpact due to higher computational cost\n\n**Args:**\n\n * `approximation_type` (str): approximation used for collision\n\n---\n**Example:**\n\n```python\n>>> prim.set_collision_approximation(\"convexDecomposition\")\n```\n",
"snippet":"visual_cuboid.set_collision_approximation(approximation_type=approximation_type)\n",
"category":"method"
},
{
"title":"set_collision_enabled",
"description":"Enable/disable the Collision API\n\n**Args:**\n\n * `enabled` (bool): Whether to enable or disable the Collision API\n\n---\n**Example:**\n\n```python\n>>> # disable collisions\n>>> prim.set_collision_enabled(False)\n```\n",
"snippet":"visual_cuboid.set_collision_enabled(enabled=enabled)\n",
"category":"method"
},
{
"title":"set_contact_offset",
"description":"Set the contact offset\n\nShapes whose distance is less than the sum of their contact offset values will generate contacts\n\nSearch for *Advanced Collision Detection* in for more details\n\n*Warning:*\nThe contact offset must be positive and greater than the rest offset\n\n**Args:**\n\n * `offset` (float): Contact offset of a collision shape. Allowed range \\[maximum(0, rest\\_offset), 0\\]. Default value is -inf, means default is picked by simulation based on the shape extent.\n\n---\n**Example:**\n\n```python\n>>> prim.set_contact_offset(0.02)\n```\n",
"snippet":"visual_cuboid.set_contact_offset(offset=offset)\n",
"category":"method"
},
{
"title":"set_default_state",
"description":"Set the default state of the prim (position and orientation), that will be used after each reset.\n\n**Args:**\n\n * `position` (Optional\\[Sequence\\[float\\]\\], optional): position in the world frame of the prim. shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the world frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n\n---\n**Example:**\n\n```python\n>>> # configure default state\n>>> prim.set_default_state(position=np.array([1.0, 0.5, 0.0]), orientation=np.array([1, 0, 0, 0]))\n>>>\n>>> # set default states during post-reset\n>>> prim.post_reset()\n```\n",
"snippet":"visual_cuboid.set_default_state()\n",
"category":"method"
},
{
"title":"set_local_pose",
"description":"Set prim's pose with respect to the local frame (the prim's parent frame).\n\n*Warning:*\nThis method will change (teleport) the prim pose immediately to the indicated value\n\n**Args:**\n\n * `translation` (Optional\\[Sequence\\[float\\]\\], optional): translation in the local frame of the prim (with respect to its parent prim). shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the local frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n\n*Hint:*\nThis method belongs to the methods used to set the prim state\n\n---\n**Example:**\n\n```python\n>>> prim.set_local_pose(translation=np.array([1.0, 0.5, 0.0]), orientation=np.array([1., 0., 0., 0.]))\n```\n",
"snippet":"visual_cuboid.set_local_pose()\n",
"category":"method"
},
{
"title":"set_local_scale",
"description":"Set prim's scale with respect to the local frame (the prim's parent frame).\n\n**Args:**\n\n * `scale` (Optional\\[Sequence\\[float\\]\\]): scale to be applied to the prim's dimensions. shape is (3, ). Defaults to None, which means left unchanged.\n\n---\n**Example:**\n\n```python\n>>> # scale prim 10 times smaller\n>>> prim.set_local_scale(np.array([0.1, 0.1, 0.1]))\n```\n",
"snippet":"visual_cuboid.set_local_scale(scale=scale)\n",
"category":"method"
},
{
"title":"set_min_torsional_patch_radius",
"description":"Set the minimum radius of the contact patch used to apply torsional friction\n\nSearch for *\"Torsional Patch Radius\"* in for more details\n\n**Args:**\n\n * `radius` (float): minimum radius of the contact patch used to apply torsional friction. Allowed range \\[0, max\\_float\\].\n\n---\n**Example:**\n\n```python\n>>> prim.set_min_torsional_patch_radius(0.05)\n```\n",
"snippet":"visual_cuboid.set_min_torsional_patch_radius(radius=radius)\n",
"category":"method"
},
{
"title":"set_rest_offset",
"description":"Set the rest offset\n\nTwo shapes will come to rest at a distance equal to the sum of their rest offset values.\nIf the rest offset is 0, they should converge to touching exactly\n\nSearch for *Advanced Collision Detection* in for more details\n\n*Warning:*\nThe contact offset must be positive and greater than the rest offset\n\n**Args:**\n\n * `offset` (float): Rest offset of a collision shape. Allowed range \\[-max\\_float, contact\\_offset. Default value is -inf, means default is picked by simulation. For rigid bodies its zero.\n\n---\n**Example:**\n\n```python\n>>> prim.set_rest_offset(0.01)\n```\n",
"snippet":"visual_cuboid.set_rest_offset(offset=offset)\n",
"category":"method"
},
{
"title":"set_size",
"description":"Set the length of each cube edge\n\n**Args:**\n\n * `size` (float): edge length\n\n---\n**Example:**\n\n```python\n>>> prim.set_size(2.0)\n```\n",
"snippet":"visual_cuboid.set_size(size=size)\n",
"category":"method"
},
{
"title":"set_torsional_patch_radius",
"description":"Set the radius of the contact patch used to apply torsional friction\n\nSearch for *\"Torsional Patch Radius\"* in for more details\n\n**Args:**\n\n * `radius` (float): radius of the contact patch used to apply torsional friction. Allowed range \\[0, max\\_float\\].\n\n---\n**Example:**\n\n```python\n>>> prim.set_torsional_patch_radius(0.1)\n```\n",
"snippet":"visual_cuboid.set_torsional_patch_radius(radius=radius)\n",
"category":"method"
},
{
"title":"set_visibility",
"description":"Set the visibility of the prim in stage\n\n**Args:**\n\n * `visible` (bool): flag to set the visibility of the usd prim in stage.\n\n---\n**Example:**\n\n```python\n>>> # make prim not visible in the stage\n>>> prim.set_visibility(visible=False)\n```\n",
"snippet":"visual_cuboid.set_visibility(visible=visible)\n",
"category":"method"
},
{
"title":"set_world_pose",
"description":"Ses prim's pose with respect to the world's frame\n\n*Warning:*\nThis method will change (teleport) the prim pose immediately to the indicated value\n\n**Args:**\n\n * `position` (Optional\\[Sequence\\[float\\]\\], optional): position in the world frame of the prim. shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the world frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n\n*Hint:*\nThis method belongs to the methods used to set the prim state\n\n---\n**Example:**\n\n```python\n>>> prim.set_world_pose(position=np.array([1.0, 0.5, 0.0]), orientation=np.array([1., 0., 0., 0.]))\n```\n",
"snippet":"visual_cuboid.set_world_pose()\n",
"category":"method"
}
]
},
{
"title":"VisualCylinder",
"snippets":[
{
"title":"import ...",
"description":"Import class",
"snippet":"from omni.isaac.core.objects import VisualCylinder\n",
"category":"import"
},
{
"title":"VisualCylinder",
"description":"High level wrapper to create/encapsulate a visual cylinder\n\n*Note:*\nVisual cylinders (Cylinder shape) have no collisions (Collider API) or rigid body dynamics (Rigid Body API)\n\n**Args:**\n\n * `prim_path` (str): prim path of the Prim to encapsulate or create\n * `name` (str, optional): shortname to be used as a key by Scene class. Note: needs to be unique if the object is added to the Scene. Defaults to \"visual\\_cylinder\".\n * `position` (Optional\\[Sequence\\[float\\]\\], optional): position in the world frame of the prim. shape is (3, ). Defaults to None, which means left unchanged.\n * `translation` (Optional\\[Sequence\\[float\\]\\], optional): translation in the local frame of the prim (with respect to its parent prim). shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the world/ local frame of the prim (depends if translation or position is specified). quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n * `scale` (Optional\\[Sequence\\[float\\]\\], optional): local scale to be applied to the prim's dimensions. shape is (3, ). Defaults to None, which means left unchanged.\n * `visible` (bool, optional): set to false for an invisible prim in the stage while rendering. Defaults to True.\n * `color` (Optional\\[np.ndarray\\], optional): color of the visual shape. Defaults to None, which means 50% gray\n * `radius` (Optional\\[float\\], optional): base radius. Defaults to None.\n * `height` (Optional\\[float\\], optional): cylinder height. Defaults to None.\n * `visual_material` (Optional\\[VisualMaterial\\], optional): visual material to be applied to the held prim. Defaults to None. If not specified, a default visual material will be added.\n\n---\n**Example:**\n\n```python\n>>> from omni.isaac.core.objects import VisualCylinder\n>>> import numpy as np\n>>>\n>>> # create a red visual cylinder at the given path\n>>> prim = VisualCylinder(\n...     prim_path=\"/World/Xform/Cylinder\",\n...     radius=0.5,\n...     height=1.0,\n...     color=np.array([1.0, 0.0, 0.0])\n... )\n>>> prim\n<omni.isaac.core.objects.cylinder.VisualCylinder object at 0x7f4e433f22c0>\n```\n",
"snippet":"visual_cylinder = VisualCylinder(prim_path=prim_path)\n",
"category":"class"
},
{
"title":"apply_physics_material",
"description":"Used to apply physics material to the held prim and optionally its descendants.\n\n**Args:**\n\n * `physics_material` (PhysicsMaterial): physics material to be applied to the held prim. This where you want to define friction, restitution..etc. Note: if a physics material is not defined, the defaults will be used from PhysX.\n * `weaker_than_descendants` (bool, optional): True if the material shouldn't override the descendants materials, otherwise False. Defaults to False.\n\n---\n**Example:**\n\n```python\n>>> from omni.isaac.core.materials import PhysicsMaterial\n>>>\n>>> # create a rigid body physical material\n>>> material = PhysicsMaterial(\n...     prim_path=\"/World/physics_material/aluminum\",  # path to the material prim to create\n...     dynamic_friction=0.4,\n...     static_friction=1.1,\n...     restitution=0.1\n... )\n>>> prim.apply_physics_material(material)\n```\n",
"snippet":"visual_cylinder.apply_physics_material(physics_material=physics_material)\n",
"category":"method"
},
{
"title":"apply_visual_material",
"description":"Apply visual material to the held prim and optionally its descendants.\n\n**Args:**\n\n * `visual_material` (VisualMaterial): visual material to be applied to the held prim. Currently supports PreviewSurface, OmniPBR and OmniGlass.\n * `weaker_than_descendants` (bool, optional): True if the material shouldn't override the descendants materials, otherwise False. Defaults to False.\n\n---\n**Example:**\n\n```python\n>>> from omni.isaac.core.materials import OmniGlass\n>>>\n>>> # create a dark-red glass visual material\n>>> material = OmniGlass(\n...     prim_path=\"/World/material/glass\",  # path to the material prim to create\n...     ior=1.25,\n...     depth=0.001,\n...     thin_walled=False,\n...     color=np.array([0.5, 0.0, 0.0])\n... )\n>>> prim.apply_visual_material(material)\n```\n",
"snippet":"visual_cylinder.apply_visual_material(visual_material=visual_material)\n",
"category":"method"
},
{
"title":"get_applied_physics_material",
"description":"Return the current applied physics material in case it was applied using apply\\_physics\\_material or not.\n\n**Returns:**\n\n * PhysicsMaterial: the current applied physics material.\n\n---\n**Example:**\n\n```python\n>>> # given a physics material applied\n>>> prim.get_applied_physics_material()\n<omni.isaac.core.materials.physics_material.PhysicsMaterial object at 0x7fb66c30cd30>\n```\n",
"snippet":"applied_physics_material = visual_cylinder.get_applied_physics_material()\n",
"category":"method"
},
{
"title":"get_applied_visual_material",
"description":"Return the current applied visual material in case it was applied using apply\\_visual\\_material\nor it's one of the following materials that was already applied before: PreviewSurface, OmniPBR and OmniGlass.\n\n**Returns:**\n\n * VisualMaterial: the current applied visual material if its type is currently supported.\n\n---\n**Example:**\n\n```python\n>>> # given a visual material applied\n>>> prim.get_applied_visual_material()\n<omni.isaac.core.materials.omni_glass.OmniGlass object at 0x7f36263106a0>\n```\n",
"snippet":"applied_visual_material = visual_cylinder.get_applied_visual_material()\n",
"category":"method"
},
{
"title":"get_collision_approximation",
"description":"Get the collision approximation\n\n| Approximation           | Full name            | Description                                                                               |\n|-------------------------|----------------------|-------------------------------------------------------------------------------------------|\n| `\"none\"`                | Triangle Mesh        | The mesh geometry is used directly as a collider without any approximation                |\n| `\"convexDecomposition\"` | Convex Decomposition | A convex mesh decomposition is performed. This results in a set of convex mesh colliders  |\n| `\"convexHull\"`          | Convex Hull          | A convex hull of the mesh is generated and used as the collider                           |\n| `\"boundingSphere\"`      | Bounding Sphere      | A bounding sphere is computed around the mesh and used as a collider                      |\n| `\"boundingCube\"`        | Bounding Cube        | An optimally fitting box collider is computed around the mesh                             |\n| `\"meshSimplification\"`  | Mesh Simplification  | A mesh simplification step is performed, resulting in a simplified triangle mesh collider |\n| `\"sdf\"`                 | SDF Mesh             | SDF (Signed-Distance-Field) use high-detail triangle meshes as collision shape            |\n| `\"sphereFill\"`          | Sphere Approximation | A sphere mesh decomposition is performed. This results in a set of sphere colliders       |\n\n**Returns:**\n\n * str: approximation used for collision\n\n---\n**Example:**\n\n```python\n>>> prim.get_collision_approximation()\nnone\n```\n",
"snippet":"collision_approximation = visual_cylinder.get_collision_approximation()\n",
"category":"method"
},
{
"title":"get_collision_enabled",
"description":"Check if the Collision API is enabled\n\n**Returns:**\n\n * bool: True if the Collision API is enabled. Otherwise False\n\n---\n**Example:**\n\n```python\n>>> prim.get_collision_enabled()\nTrue\n```\n",
"snippet":"collision_enabled = visual_cylinder.get_collision_enabled()\n",
"category":"method"
},
{
"title":"get_contact_force_matrix",
"description":"If the object is initialized with filter\\_paths\\_expr list, this method returns the contact forces between the prims\nin the view and the filter prims. i.e., a matrix of dimension (self.\\_contact\\_view.num\\_filters, 3)\nwhere num\\_filters is the determined according to the filter\\_paths\\_expr parameter.\n\n**Args:**\n\n * `dt` (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor\\]: Net contact forces of the prims with shape (self.\\_geometry\\_prim\\_view.\\_contact\\_view.num\\_filters, 3).\n",
"snippet":"contact_force_matrix = visual_cylinder.get_contact_force_matrix()\n",
"category":"method"
},
{
"title":"get_contact_offset",
"description":"Get the contact offset\n\nShapes whose distance is less than the sum of their contact offset values will generate contacts\n\nSearch for *Advanced Collision Detection* in for more details\n\n**Returns:**\n\n * float: contact offset of the collision shape. Default value is -inf, means default is picked by simulation.\n\n---\n**Example:**\n\n```python\n>>> prim.get_contact_offset()\n-inf\n```\n",
"snippet":"contact_offset = visual_cylinder.get_contact_offset()\n",
"category":"method"
},
{
"title":"get_default_state",
"description":"Get the default prim states (spatial position and orientation).\n\n**Returns:**\n\n * XFormPrimState: an object that contains the default state of the prim (position and orientation)\n\n---\n**Example:**\n\n```python\n>>> state = prim.get_default_state()\n>>> state\n<omni.isaac.core.utils.types.XFormPrimState object at 0x7f33addda650>\n>>>\n>>> state.position\n[-4.5299529e-08 -1.8347054e-09 -2.8610229e-08]\n>>> state.orientation\n[1. 0. 0. 0.]\n```\n",
"snippet":"default_state = visual_cylinder.get_default_state()\n",
"category":"method"
},
{
"title":"get_height",
"description":"Get the cylinder height\n\n**Returns:**\n\n * float: cylinder height\n\n---\n**Example:**\n\n```python\n>>> prim.get_height()\n1.0\n```\n",
"snippet":"height = visual_cylinder.get_height()\n",
"category":"method"
},
{
"title":"get_local_pose",
"description":"Get prim's pose with respect to the local frame (the prim's parent frame)\n\n**Returns:**\n\n * Tuple\\[np.ndarray, np.ndarray\\]: first index is the position in the local frame (with shape (3, )).\n    Second index is quaternion orientation (with shape (4, )) in the local frame\n\n---\n**Example:**\n\n```python\n>>> # if the prim is in position (1.0, 0.5, 0.0) with respect to the world frame\n>>> position, orientation = prim.get_local_pose()\n>>> position\n[0. 0. 0.]\n>>> orientation\n[0. 0. 0.]\n```\n",
"snippet":"local_pose = visual_cylinder.get_local_pose()\n",
"category":"method"
},
{
"title":"get_local_scale",
"description":"Get prim's scale with respect to the local frame (the parent's frame)\n\n**Returns:**\n\n * np.ndarray: scale applied to the prim's dimensions in the local frame. shape is (3, ).\n\n---\n**Example:**\n\n```python\n>>> prim.get_local_scale()\n[1. 1. 1.]\n```\n",
"snippet":"local_scale = visual_cylinder.get_local_scale()\n",
"category":"method"
},
{
"title":"get_min_torsional_patch_radius",
"description":"Get the minimum radius of the contact patch used to apply torsional friction\n\nSearch for *\"Torsional Patch Radius\"* in for more details\n\n**Returns:**\n\n * float: minimum radius of the contact patch used to apply torsional friction. Allowed range \\[0, max\\_float\\].\n\n---\n**Example:**\n\n```python\n>>> prim.get_min_torsional_patch_radius()\n0.0\n```\n",
"snippet":"min_torsional_patch_radius = visual_cylinder.get_min_torsional_patch_radius()\n",
"category":"method"
},
{
"title":"get_net_contact_forces",
"description":"If contact forces of the prims in the view are tracked, this method returns the net contact forces on prims.\ni.e., a matrix of dimension (1, 3)\n\n**Args:**\n\n * `dt` (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor\\]: Net contact forces of the prims with shape (3).\n",
"snippet":"net_contact_forces = visual_cylinder.get_net_contact_forces()\n",
"category":"method"
},
{
"title":"get_radius",
"description":"Get the base radius\n\n**Returns:**\n\n * float: base radius\n\n---\n**Example:**\n\n```python\n>>> prim.get_radius()\n0.5\n```\n",
"snippet":"radius = visual_cylinder.get_radius()\n",
"category":"method"
},
{
"title":"get_rest_offset",
"description":"Get the rest offset\n\nTwo shapes will come to rest at a distance equal to the sum of their rest offset values.\nIf the rest offset is 0, they should converge to touching exactly\n\nSearch for *Advanced Collision Detection* in for more details\n\n**Returns:**\n\n * float: rest offset of the collision shape.\n\n---\n**Example:**\n\n```python\n>>> prim.get_rest_offset()\n-inf\n```\n",
"snippet":"rest_offset = visual_cylinder.get_rest_offset()\n",
"category":"method"
},
{
"title":"get_torsional_patch_radius",
"description":"Get the radius of the contact patch used to apply torsional friction\n\nSearch for *\"Torsional Patch Radius\"* in for more details\n\n**Returns:**\n\n * float: radius of the contact patch used to apply torsional friction. Allowed range \\[0, max\\_float\\].\n\n---\n**Example:**\n\n```python\n>>> prim.get_torsional_patch_radius()\n0.0\n```\n",
"snippet":"torsional_patch_radius = visual_cylinder.get_torsional_patch_radius()\n",
"category":"method"
},
{
"title":"get_visibility",
"description":"**Returns:**\n\n * bool: true if the prim is visible in stage. false otherwise.\n\n---\n**Example:**\n\n```python\n>>> # get the visible state of an visible prim on the stage\n>>> prim.get_visibility()\nTrue\n```\n",
"snippet":"visibility = visual_cylinder.get_visibility()\n",
"category":"method"
},
{
"title":"get_world_pose",
"description":"Get prim's pose with respect to the world's frame\n\n**Returns:**\n\n * Tuple\\[np.ndarray, np.ndarray\\]: first index is the position in the world frame (with shape (3, )).\n    Second index is quaternion orientation (with shape (4, )) in the world frame\n\n---\n**Example:**\n\n```python\n>>> # if the prim is in position (1.0, 0.5, 0.0) with respect to the world frame\n>>> position, orientation = prim.get_world_pose()\n>>> position\n[1.  0.5 0. ]\n>>> orientation\n[1. 0. 0. 0.]\n```\n",
"snippet":"world_pose = visual_cylinder.get_world_pose()\n",
"category":"method"
},
{
"title":"get_world_scale",
"description":"Get prim's scale with respect to the world's frame\n\n**Returns:**\n\n * np.ndarray: scale applied to the prim's dimensions in the world frame. shape is (3, ).\n\n---\n**Example:**\n\n```python\n>>> prim.get_world_scale()\n[1. 1. 1.]\n```\n",
"snippet":"world_scale = visual_cylinder.get_world_scale()\n",
"category":"method"
},
{
"title":"initialize",
"description":"Create a physics simulation view if not passed and using PhysX tensor API\n\n*Note:*\nIf the prim has been added to the world scene (e.g., `world.scene.add(prim)`),\nit will be automatically initialized when the world is reset (e.g., `world.reset()`).\n\n**Args:**\n\n * `physics_sim_view` (omni.physics.tensors.SimulationView, optional): current physics simulation view. Defaults to None.\n\n---\n**Example:**\n\n```python\n>>> prim.initialize()\n```\n",
"snippet":"visual_cylinder.initialize()\n",
"category":"method"
},
{
"title":"is_valid",
"description":"Check if the prim path has a valid USD Prim at it\n\n**Returns:**\n\n * bool: True is the current prim path corresponds to a valid prim in stage. False otherwise.\n\n---\n**Example:**\n\n```python\n>>> # given an existing and valid prim\n>>> prims.is_valid()\nTrue\n```\n",
"snippet":"value = visual_cylinder.is_valid()\n",
"category":"method"
},
{
"title":"is_visual_material_applied",
"description":"Check if there is a visual material applied\n\n**Returns:**\n\n * bool: True if there is a visual material applied. False otherwise.\n\n---\n**Example:**\n\n```python\n>>> # given a visual material applied\n>>> prim.is_visual_material_applied()\nTrue\n```\n",
"snippet":"value = visual_cylinder.is_visual_material_applied()\n",
"category":"method"
},
{
"title":"post_reset",
"description":"Reset the prim to its default state (position and orientation).\n\n*Note:*\nFor an articulation, in addition to configuring the root prim's default position and spatial orientation\n(defined via the `set_default_state` method), the joint's positions, velocities, and efforts\n(defined via the `set_joints_default_state` method) are imposed\n\n---\n**Example:**\n\n```python\n>>> prim.post_reset()\n```\n",
"snippet":"visual_cylinder.post_reset()\n",
"category":"method"
},
{
"title":"set_collision_approximation",
"description":"Set the collision approximation\n\n| Approximation           | Full name            | Description                                                                               |\n|-------------------------|----------------------|-------------------------------------------------------------------------------------------|\n| `\"none\"`                | Triangle Mesh        | The mesh geometry is used directly as a collider without any approximation                |\n| `\"convexDecomposition\"` | Convex Decomposition | A convex mesh decomposition is performed. This results in a set of convex mesh colliders  |\n| `\"convexHull\"`          | Convex Hull          | A convex hull of the mesh is generated and used as the collider                           |\n| `\"boundingSphere\"`      | Bounding Sphere      | A bounding sphere is computed around the mesh and used as a collider                      |\n| `\"boundingCube\"`        | Bounding Cube        | An optimally fitting box collider is computed around the mesh                             |\n| `\"meshSimplification\"`  | Mesh Simplification  | A mesh simplification step is performed, resulting in a simplified triangle mesh collider |\n| `\"sdf\"`                 | SDF Mesh             | SDF (Signed-Distance-Field) use high-detail triangle meshes as collision shape            |\n| `\"sphereFill\"`          | Sphere Approximation | A sphere mesh decomposition is performed. This results in a set of sphere colliders       |\n\n*Warning:*\nSwitching to Convex Decomposition or SDF (Signed-Distance-Field) will have a simulation performance\nimpact due to higher computational cost\n\n**Args:**\n\n * `approximation_type` (str): approximation used for collision\n\n---\n**Example:**\n\n```python\n>>> prim.set_collision_approximation(\"convexDecomposition\")\n```\n",
"snippet":"visual_cylinder.set_collision_approximation(approximation_type=approximation_type)\n",
"category":"method"
},
{
"title":"set_collision_enabled",
"description":"Enable/disable the Collision API\n\n**Args:**\n\n * `enabled` (bool): Whether to enable or disable the Collision API\n\n---\n**Example:**\n\n```python\n>>> # disable collisions\n>>> prim.set_collision_enabled(False)\n```\n",
"snippet":"visual_cylinder.set_collision_enabled(enabled=enabled)\n",
"category":"method"
},
{
"title":"set_contact_offset",
"description":"Set the contact offset\n\nShapes whose distance is less than the sum of their contact offset values will generate contacts\n\nSearch for *Advanced Collision Detection* in for more details\n\n*Warning:*\nThe contact offset must be positive and greater than the rest offset\n\n**Args:**\n\n * `offset` (float): Contact offset of a collision shape. Allowed range \\[maximum(0, rest\\_offset), 0\\]. Default value is -inf, means default is picked by simulation based on the shape extent.\n\n---\n**Example:**\n\n```python\n>>> prim.set_contact_offset(0.02)\n```\n",
"snippet":"visual_cylinder.set_contact_offset(offset=offset)\n",
"category":"method"
},
{
"title":"set_default_state",
"description":"Set the default state of the prim (position and orientation), that will be used after each reset.\n\n**Args:**\n\n * `position` (Optional\\[Sequence\\[float\\]\\], optional): position in the world frame of the prim. shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the world frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n\n---\n**Example:**\n\n```python\n>>> # configure default state\n>>> prim.set_default_state(position=np.array([1.0, 0.5, 0.0]), orientation=np.array([1, 0, 0, 0]))\n>>>\n>>> # set default states during post-reset\n>>> prim.post_reset()\n```\n",
"snippet":"visual_cylinder.set_default_state()\n",
"category":"method"
},
{
"title":"set_height",
"description":"Set the cylinder height\n\n**Args:**\n\n * `height` (float): cylinder height\n\n---\n**Example:**\n\n```python\n>>> prim.set_height(2.0)\n```\n",
"snippet":"visual_cylinder.set_height(height=height)\n",
"category":"method"
},
{
"title":"set_local_pose",
"description":"Set prim's pose with respect to the local frame (the prim's parent frame).\n\n*Warning:*\nThis method will change (teleport) the prim pose immediately to the indicated value\n\n**Args:**\n\n * `translation` (Optional\\[Sequence\\[float\\]\\], optional): translation in the local frame of the prim (with respect to its parent prim). shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the local frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n\n*Hint:*\nThis method belongs to the methods used to set the prim state\n\n---\n**Example:**\n\n```python\n>>> prim.set_local_pose(translation=np.array([1.0, 0.5, 0.0]), orientation=np.array([1., 0., 0., 0.]))\n```\n",
"snippet":"visual_cylinder.set_local_pose()\n",
"category":"method"
},
{
"title":"set_local_scale",
"description":"Set prim's scale with respect to the local frame (the prim's parent frame).\n\n**Args:**\n\n * `scale` (Optional\\[Sequence\\[float\\]\\]): scale to be applied to the prim's dimensions. shape is (3, ). Defaults to None, which means left unchanged.\n\n---\n**Example:**\n\n```python\n>>> # scale prim 10 times smaller\n>>> prim.set_local_scale(np.array([0.1, 0.1, 0.1]))\n```\n",
"snippet":"visual_cylinder.set_local_scale(scale=scale)\n",
"category":"method"
},
{
"title":"set_min_torsional_patch_radius",
"description":"Set the minimum radius of the contact patch used to apply torsional friction\n\nSearch for *\"Torsional Patch Radius\"* in for more details\n\n**Args:**\n\n * `radius` (float): minimum radius of the contact patch used to apply torsional friction. Allowed range \\[0, max\\_float\\].\n\n---\n**Example:**\n\n```python\n>>> prim.set_min_torsional_patch_radius(0.05)\n```\n",
"snippet":"visual_cylinder.set_min_torsional_patch_radius(radius=radius)\n",
"category":"method"
},
{
"title":"set_radius",
"description":"Set the base radius\n\n**Args:**\n\n * `radius` (float): base radius\n\n---\n**Example:**\n\n```python\n>>> prim.set_radius(1.0)\n```\n",
"snippet":"visual_cylinder.set_radius(radius=radius)\n",
"category":"method"
},
{
"title":"set_rest_offset",
"description":"Set the rest offset\n\nTwo shapes will come to rest at a distance equal to the sum of their rest offset values.\nIf the rest offset is 0, they should converge to touching exactly\n\nSearch for *Advanced Collision Detection* in for more details\n\n*Warning:*\nThe contact offset must be positive and greater than the rest offset\n\n**Args:**\n\n * `offset` (float): Rest offset of a collision shape. Allowed range \\[-max\\_float, contact\\_offset. Default value is -inf, means default is picked by simulation. For rigid bodies its zero.\n\n---\n**Example:**\n\n```python\n>>> prim.set_rest_offset(0.01)\n```\n",
"snippet":"visual_cylinder.set_rest_offset(offset=offset)\n",
"category":"method"
},
{
"title":"set_torsional_patch_radius",
"description":"Set the radius of the contact patch used to apply torsional friction\n\nSearch for *\"Torsional Patch Radius\"* in for more details\n\n**Args:**\n\n * `radius` (float): radius of the contact patch used to apply torsional friction. Allowed range \\[0, max\\_float\\].\n\n---\n**Example:**\n\n```python\n>>> prim.set_torsional_patch_radius(0.1)\n```\n",
"snippet":"visual_cylinder.set_torsional_patch_radius(radius=radius)\n",
"category":"method"
},
{
"title":"set_visibility",
"description":"Set the visibility of the prim in stage\n\n**Args:**\n\n * `visible` (bool): flag to set the visibility of the usd prim in stage.\n\n---\n**Example:**\n\n```python\n>>> # make prim not visible in the stage\n>>> prim.set_visibility(visible=False)\n```\n",
"snippet":"visual_cylinder.set_visibility(visible=visible)\n",
"category":"method"
},
{
"title":"set_world_pose",
"description":"Ses prim's pose with respect to the world's frame\n\n*Warning:*\nThis method will change (teleport) the prim pose immediately to the indicated value\n\n**Args:**\n\n * `position` (Optional\\[Sequence\\[float\\]\\], optional): position in the world frame of the prim. shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the world frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n\n*Hint:*\nThis method belongs to the methods used to set the prim state\n\n---\n**Example:**\n\n```python\n>>> prim.set_world_pose(position=np.array([1.0, 0.5, 0.0]), orientation=np.array([1., 0., 0., 0.]))\n```\n",
"snippet":"visual_cylinder.set_world_pose()\n",
"category":"method"
}
]
},
{
"title":"VisualSphere",
"snippets":[
{
"title":"import ...",
"description":"Import class",
"snippet":"from omni.isaac.core.objects import VisualSphere\n",
"category":"import"
},
{
"title":"VisualSphere",
"description":"High level wrapper to create/encapsulate a visual sphere\n\n*Note:*\nVisual spheres (Sphere shape) have no collisions (Collider API) or rigid body dynamics (Rigid Body API)\n\n**Args:**\n\n * `prim_path` (str): prim path of the Prim to encapsulate or create\n * `name` (str, optional): shortname to be used as a key by Scene class. Note: needs to be unique if the object is added to the Scene. Defaults to \"visual\\_sphere\".\n * `position` (Optional\\[Sequence\\[float\\]\\], optional): position in the world frame of the prim. shape is (3, ). Defaults to None, which means left unchanged.\n * `translation` (Optional\\[Sequence\\[float\\]\\], optional): translation in the local frame of the prim (with respect to its parent prim). shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the world/ local frame of the prim (depends if translation or position is specified). quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n * `scale` (Optional\\[Sequence\\[float\\]\\], optional): local scale to be applied to the prim's dimensions. shape is (3, ). Defaults to None, which means left unchanged.\n * `visible` (bool, optional): set to false for an invisible prim in the stage while rendering. Defaults to True.\n * `color` (Optional\\[np.ndarray\\], optional): color of the visual shape. Defaults to None, which means 50% gray\n * `radius` (Optional\\[float\\], optional): sphere radius. Defaults to None.\n * `visual_material` (Optional\\[VisualMaterial\\], optional): visual material to be applied to the held prim. Defaults to None. If not specified, a default visual material will be added.\n\n---\n**Example:**\n\n```python\n>>> from omni.isaac.core.objects import VisualSphere\n>>> import numpy as np\n>>>\n>>> # create a red visual sphere at the given path\n>>> prim = VisualSphere(prim_path=\"/World/Xform/Sphere\", color=np.array([1.0, 0.0, 0.0]))\n>>> prim\n<omni.isaac.core.objects.sphere.VisualSphere object at 0x7f4e3eb3ea70>\n```\n",
"snippet":"visual_sphere = VisualSphere(prim_path=prim_path)\n",
"category":"class"
},
{
"title":"apply_physics_material",
"description":"Used to apply physics material to the held prim and optionally its descendants.\n\n**Args:**\n\n * `physics_material` (PhysicsMaterial): physics material to be applied to the held prim. This where you want to define friction, restitution..etc. Note: if a physics material is not defined, the defaults will be used from PhysX.\n * `weaker_than_descendants` (bool, optional): True if the material shouldn't override the descendants materials, otherwise False. Defaults to False.\n\n---\n**Example:**\n\n```python\n>>> from omni.isaac.core.materials import PhysicsMaterial\n>>>\n>>> # create a rigid body physical material\n>>> material = PhysicsMaterial(\n...     prim_path=\"/World/physics_material/aluminum\",  # path to the material prim to create\n...     dynamic_friction=0.4,\n...     static_friction=1.1,\n...     restitution=0.1\n... )\n>>> prim.apply_physics_material(material)\n```\n",
"snippet":"visual_sphere.apply_physics_material(physics_material=physics_material)\n",
"category":"method"
},
{
"title":"apply_visual_material",
"description":"Apply visual material to the held prim and optionally its descendants.\n\n**Args:**\n\n * `visual_material` (VisualMaterial): visual material to be applied to the held prim. Currently supports PreviewSurface, OmniPBR and OmniGlass.\n * `weaker_than_descendants` (bool, optional): True if the material shouldn't override the descendants materials, otherwise False. Defaults to False.\n\n---\n**Example:**\n\n```python\n>>> from omni.isaac.core.materials import OmniGlass\n>>>\n>>> # create a dark-red glass visual material\n>>> material = OmniGlass(\n...     prim_path=\"/World/material/glass\",  # path to the material prim to create\n...     ior=1.25,\n...     depth=0.001,\n...     thin_walled=False,\n...     color=np.array([0.5, 0.0, 0.0])\n... )\n>>> prim.apply_visual_material(material)\n```\n",
"snippet":"visual_sphere.apply_visual_material(visual_material=visual_material)\n",
"category":"method"
},
{
"title":"get_applied_physics_material",
"description":"Return the current applied physics material in case it was applied using apply\\_physics\\_material or not.\n\n**Returns:**\n\n * PhysicsMaterial: the current applied physics material.\n\n---\n**Example:**\n\n```python\n>>> # given a physics material applied\n>>> prim.get_applied_physics_material()\n<omni.isaac.core.materials.physics_material.PhysicsMaterial object at 0x7fb66c30cd30>\n```\n",
"snippet":"applied_physics_material = visual_sphere.get_applied_physics_material()\n",
"category":"method"
},
{
"title":"get_applied_visual_material",
"description":"Return the current applied visual material in case it was applied using apply\\_visual\\_material\nor it's one of the following materials that was already applied before: PreviewSurface, OmniPBR and OmniGlass.\n\n**Returns:**\n\n * VisualMaterial: the current applied visual material if its type is currently supported.\n\n---\n**Example:**\n\n```python\n>>> # given a visual material applied\n>>> prim.get_applied_visual_material()\n<omni.isaac.core.materials.omni_glass.OmniGlass object at 0x7f36263106a0>\n```\n",
"snippet":"applied_visual_material = visual_sphere.get_applied_visual_material()\n",
"category":"method"
},
{
"title":"get_collision_approximation",
"description":"Get the collision approximation\n\n| Approximation           | Full name            | Description                                                                               |\n|-------------------------|----------------------|-------------------------------------------------------------------------------------------|\n| `\"none\"`                | Triangle Mesh        | The mesh geometry is used directly as a collider without any approximation                |\n| `\"convexDecomposition\"` | Convex Decomposition | A convex mesh decomposition is performed. This results in a set of convex mesh colliders  |\n| `\"convexHull\"`          | Convex Hull          | A convex hull of the mesh is generated and used as the collider                           |\n| `\"boundingSphere\"`      | Bounding Sphere      | A bounding sphere is computed around the mesh and used as a collider                      |\n| `\"boundingCube\"`        | Bounding Cube        | An optimally fitting box collider is computed around the mesh                             |\n| `\"meshSimplification\"`  | Mesh Simplification  | A mesh simplification step is performed, resulting in a simplified triangle mesh collider |\n| `\"sdf\"`                 | SDF Mesh             | SDF (Signed-Distance-Field) use high-detail triangle meshes as collision shape            |\n| `\"sphereFill\"`          | Sphere Approximation | A sphere mesh decomposition is performed. This results in a set of sphere colliders       |\n\n**Returns:**\n\n * str: approximation used for collision\n\n---\n**Example:**\n\n```python\n>>> prim.get_collision_approximation()\nnone\n```\n",
"snippet":"collision_approximation = visual_sphere.get_collision_approximation()\n",
"category":"method"
},
{
"title":"get_collision_enabled",
"description":"Check if the Collision API is enabled\n\n**Returns:**\n\n * bool: True if the Collision API is enabled. Otherwise False\n\n---\n**Example:**\n\n```python\n>>> prim.get_collision_enabled()\nTrue\n```\n",
"snippet":"collision_enabled = visual_sphere.get_collision_enabled()\n",
"category":"method"
},
{
"title":"get_contact_force_matrix",
"description":"If the object is initialized with filter\\_paths\\_expr list, this method returns the contact forces between the prims\nin the view and the filter prims. i.e., a matrix of dimension (self.\\_contact\\_view.num\\_filters, 3)\nwhere num\\_filters is the determined according to the filter\\_paths\\_expr parameter.\n\n**Args:**\n\n * `dt` (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor\\]: Net contact forces of the prims with shape (self.\\_geometry\\_prim\\_view.\\_contact\\_view.num\\_filters, 3).\n",
"snippet":"contact_force_matrix = visual_sphere.get_contact_force_matrix()\n",
"category":"method"
},
{
"title":"get_contact_offset",
"description":"Get the contact offset\n\nShapes whose distance is less than the sum of their contact offset values will generate contacts\n\nSearch for *Advanced Collision Detection* in for more details\n\n**Returns:**\n\n * float: contact offset of the collision shape. Default value is -inf, means default is picked by simulation.\n\n---\n**Example:**\n\n```python\n>>> prim.get_contact_offset()\n-inf\n```\n",
"snippet":"contact_offset = visual_sphere.get_contact_offset()\n",
"category":"method"
},
{
"title":"get_default_state",
"description":"Get the default prim states (spatial position and orientation).\n\n**Returns:**\n\n * XFormPrimState: an object that contains the default state of the prim (position and orientation)\n\n---\n**Example:**\n\n```python\n>>> state = prim.get_default_state()\n>>> state\n<omni.isaac.core.utils.types.XFormPrimState object at 0x7f33addda650>\n>>>\n>>> state.position\n[-4.5299529e-08 -1.8347054e-09 -2.8610229e-08]\n>>> state.orientation\n[1. 0. 0. 0.]\n```\n",
"snippet":"default_state = visual_sphere.get_default_state()\n",
"category":"method"
},
{
"title":"get_local_pose",
"description":"Get prim's pose with respect to the local frame (the prim's parent frame)\n\n**Returns:**\n\n * Tuple\\[np.ndarray, np.ndarray\\]: first index is the position in the local frame (with shape (3, )).\n    Second index is quaternion orientation (with shape (4, )) in the local frame\n\n---\n**Example:**\n\n```python\n>>> # if the prim is in position (1.0, 0.5, 0.0) with respect to the world frame\n>>> position, orientation = prim.get_local_pose()\n>>> position\n[0. 0. 0.]\n>>> orientation\n[0. 0. 0.]\n```\n",
"snippet":"local_pose = visual_sphere.get_local_pose()\n",
"category":"method"
},
{
"title":"get_local_scale",
"description":"Get prim's scale with respect to the local frame (the parent's frame)\n\n**Returns:**\n\n * np.ndarray: scale applied to the prim's dimensions in the local frame. shape is (3, ).\n\n---\n**Example:**\n\n```python\n>>> prim.get_local_scale()\n[1. 1. 1.]\n```\n",
"snippet":"local_scale = visual_sphere.get_local_scale()\n",
"category":"method"
},
{
"title":"get_min_torsional_patch_radius",
"description":"Get the minimum radius of the contact patch used to apply torsional friction\n\nSearch for *\"Torsional Patch Radius\"* in for more details\n\n**Returns:**\n\n * float: minimum radius of the contact patch used to apply torsional friction. Allowed range \\[0, max\\_float\\].\n\n---\n**Example:**\n\n```python\n>>> prim.get_min_torsional_patch_radius()\n0.0\n```\n",
"snippet":"min_torsional_patch_radius = visual_sphere.get_min_torsional_patch_radius()\n",
"category":"method"
},
{
"title":"get_net_contact_forces",
"description":"If contact forces of the prims in the view are tracked, this method returns the net contact forces on prims.\ni.e., a matrix of dimension (1, 3)\n\n**Args:**\n\n * `dt` (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor\\]: Net contact forces of the prims with shape (3).\n",
"snippet":"net_contact_forces = visual_sphere.get_net_contact_forces()\n",
"category":"method"
},
{
"title":"get_radius",
"description":"Get the sphere radius\n\n**Returns:**\n\n * float: sphere radius\n\n---\n**Example:**\n\n```python\n>>> prim.get_radius()\n1.0\n```\n",
"snippet":"radius = visual_sphere.get_radius()\n",
"category":"method"
},
{
"title":"get_rest_offset",
"description":"Get the rest offset\n\nTwo shapes will come to rest at a distance equal to the sum of their rest offset values.\nIf the rest offset is 0, they should converge to touching exactly\n\nSearch for *Advanced Collision Detection* in for more details\n\n**Returns:**\n\n * float: rest offset of the collision shape.\n\n---\n**Example:**\n\n```python\n>>> prim.get_rest_offset()\n-inf\n```\n",
"snippet":"rest_offset = visual_sphere.get_rest_offset()\n",
"category":"method"
},
{
"title":"get_torsional_patch_radius",
"description":"Get the radius of the contact patch used to apply torsional friction\n\nSearch for *\"Torsional Patch Radius\"* in for more details\n\n**Returns:**\n\n * float: radius of the contact patch used to apply torsional friction. Allowed range \\[0, max\\_float\\].\n\n---\n**Example:**\n\n```python\n>>> prim.get_torsional_patch_radius()\n0.0\n```\n",
"snippet":"torsional_patch_radius = visual_sphere.get_torsional_patch_radius()\n",
"category":"method"
},
{
"title":"get_visibility",
"description":"**Returns:**\n\n * bool: true if the prim is visible in stage. false otherwise.\n\n---\n**Example:**\n\n```python\n>>> # get the visible state of an visible prim on the stage\n>>> prim.get_visibility()\nTrue\n```\n",
"snippet":"visibility = visual_sphere.get_visibility()\n",
"category":"method"
},
{
"title":"get_world_pose",
"description":"Get prim's pose with respect to the world's frame\n\n**Returns:**\n\n * Tuple\\[np.ndarray, np.ndarray\\]: first index is the position in the world frame (with shape (3, )).\n    Second index is quaternion orientation (with shape (4, )) in the world frame\n\n---\n**Example:**\n\n```python\n>>> # if the prim is in position (1.0, 0.5, 0.0) with respect to the world frame\n>>> position, orientation = prim.get_world_pose()\n>>> position\n[1.  0.5 0. ]\n>>> orientation\n[1. 0. 0. 0.]\n```\n",
"snippet":"world_pose = visual_sphere.get_world_pose()\n",
"category":"method"
},
{
"title":"get_world_scale",
"description":"Get prim's scale with respect to the world's frame\n\n**Returns:**\n\n * np.ndarray: scale applied to the prim's dimensions in the world frame. shape is (3, ).\n\n---\n**Example:**\n\n```python\n>>> prim.get_world_scale()\n[1. 1. 1.]\n```\n",
"snippet":"world_scale = visual_sphere.get_world_scale()\n",
"category":"method"
},
{
"title":"initialize",
"description":"Create a physics simulation view if not passed and using PhysX tensor API\n\n*Note:*\nIf the prim has been added to the world scene (e.g., `world.scene.add(prim)`),\nit will be automatically initialized when the world is reset (e.g., `world.reset()`).\n\n**Args:**\n\n * `physics_sim_view` (omni.physics.tensors.SimulationView, optional): current physics simulation view. Defaults to None.\n\n---\n**Example:**\n\n```python\n>>> prim.initialize()\n```\n",
"snippet":"visual_sphere.initialize()\n",
"category":"method"
},
{
"title":"is_valid",
"description":"Check if the prim path has a valid USD Prim at it\n\n**Returns:**\n\n * bool: True is the current prim path corresponds to a valid prim in stage. False otherwise.\n\n---\n**Example:**\n\n```python\n>>> # given an existing and valid prim\n>>> prims.is_valid()\nTrue\n```\n",
"snippet":"value = visual_sphere.is_valid()\n",
"category":"method"
},
{
"title":"is_visual_material_applied",
"description":"Check if there is a visual material applied\n\n**Returns:**\n\n * bool: True if there is a visual material applied. False otherwise.\n\n---\n**Example:**\n\n```python\n>>> # given a visual material applied\n>>> prim.is_visual_material_applied()\nTrue\n```\n",
"snippet":"value = visual_sphere.is_visual_material_applied()\n",
"category":"method"
},
{
"title":"post_reset",
"description":"Reset the prim to its default state (position and orientation).\n\n*Note:*\nFor an articulation, in addition to configuring the root prim's default position and spatial orientation\n(defined via the `set_default_state` method), the joint's positions, velocities, and efforts\n(defined via the `set_joints_default_state` method) are imposed\n\n---\n**Example:**\n\n```python\n>>> prim.post_reset()\n```\n",
"snippet":"visual_sphere.post_reset()\n",
"category":"method"
},
{
"title":"set_collision_approximation",
"description":"Set the collision approximation\n\n| Approximation           | Full name            | Description                                                                               |\n|-------------------------|----------------------|-------------------------------------------------------------------------------------------|\n| `\"none\"`                | Triangle Mesh        | The mesh geometry is used directly as a collider without any approximation                |\n| `\"convexDecomposition\"` | Convex Decomposition | A convex mesh decomposition is performed. This results in a set of convex mesh colliders  |\n| `\"convexHull\"`          | Convex Hull          | A convex hull of the mesh is generated and used as the collider                           |\n| `\"boundingSphere\"`      | Bounding Sphere      | A bounding sphere is computed around the mesh and used as a collider                      |\n| `\"boundingCube\"`        | Bounding Cube        | An optimally fitting box collider is computed around the mesh                             |\n| `\"meshSimplification\"`  | Mesh Simplification  | A mesh simplification step is performed, resulting in a simplified triangle mesh collider |\n| `\"sdf\"`                 | SDF Mesh             | SDF (Signed-Distance-Field) use high-detail triangle meshes as collision shape            |\n| `\"sphereFill\"`          | Sphere Approximation | A sphere mesh decomposition is performed. This results in a set of sphere colliders       |\n\n*Warning:*\nSwitching to Convex Decomposition or SDF (Signed-Distance-Field) will have a simulation performance\nimpact due to higher computational cost\n\n**Args:**\n\n * `approximation_type` (str): approximation used for collision\n\n---\n**Example:**\n\n```python\n>>> prim.set_collision_approximation(\"convexDecomposition\")\n```\n",
"snippet":"visual_sphere.set_collision_approximation(approximation_type=approximation_type)\n",
"category":"method"
},
{
"title":"set_collision_enabled",
"description":"Enable/disable the Collision API\n\n**Args:**\n\n * `enabled` (bool): Whether to enable or disable the Collision API\n\n---\n**Example:**\n\n```python\n>>> # disable collisions\n>>> prim.set_collision_enabled(False)\n```\n",
"snippet":"visual_sphere.set_collision_enabled(enabled=enabled)\n",
"category":"method"
},
{
"title":"set_contact_offset",
"description":"Set the contact offset\n\nShapes whose distance is less than the sum of their contact offset values will generate contacts\n\nSearch for *Advanced Collision Detection* in for more details\n\n*Warning:*\nThe contact offset must be positive and greater than the rest offset\n\n**Args:**\n\n * `offset` (float): Contact offset of a collision shape. Allowed range \\[maximum(0, rest\\_offset), 0\\]. Default value is -inf, means default is picked by simulation based on the shape extent.\n\n---\n**Example:**\n\n```python\n>>> prim.set_contact_offset(0.02)\n```\n",
"snippet":"visual_sphere.set_contact_offset(offset=offset)\n",
"category":"method"
},
{
"title":"set_default_state",
"description":"Set the default state of the prim (position and orientation), that will be used after each reset.\n\n**Args:**\n\n * `position` (Optional\\[Sequence\\[float\\]\\], optional): position in the world frame of the prim. shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the world frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n\n---\n**Example:**\n\n```python\n>>> # configure default state\n>>> prim.set_default_state(position=np.array([1.0, 0.5, 0.0]), orientation=np.array([1, 0, 0, 0]))\n>>>\n>>> # set default states during post-reset\n>>> prim.post_reset()\n```\n",
"snippet":"visual_sphere.set_default_state()\n",
"category":"method"
},
{
"title":"set_local_pose",
"description":"Set prim's pose with respect to the local frame (the prim's parent frame).\n\n*Warning:*\nThis method will change (teleport) the prim pose immediately to the indicated value\n\n**Args:**\n\n * `translation` (Optional\\[Sequence\\[float\\]\\], optional): translation in the local frame of the prim (with respect to its parent prim). shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the local frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n\n*Hint:*\nThis method belongs to the methods used to set the prim state\n\n---\n**Example:**\n\n```python\n>>> prim.set_local_pose(translation=np.array([1.0, 0.5, 0.0]), orientation=np.array([1., 0., 0., 0.]))\n```\n",
"snippet":"visual_sphere.set_local_pose()\n",
"category":"method"
},
{
"title":"set_local_scale",
"description":"Set prim's scale with respect to the local frame (the prim's parent frame).\n\n**Args:**\n\n * `scale` (Optional\\[Sequence\\[float\\]\\]): scale to be applied to the prim's dimensions. shape is (3, ). Defaults to None, which means left unchanged.\n\n---\n**Example:**\n\n```python\n>>> # scale prim 10 times smaller\n>>> prim.set_local_scale(np.array([0.1, 0.1, 0.1]))\n```\n",
"snippet":"visual_sphere.set_local_scale(scale=scale)\n",
"category":"method"
},
{
"title":"set_min_torsional_patch_radius",
"description":"Set the minimum radius of the contact patch used to apply torsional friction\n\nSearch for *\"Torsional Patch Radius\"* in for more details\n\n**Args:**\n\n * `radius` (float): minimum radius of the contact patch used to apply torsional friction. Allowed range \\[0, max\\_float\\].\n\n---\n**Example:**\n\n```python\n>>> prim.set_min_torsional_patch_radius(0.05)\n```\n",
"snippet":"visual_sphere.set_min_torsional_patch_radius(radius=radius)\n",
"category":"method"
},
{
"title":"set_radius",
"description":"Set the sphere radius\n\n**Args:**\n\n * `radius` (float): sphere radius\n\n---\n**Example:**\n\n```python\n>>> prim.set_radius(2.0)\n```\n",
"snippet":"visual_sphere.set_radius(radius=radius)\n",
"category":"method"
},
{
"title":"set_rest_offset",
"description":"Set the rest offset\n\nTwo shapes will come to rest at a distance equal to the sum of their rest offset values.\nIf the rest offset is 0, they should converge to touching exactly\n\nSearch for *Advanced Collision Detection* in for more details\n\n*Warning:*\nThe contact offset must be positive and greater than the rest offset\n\n**Args:**\n\n * `offset` (float): Rest offset of a collision shape. Allowed range \\[-max\\_float, contact\\_offset. Default value is -inf, means default is picked by simulation. For rigid bodies its zero.\n\n---\n**Example:**\n\n```python\n>>> prim.set_rest_offset(0.01)\n```\n",
"snippet":"visual_sphere.set_rest_offset(offset=offset)\n",
"category":"method"
},
{
"title":"set_torsional_patch_radius",
"description":"Set the radius of the contact patch used to apply torsional friction\n\nSearch for *\"Torsional Patch Radius\"* in for more details\n\n**Args:**\n\n * `radius` (float): radius of the contact patch used to apply torsional friction. Allowed range \\[0, max\\_float\\].\n\n---\n**Example:**\n\n```python\n>>> prim.set_torsional_patch_radius(0.1)\n```\n",
"snippet":"visual_sphere.set_torsional_patch_radius(radius=radius)\n",
"category":"method"
},
{
"title":"set_visibility",
"description":"Set the visibility of the prim in stage\n\n**Args:**\n\n * `visible` (bool): flag to set the visibility of the usd prim in stage.\n\n---\n**Example:**\n\n```python\n>>> # make prim not visible in the stage\n>>> prim.set_visibility(visible=False)\n```\n",
"snippet":"visual_sphere.set_visibility(visible=visible)\n",
"category":"method"
},
{
"title":"set_world_pose",
"description":"Ses prim's pose with respect to the world's frame\n\n*Warning:*\nThis method will change (teleport) the prim pose immediately to the indicated value\n\n**Args:**\n\n * `position` (Optional\\[Sequence\\[float\\]\\], optional): position in the world frame of the prim. shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the world frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n\n*Hint:*\nThis method belongs to the methods used to set the prim state\n\n---\n**Example:**\n\n```python\n>>> prim.set_world_pose(position=np.array([1.0, 0.5, 0.0]), orientation=np.array([1., 0., 0., 0.]))\n```\n",
"snippet":"visual_sphere.set_world_pose()\n",
"category":"method"
}
]
}
]
},
{
"title":"PhysicsContext",
"snippets":[
{
"title":"import ...",
"description":"Import class",
"snippet":"from omni.isaac.core.physics_context import PhysicsContext\n",
"category":"import"
},
{
"title":"PhysicsContext",
"description":"Provides high level functions to deal with a physics scene and its settings. This will create a\na PhysicsScene prim at the specified prim path in case there is no PhysicsScene present in the current\nstage.\nIf there is a PhysicsScene present, it will discard the prim\\_path specified and sets the\ndefault settings on the current PhysicsScene found.\n\n> Args:\n> physics\\_dt (float, optional): specifies the physics\\_dt of the simulation. Defaults to 1.0 / 60.0.\n> prim\\_path (Optional\\[str\\], optional): specifies the prim path to create a PhysicsScene at, only in the case where no PhysicsScene already defined. Defaults to \"/physicsScene\".\n> set\\_defaults (bool, optional): set to True to use the defaults physics parameters \\[physics\\_dt = 1.0/ 60.0, gravity = -9.81 m / s ccd\\_enabled, stabilization\\_enabled, gpu dynamics turned off, broadcast type is MBP, solver type is TGS\\]. Defaults to True.\n> backend (str, optional): specifies the backend to be used (numpy or torch). Defaults to numpy.\n> device (Optional\\[str\\], optional): specifies the device to be used if running on the gpu with torch backend.\n>\n> Raises:\n> Exception: If prim\\_path is not absolute.\n> Exception: if prim\\_path already exists and its type is not a PhysicsScene.\n",
"snippet":"physics_context = PhysicsContext()\n",
"category":"class"
},
{
"title":"device",
"description":"",
"snippet":"device = physics_context.device\n",
"category":"property"
},
{
"title":"enable_ccd",
"description":"Enables a second broad phase after integration that makes it possible to prevent objects from tunneling\nthrough each other.\nArgs:\nflag (bool): enables or disables ccd on the PhysicsScene\nRaises:\nException: If the prim path registered in context doesn't correspond to a valid prim path currently.\n",
"snippet":"physics_context.enable_ccd(flag=flag)\n",
"category":"method"
},
{
"title":"enable_fabric",
"description":"",
"snippet":"physics_context.enable_fabric(enable=enable)\n",
"category":"method"
},
{
"title":"enable_gpu_dynamics",
"description":"Enables gpu dynamics pipeline, required for deformables for instance.\n\n**Args:**\n\n * `flag` (bool): enables or disables gpu dynamics on the PhysicsScene\n\n**Raises:**\n\n * Exception: If the prim path registered in context doesn't correspond to a valid prim path currently.\n",
"snippet":"physics_context.enable_gpu_dynamics(flag=flag)\n",
"category":"method"
},
{
"title":"enable_stablization",
"description":"Enables additional stabilization pass in the solver.\n\n**Args:**\n\n * `flag` (bool): enables or disables stabilization on the PhysicsScene\n\n**Raises:**\n\n * Exception: If the prim path registered in context doesn't correspond to a valid prim path currently.\n",
"snippet":"physics_context.enable_stablization(flag=flag)\n",
"category":"method"
},
{
"title":"get_bounce_threshold",
"description":"\\[summary\\]\n\n**Raises:**\n\n * Exception: \\[description\\]\n\n**Returns:**\n\n * float: \\[description\\]\n",
"snippet":"bounce_threshold = physics_context.get_bounce_threshold()\n",
"category":"method"
},
{
"title":"get_broadphase_type",
"description":"Gets current broadcast phase algorithm type.\n\n**Raises:**\n\n * Exception: If the prim path registered in context doesn't correspond to a valid prim path currently.\n\n**Returns:**\n\n * str: Broadcast phase algorithm used.\n",
"snippet":"broadphase_type = physics_context.get_broadphase_type()\n",
"category":"method"
},
{
"title":"get_current_physics_scene_prim",
"description":"Used to return the PhysicsScene prim in stage by traversing the stage.\n\n**Returns:**\n\n * Optional\\[Usd.Prim\\]: returns a PhysicsScene prim if found in current stage. Otherwise, None.\n",
"snippet":"current_physics_scene_prim = physics_context.get_current_physics_scene_prim()\n",
"category":"method"
},
{
"title":"get_enable_scene_query_support",
"description":"Retrieves the Enable Scene Query Support attribute in Physx Scene\n\n**Raises:**\n\n * Exception: \\[description\\]\n\n**Returns:**\n\n * bool: enable scene query support attribute\n",
"snippet":"enable_scene_query_support = physics_context.get_enable_scene_query_support()\n",
"category":"method"
},
{
"title":"get_friction_correlation_distance",
"description":"\\[summary\\]\n\n**Raises:**\n\n * Exception: \\[description\\]\n\n**Returns:**\n\n * float: \\[description\\]\n",
"snippet":"friction_correlation_distance = physics_context.get_friction_correlation_distance()\n",
"category":"method"
},
{
"title":"get_friction_offset_threshold",
"description":"\\[summary\\]\n\n**Raises:**\n\n * Exception: \\[description\\]\n\n**Returns:**\n\n * float: \\[description\\]\n",
"snippet":"friction_offset_threshold = physics_context.get_friction_offset_threshold()\n",
"category":"method"
},
{
"title":"get_gpu_collision_stack_size",
"description":"\\[summary\\]\n\n**Raises:**\n\n * Exception: \\[description\\]\n\n**Returns:**\n\n * int: \\[description\\]\n",
"snippet":"gpu_collision_stack_size = physics_context.get_gpu_collision_stack_size()\n",
"category":"method"
},
{
"title":"get_gpu_found_lost_aggregate_pairs_capacity",
"description":"\\[summary\\]\n\n**Raises:**\n\n * Exception: \\[description\\]\n\n**Returns:**\n\n * int: \\[description\\]\n",
"snippet":"gpu_found_lost_aggregate_pairs_capacity = physics_context.get_gpu_found_lost_aggregate_pairs_capacity()\n",
"category":"method"
},
{
"title":"get_gpu_found_lost_pairs_capacity",
"description":"\\[summary\\]\n\n**Raises:**\n\n * Exception: \\[description\\]\n\n**Returns:**\n\n * int: \\[description\\]\n",
"snippet":"gpu_found_lost_pairs_capacity = physics_context.get_gpu_found_lost_pairs_capacity()\n",
"category":"method"
},
{
"title":"get_gpu_heap_capacity",
"description":"\\[summary\\]\n\n**Raises:**\n\n * Exception: \\[description\\]\n\n**Returns:**\n\n * int: \\[description\\]\n",
"snippet":"gpu_heap_capacity = physics_context.get_gpu_heap_capacity()\n",
"category":"method"
},
{
"title":"get_gpu_max_num_partitions",
"description":"\\[summary\\]\n\n**Raises:**\n\n * Exception: \\[description\\]\n\n**Returns:**\n\n * int: \\[description\\]\n",
"snippet":"gpu_max_num_partitions = physics_context.get_gpu_max_num_partitions()\n",
"category":"method"
},
{
"title":"get_gpu_max_particle_contacts",
"description":"\\[summary\\]\n\n**Raises:**\n\n * Exception: \\[description\\]\n\n**Returns:**\n\n * int: \\[description\\]\n",
"snippet":"gpu_max_particle_contacts = physics_context.get_gpu_max_particle_contacts()\n",
"category":"method"
},
{
"title":"get_gpu_max_rigid_contact_count",
"description":"\\[summary\\]\n\n**Raises:**\n\n * Exception: \\[description\\]\n\n**Returns:**\n\n * int: \\[description\\]\n",
"snippet":"gpu_max_rigid_contact_count = physics_context.get_gpu_max_rigid_contact_count()\n",
"category":"method"
},
{
"title":"get_gpu_max_rigid_patch_count",
"description":"\\[summary\\]\n\n**Raises:**\n\n * Exception: \\[description\\]\n\n**Returns:**\n\n * int: \\[description\\]\n",
"snippet":"gpu_max_rigid_patch_count = physics_context.get_gpu_max_rigid_patch_count()\n",
"category":"method"
},
{
"title":"get_gpu_max_soft_body_contacts",
"description":"\\[summary\\]\n\n**Raises:**\n\n * Exception: \\[description\\]\n\n**Returns:**\n\n * int: \\[description\\]\n",
"snippet":"gpu_max_soft_body_contacts = physics_context.get_gpu_max_soft_body_contacts()\n",
"category":"method"
},
{
"title":"get_gpu_temp_buffer_capacity",
"description":"\\[summary\\]\n\n**Raises:**\n\n * Exception: \\[description\\]\n\n**Returns:**\n\n * int: \\[description\\]\n",
"snippet":"gpu_temp_buffer_capacity = physics_context.get_gpu_temp_buffer_capacity()\n",
"category":"method"
},
{
"title":"get_gpu_total_aggregate_pairs_capacity",
"description":"\\[summary\\]\n\n**Raises:**\n\n * Exception: \\[description\\]\n\n**Returns:**\n\n * int: \\[description\\]\n",
"snippet":"gpu_total_aggregate_pairs_capacity = physics_context.get_gpu_total_aggregate_pairs_capacity()\n",
"category":"method"
},
{
"title":"get_gravity",
"description":"Gets current gravity.\n\n**Raises:**\n\n * Exception: If the prim path registered in context doesn't correspond to a valid prim path currently.\n\n**Returns:**\n\n * Tuple\\[list, float\\]: returns a tuple, first element corresponds to the gravity direction vector and second element is the magnitude.\n",
"snippet":"gravity = physics_context.get_gravity()\n",
"category":"method"
},
{
"title":"get_invert_collision_group_filter",
"description":"\\[summary\\]\n\n**Raises:**\n\n * Exception: \\[description\\]\n\n**Returns:**\n\n * int: \\[description\\]\n",
"snippet":"invert_collision_group_filter = physics_context.get_invert_collision_group_filter()\n",
"category":"method"
},
{
"title":"get_physics_dt",
"description":"Returns the current physics dt.\n\n**Raises:**\n\n * Exception: If the prim path registered in context doesn't correspond to a valid prim path currently.\n\n**Returns:**\n\n * float: physics dt.\n",
"snippet":"physics_dt = physics_context.get_physics_dt()\n",
"category":"method"
},
{
"title":"get_physx_update_transformations_settings",
"description":"Gets how physx syncs with the usd when transformations are updated.\n\n**Returns:**\n\n * Tuple\\[bool, bool, bool, bool\\]: \\[update\\_to\\_fast\\_cache, update\\_to\\_usd, update\\_velocities\\_to\\_usd, output\\_velocities\\_local\\_space\\]\n",
"snippet":"physx_update_transformations_settings = physics_context.get_physx_update_transformations_settings()\n",
"category":"method"
},
{
"title":"get_solver_type",
"description":"Gets current solver type.\n\n**Raises:**\n\n * Exception: If the prim path registered in context doesn't correspond to a valid prim path currently.\n\n**Returns:**\n\n * str: solver used for simulation.\n",
"snippet":"solver_type = physics_context.get_solver_type()\n",
"category":"method"
},
{
"title":"is_ccd_enabled",
"description":"Checks if ccd is enabled.\n\n**Raises:**\n\n * Exception: If the prim path registered in context doesn't correspond to a valid prim path currently.\n\n**Returns:**\n\n * bool: True if ccd is enabled, otherwise False.\n",
"snippet":"value = physics_context.is_ccd_enabled()\n",
"category":"method"
},
{
"title":"is_gpu_dynamics_enabled",
"description":"Checks if Gpu Dynamics is enabled.\n\n**Raises:**\n\n * Exception: If the prim path registered in context doesn't correspond to a valid prim path currently.\n\n**Returns:**\n\n * bool: True if Gpu Dynamics is enabled, otherwise False.\n",
"snippet":"value = physics_context.is_gpu_dynamics_enabled()\n",
"category":"method"
},
{
"title":"is_stablization_enabled",
"description":"Checks if stabilization is enabled.\n\n**Raises:**\n\n * Exception: If the prim path registered in context doesn't correspond to a valid prim path currently.\n\n**Returns:**\n\n * bool: True if stabilization is enabled, otherwise False.\n",
"snippet":"value = physics_context.is_stablization_enabled()\n",
"category":"method"
},
{
"title":"prim_path",
"description":"",
"snippet":"prim_path = physics_context.prim_path\n",
"category":"property"
},
{
"title":"set_bounce_threshold",
"description":"\\[summary\\]\n\n**Args:**\n\n * `value` (float): \\[description\\]\n\n**Raises:**\n\n * Exception: \\[description\\]\n",
"snippet":"physics_context.set_bounce_threshold(value=value)\n",
"category":"method"
},
{
"title":"set_broadphase_type",
"description":"Broadcast phase algorithm used in simulation.\n\n**Args:**\n\n * `broadcast_type` (str): type of broadcasting to be used, can be \"MBP\"\n\n**Raises:**\n\n * Exception: If the prim path registered in context doesn't correspond to a valid prim path currently.\n",
"snippet":"physics_context.set_broadphase_type(broadcast_type=broadcast_type)\n",
"category":"method"
},
{
"title":"set_enable_scene_query_support",
"description":"Sets the Enable Scene Query Support attribute in Physx Scene\n\n**Args:**\n\n * `enable_scene_query_support` (bool): Whether to enable scene query support\n\n**Raises:**\n\n * Exception: \\[description\\]\n",
"snippet":"physics_context.set_enable_scene_query_support(enable_scene_query_support=enable_scene_query_support)\n",
"category":"method"
},
{
"title":"set_friction_correlation_distance",
"description":"\\[summary\\]\n\n**Args:**\n\n * `value` (float): \\[description\\]\n\n**Raises:**\n\n * Exception: \\[description\\]\n",
"snippet":"physics_context.set_friction_correlation_distance(value=value)\n",
"category":"method"
},
{
"title":"set_friction_offset_threshold",
"description":"\\[summary\\]\n\n**Args:**\n\n * `value` (float): \\[description\\]\n\n**Raises:**\n\n * Exception: \\[description\\]\n",
"snippet":"physics_context.set_friction_offset_threshold(value=value)\n",
"category":"method"
},
{
"title":"set_gpu_collision_stack_size",
"description":"\\[summary\\]\n\n**Args:**\n\n * `value` (int): \\[description\\]\n\n**Raises:**\n\n * Exception: \\[description\\]\n",
"snippet":"physics_context.set_gpu_collision_stack_size(value=value)\n",
"category":"method"
},
{
"title":"set_gpu_found_lost_aggregate_pairs_capacity",
"description":"\\[summary\\]\n\n**Args:**\n\n * `value` (int): \\[description\\]\n\n**Raises:**\n\n * Exception: \\[description\\]\n",
"snippet":"physics_context.set_gpu_found_lost_aggregate_pairs_capacity(value=value)\n",
"category":"method"
},
{
"title":"set_gpu_found_lost_pairs_capacity",
"description":"\\[summary\\]\n\n**Args:**\n\n * `value` (int): \\[description\\]\n\n**Raises:**\n\n * Exception: \\[description\\]\n",
"snippet":"physics_context.set_gpu_found_lost_pairs_capacity(value=value)\n",
"category":"method"
},
{
"title":"set_gpu_heap_capacity",
"description":"\\[summary\\]\n\n**Args:**\n\n * `value` (int): \\[description\\]\n\n**Raises:**\n\n * Exception: \\[description\\]\n",
"snippet":"physics_context.set_gpu_heap_capacity(value=value)\n",
"category":"method"
},
{
"title":"set_gpu_max_num_partitions",
"description":"\\[summary\\]\n\n**Args:**\n\n * `value` (int): \\[description\\]\n\n**Raises:**\n\n * Exception: \\[description\\]\n",
"snippet":"physics_context.set_gpu_max_num_partitions(value=value)\n",
"category":"method"
},
{
"title":"set_gpu_max_particle_contacts",
"description":"\\[summary\\]\n\n**Args:**\n\n * `value` (int): \\[description\\]\n\n**Raises:**\n\n * Exception: \\[description\\]\n",
"snippet":"physics_context.set_gpu_max_particle_contacts(value=value)\n",
"category":"method"
},
{
"title":"set_gpu_max_rigid_contact_count",
"description":"\\[summary\\]\n\n**Args:**\n\n * `value` (int): \\[description\\]\n\n**Raises:**\n\n * Exception: \\[description\\]\n",
"snippet":"physics_context.set_gpu_max_rigid_contact_count(value=value)\n",
"category":"method"
},
{
"title":"set_gpu_max_rigid_patch_count",
"description":"\\[summary\\]\n\n**Args:**\n\n * `value` (int): \\[description\\]\n\n**Raises:**\n\n * Exception: \\[description\\]\n",
"snippet":"physics_context.set_gpu_max_rigid_patch_count(value=value)\n",
"category":"method"
},
{
"title":"set_gpu_max_soft_body_contacts",
"description":"\\[summary\\]\n\n**Args:**\n\n * `value` (int): \\[description\\]\n\n**Raises:**\n\n * Exception: \\[description\\]\n",
"snippet":"physics_context.set_gpu_max_soft_body_contacts(value=value)\n",
"category":"method"
},
{
"title":"set_gpu_temp_buffer_capacity",
"description":"\\[summary\\]\n\n**Args:**\n\n * `value` (int): \\[description\\]\n\n**Raises:**\n\n * Exception: \\[description\\]\n",
"snippet":"physics_context.set_gpu_temp_buffer_capacity(value=value)\n",
"category":"method"
},
{
"title":"set_gpu_total_aggregate_pairs_capacity",
"description":"\\[summary\\]\n\n**Args:**\n\n * `value` (int): \\[description\\]\n\n**Raises:**\n\n * Exception: \\[description\\]\n",
"snippet":"physics_context.set_gpu_total_aggregate_pairs_capacity(value=value)\n",
"category":"method"
},
{
"title":"set_gravity",
"description":"sets the gravity direction and magnitude.\n\n**Args:**\n\n * `value` (float): gravity value to be used in simulation.\n\n**Raises:**\n\n * Exception: If the prim path registered in context doesn't correspond to a valid prim path currently.\n",
"snippet":"physics_context.set_gravity(value=value)\n",
"category":"method"
},
{
"title":"set_invert_collision_group_filter",
"description":"\\[summary\\]\n\n**Args:**\n\n * `invert_collision_group_filter` (bool): \\[description\\]\n\n**Raises:**\n\n * Exception: \\[description\\]\n",
"snippet":"physics_context.set_invert_collision_group_filter(invert_collision_group_filter=invert_collision_group_filter)\n",
"category":"method"
},
{
"title":"set_physics_dt",
"description":"Sets the physics dt on the PhysicsScene\n\n**Args:**\n\n * `dt` (float, optional): physics dt. Defaults to 1.0/60.0.\n * `substeps` (int, optional): number of physics steps to run for before rendering a frame. Defaults to 1.\n\n**Raises:**\n\n * Exception: If the prim path registered in context doesn't correspond to a valid prim path currently.\n    ValueError: Physics dt must be a \\>= 0.\n    ValueError: Physics dt must be a \\<= 1.0.\n",
"snippet":"physics_context.set_physics_dt()\n",
"category":"method"
},
{
"title":"set_physx_update_transformations_settings",
"description":"Sets how physx syncs with the usd when transformations are updated.\n\n**Args:**\n\n * `update_to_fast_cache` (bool, optional): Uses Fast cache if set to True. Defaults to True.\n * `update_to_usd` (bool, optional): Updates to USD the transformations. Defaults to True.\n * `update_velocities_to_usd` (bool, optional): Updates Velocities to USD. Defaults to True.\n * `output_velocities_local_space` (bool, optional): Output the velocities in the local frame and not the world frame. Defaults to False.\n",
"snippet":"physics_context.set_physx_update_transformations_settings()\n",
"category":"method"
},
{
"title":"set_solver_type",
"description":"solver used for simulation.\n\n**Args:**\n\n * `solver_type` (str): can be \"TGS\" or \"PGS\". for references look at..\n\n**Raises:**\n\n * Exception: If the prim path registered in context doesn't correspond to a valid prim path currently.\n",
"snippet":"physics_context.set_solver_type(solver_type=solver_type)\n",
"category":"method"
},
{
"title":"use_fabric",
"description":"",
"snippet":"use_fabric = physics_context.use_fabric\n",
"category":"property"
},
{
"title":"use_gpu_pipeline",
"description":"",
"snippet":"use_gpu_pipeline = physics_context.use_gpu_pipeline\n",
"category":"property"
},
{
"title":"use_gpu_sim",
"description":"",
"snippet":"use_gpu_sim = physics_context.use_gpu_sim\n",
"category":"property"
},
{
"title":"warm_start",
"description":"",
"snippet":"physics_context.warm_start()\n",
"category":"method"
}
]
},
{
"title":"Prims",
"snippets":[
{
"title":"BaseSensor",
"snippets":[
{
"title":"import ...",
"description":"Import class",
"snippet":"from omni.isaac.core.prims import BaseSensor\n",
"category":"import"
},
{
"title":"BaseSensor",
"description":"Provides a common properties and methods to deal with prims as a sensor\n\n*Note:*\nThis class, which inherits from `XFormPrim`, does not currently add any new property/method to it.\nIts definition is oriented to future implementations.\n\n**Args:**\n\n * `prim_path` (str): prim path of the Prim to encapsulate or create.\n * `name` (str, optional): shortname to be used as a key by Scene class. Note: needs to be unique if the object is added to the Scene. Defaults to \"base\\_sensor\".\n * `position` (Optional\\[Sequence\\[float\\]\\], optional): position in the world frame of the prim. shape is (3, ). Defaults to None, which means left unchanged.\n * `translation` (Optional\\[Sequence\\[float\\]\\], optional): translation in the local frame of the prim (with respect to its parent prim). shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the world/ local frame of the prim (depends if translation or position is specified). quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n * `scale` (Optional\\[Sequence\\[float\\]\\], optional): local scale to be applied to the prim's dimensions. shape is (3, ). Defaults to None, which means left unchanged.\n * `visible` (bool, optional): set to false for an invisible prim in the stage while rendering. Defaults to True.\n\n**Raises:**\n\n * Exception: if translation and position defined at the same time\n",
"snippet":"base_sensor = BaseSensor(prim_path=prim_path)\n",
"category":"class"
},
{
"title":"apply_visual_material",
"description":"Apply visual material to the held prim and optionally its descendants.\n\n**Args:**\n\n * `visual_material` (VisualMaterial): visual material to be applied to the held prim. Currently supports PreviewSurface, OmniPBR and OmniGlass.\n * `weaker_than_descendants` (bool, optional): True if the material shouldn't override the descendants materials, otherwise False. Defaults to False.\n\n---\n**Example:**\n\n```python\n>>> from omni.isaac.core.materials import OmniGlass\n>>>\n>>> # create a dark-red glass visual material\n>>> material = OmniGlass(\n...     prim_path=\"/World/material/glass\",  # path to the material prim to create\n...     ior=1.25,\n...     depth=0.001,\n...     thin_walled=False,\n...     color=np.array([0.5, 0.0, 0.0])\n... )\n>>> prim.apply_visual_material(material)\n```\n",
"snippet":"base_sensor.apply_visual_material(visual_material=visual_material)\n",
"category":"method"
},
{
"title":"get_applied_visual_material",
"description":"Return the current applied visual material in case it was applied using apply\\_visual\\_material\nor it's one of the following materials that was already applied before: PreviewSurface, OmniPBR and OmniGlass.\n\n**Returns:**\n\n * VisualMaterial: the current applied visual material if its type is currently supported.\n\n---\n**Example:**\n\n```python\n>>> # given a visual material applied\n>>> prim.get_applied_visual_material()\n<omni.isaac.core.materials.omni_glass.OmniGlass object at 0x7f36263106a0>\n```\n",
"snippet":"applied_visual_material = base_sensor.get_applied_visual_material()\n",
"category":"method"
},
{
"title":"get_default_state",
"description":"Get the default prim states (spatial position and orientation).\n\n**Returns:**\n\n * XFormPrimState: an object that contains the default state of the prim (position and orientation)\n\n---\n**Example:**\n\n```python\n>>> state = prim.get_default_state()\n>>> state\n<omni.isaac.core.utils.types.XFormPrimState object at 0x7f33addda650>\n>>>\n>>> state.position\n[-4.5299529e-08 -1.8347054e-09 -2.8610229e-08]\n>>> state.orientation\n[1. 0. 0. 0.]\n```\n",
"snippet":"default_state = base_sensor.get_default_state()\n",
"category":"method"
},
{
"title":"get_local_pose",
"description":"Get prim's pose with respect to the local frame (the prim's parent frame)\n\n**Returns:**\n\n * Tuple\\[np.ndarray, np.ndarray\\]: first index is the position in the local frame (with shape (3, )).\n    Second index is quaternion orientation (with shape (4, )) in the local frame\n\n---\n**Example:**\n\n```python\n>>> # if the prim is in position (1.0, 0.5, 0.0) with respect to the world frame\n>>> position, orientation = prim.get_local_pose()\n>>> position\n[0. 0. 0.]\n>>> orientation\n[0. 0. 0.]\n```\n",
"snippet":"local_pose = base_sensor.get_local_pose()\n",
"category":"method"
},
{
"title":"get_local_scale",
"description":"Get prim's scale with respect to the local frame (the parent's frame)\n\n**Returns:**\n\n * np.ndarray: scale applied to the prim's dimensions in the local frame. shape is (3, ).\n\n---\n**Example:**\n\n```python\n>>> prim.get_local_scale()\n[1. 1. 1.]\n```\n",
"snippet":"local_scale = base_sensor.get_local_scale()\n",
"category":"method"
},
{
"title":"get_visibility",
"description":"**Returns:**\n\n * bool: true if the prim is visible in stage. false otherwise.\n\n---\n**Example:**\n\n```python\n>>> # get the visible state of an visible prim on the stage\n>>> prim.get_visibility()\nTrue\n```\n",
"snippet":"visibility = base_sensor.get_visibility()\n",
"category":"method"
},
{
"title":"get_world_pose",
"description":"Get prim's pose with respect to the world's frame\n\n**Returns:**\n\n * Tuple\\[np.ndarray, np.ndarray\\]: first index is the position in the world frame (with shape (3, )).\n    Second index is quaternion orientation (with shape (4, )) in the world frame\n\n---\n**Example:**\n\n```python\n>>> # if the prim is in position (1.0, 0.5, 0.0) with respect to the world frame\n>>> position, orientation = prim.get_world_pose()\n>>> position\n[1.  0.5 0. ]\n>>> orientation\n[1. 0. 0. 0.]\n```\n",
"snippet":"world_pose = base_sensor.get_world_pose()\n",
"category":"method"
},
{
"title":"get_world_scale",
"description":"Get prim's scale with respect to the world's frame\n\n**Returns:**\n\n * np.ndarray: scale applied to the prim's dimensions in the world frame. shape is (3, ).\n\n---\n**Example:**\n\n```python\n>>> prim.get_world_scale()\n[1. 1. 1.]\n```\n",
"snippet":"world_scale = base_sensor.get_world_scale()\n",
"category":"method"
},
{
"title":"initialize",
"description":"Create a physics simulation view if not passed and using PhysX tensor API\n\n*Note:*\nIf the prim has been added to the world scene (e.g., `world.scene.add(prim)`),\nit will be automatically initialized when the world is reset (e.g., `world.reset()`).\n\n**Args:**\n\n * `physics_sim_view` (omni.physics.tensors.SimulationView, optional): current physics simulation view. Defaults to None.\n\n---\n**Example:**\n\n```python\n>>> prim.initialize()\n```\n",
"snippet":"base_sensor.initialize()\n",
"category":"method"
},
{
"title":"initialize",
"description":"Create a physics simulation view if not passed and using PhysX tensor API\n\n*Note:*\nIf the prim has been added to the world scene (e.g., `world.scene.add(prim)`),\nit will be automatically initialized when the world is reset (e.g., `world.reset()`).\n\n**Args:**\n\n * `physics_sim_view` (omni.physics.tensors.SimulationView, optional): current physics simulation view. Defaults to None.\n\n---\n**Example:**\n\n```python\n>>> prim.initialize()\n```\n",
"snippet":"base_sensor.initialize()\n",
"category":"method"
},
{
"title":"is_valid",
"description":"Check if the prim path has a valid USD Prim at it\n\n**Returns:**\n\n * bool: True is the current prim path corresponds to a valid prim in stage. False otherwise.\n\n---\n**Example:**\n\n```python\n>>> # given an existing and valid prim\n>>> prims.is_valid()\nTrue\n```\n",
"snippet":"value = base_sensor.is_valid()\n",
"category":"method"
},
{
"title":"is_visual_material_applied",
"description":"Check if there is a visual material applied\n\n**Returns:**\n\n * bool: True if there is a visual material applied. False otherwise.\n\n---\n**Example:**\n\n```python\n>>> # given a visual material applied\n>>> prim.is_visual_material_applied()\nTrue\n```\n",
"snippet":"value = base_sensor.is_visual_material_applied()\n",
"category":"method"
},
{
"title":"post_reset",
"description":"",
"snippet":"base_sensor.post_reset()\n",
"category":"method"
},
{
"title":"post_reset",
"description":"Reset the prim to its default state (position and orientation).\n\n*Note:*\nFor an articulation, in addition to configuring the root prim's default position and spatial orientation\n(defined via the `set_default_state` method), the joint's positions, velocities, and efforts\n(defined via the `set_joints_default_state` method) are imposed\n\n---\n**Example:**\n\n```python\n>>> prim.post_reset()\n```\n",
"snippet":"base_sensor.post_reset()\n",
"category":"method"
},
{
"title":"set_default_state",
"description":"Set the default state of the prim (position and orientation), that will be used after each reset.\n\n**Args:**\n\n * `position` (Optional\\[Sequence\\[float\\]\\], optional): position in the world frame of the prim. shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the world frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n\n---\n**Example:**\n\n```python\n>>> # configure default state\n>>> prim.set_default_state(position=np.array([1.0, 0.5, 0.0]), orientation=np.array([1, 0, 0, 0]))\n>>>\n>>> # set default states during post-reset\n>>> prim.post_reset()\n```\n",
"snippet":"base_sensor.set_default_state()\n",
"category":"method"
},
{
"title":"set_local_pose",
"description":"Set prim's pose with respect to the local frame (the prim's parent frame).\n\n*Warning:*\nThis method will change (teleport) the prim pose immediately to the indicated value\n\n**Args:**\n\n * `translation` (Optional\\[Sequence\\[float\\]\\], optional): translation in the local frame of the prim (with respect to its parent prim). shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the local frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n\n*Hint:*\nThis method belongs to the methods used to set the prim state\n\n---\n**Example:**\n\n```python\n>>> prim.set_local_pose(translation=np.array([1.0, 0.5, 0.0]), orientation=np.array([1., 0., 0., 0.]))\n```\n",
"snippet":"base_sensor.set_local_pose()\n",
"category":"method"
},
{
"title":"set_local_scale",
"description":"Set prim's scale with respect to the local frame (the prim's parent frame).\n\n**Args:**\n\n * `scale` (Optional\\[Sequence\\[float\\]\\]): scale to be applied to the prim's dimensions. shape is (3, ). Defaults to None, which means left unchanged.\n\n---\n**Example:**\n\n```python\n>>> # scale prim 10 times smaller\n>>> prim.set_local_scale(np.array([0.1, 0.1, 0.1]))\n```\n",
"snippet":"base_sensor.set_local_scale(scale=scale)\n",
"category":"method"
},
{
"title":"set_visibility",
"description":"Set the visibility of the prim in stage\n\n**Args:**\n\n * `visible` (bool): flag to set the visibility of the usd prim in stage.\n\n---\n**Example:**\n\n```python\n>>> # make prim not visible in the stage\n>>> prim.set_visibility(visible=False)\n```\n",
"snippet":"base_sensor.set_visibility(visible=visible)\n",
"category":"method"
},
{
"title":"set_world_pose",
"description":"Ses prim's pose with respect to the world's frame\n\n*Warning:*\nThis method will change (teleport) the prim pose immediately to the indicated value\n\n**Args:**\n\n * `position` (Optional\\[Sequence\\[float\\]\\], optional): position in the world frame of the prim. shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the world frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n\n*Hint:*\nThis method belongs to the methods used to set the prim state\n\n---\n**Example:**\n\n```python\n>>> prim.set_world_pose(position=np.array([1.0, 0.5, 0.0]), orientation=np.array([1., 0., 0., 0.]))\n```\n",
"snippet":"base_sensor.set_world_pose()\n",
"category":"method"
}
]
},
{
"title":"ClothPrim",
"snippets":[
{
"title":"import ...",
"description":"Import class",
"snippet":"from omni.isaac.core.prims import ClothPrim\n",
"category":"import"
},
{
"title":"ClothPrim",
"description":"Cloth primitive object provide functionalities to create and control cloth parameters\n",
"snippet":"cloth_prim = ClothPrim(prim_path=prim_path, particle_system=particle_system)\n",
"category":"class"
},
{
"title":"apply_visual_material",
"description":"Apply visual material to the held prim and optionally its descendants.\n\n**Args:**\n\n * `visual_material` (VisualMaterial): visual material to be applied to the held prim. Currently supports PreviewSurface, OmniPBR and OmniGlass.\n * `weaker_than_descendants` (bool, optional): True if the material shouldn't override the descendants materials, otherwise False. Defaults to False.\n\n---\n**Example:**\n\n```python\n>>> from omni.isaac.core.materials import OmniGlass\n>>>\n>>> # create a dark-red glass visual material\n>>> material = OmniGlass(\n...     prim_path=\"/World/material/glass\",  # path to the material prim to create\n...     ior=1.25,\n...     depth=0.001,\n...     thin_walled=False,\n...     color=np.array([0.5, 0.0, 0.0])\n... )\n>>> prim.apply_visual_material(material)\n```\n",
"snippet":"cloth_prim.apply_visual_material(visual_material=visual_material)\n",
"category":"method"
},
{
"title":"get_applied_visual_material",
"description":"Return the current applied visual material in case it was applied using apply\\_visual\\_material\nor it's one of the following materials that was already applied before: PreviewSurface, OmniPBR and OmniGlass.\n\n**Returns:**\n\n * VisualMaterial: the current applied visual material if its type is currently supported.\n\n---\n**Example:**\n\n```python\n>>> # given a visual material applied\n>>> prim.get_applied_visual_material()\n<omni.isaac.core.materials.omni_glass.OmniGlass object at 0x7f36263106a0>\n```\n",
"snippet":"applied_visual_material = cloth_prim.get_applied_visual_material()\n",
"category":"method"
},
{
"title":"get_cloth_bend_stiffness",
"description":"Reports a single value that would be used to generate the stiffnesses. This API does not report the actually created stiffnesses.\n\n**Returns:**\n\n * float: The bend stiffness.\n",
"snippet":"cloth_bend_stiffness = cloth_prim.get_cloth_bend_stiffness()\n",
"category":"method"
},
{
"title":"get_cloth_damping",
"description":"Reports a single value that would be used to generate the dampings. This API does not report the actually created dampings.\n\n**Returns:**\n\n * float: The spring damping.\n",
"snippet":"cloth_damping = cloth_prim.get_cloth_damping()\n",
"category":"method"
},
{
"title":"get_cloth_shear_stiffness",
"description":"Reports a single value that would be used to generate the stiffnesses. This API does not report the actually created stiffnesses.\n\n**Returns:**\n\n * float: The shear stiffness.\n",
"snippet":"cloth_shear_stiffness = cloth_prim.get_cloth_shear_stiffness()\n",
"category":"method"
},
{
"title":"get_cloth_stretch_stiffness",
"description":"Reports a single value that would be used to generate the stiffnesses. This API does not report the actually created stiffnesses.\n\n**Returns:**\n\n * float: The stretch stiffness.\n",
"snippet":"cloth_stretch_stiffness = cloth_prim.get_cloth_stretch_stiffness()\n",
"category":"method"
},
{
"title":"get_current_dynamic_state",
"description":"Return the DynamicState that contains the position and orientation of the cloth prim\n\n**Returns:**\n\n * DynamicState: position (np.ndarray, optional): position in the world frame of the prim. shape is (3, ). Defaults to None, which means left unchanged. orientation (np.ndarray, optional): quaternion orientation in the world frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n",
"snippet":"current_dynamic_state = cloth_prim.get_current_dynamic_state()\n",
"category":"method"
},
{
"title":"get_default_state",
"description":"Get the default prim states (spatial position and orientation).\n\n**Returns:**\n\n * XFormPrimState: an object that contains the default state of the prim (position and orientation)\n\n---\n**Example:**\n\n```python\n>>> state = prim.get_default_state()\n>>> state\n<omni.isaac.core.utils.types.XFormPrimState object at 0x7f33addda650>\n>>>\n>>> state.position\n[-4.5299529e-08 -1.8347054e-09 -2.8610229e-08]\n>>> state.orientation\n[1. 0. 0. 0.]\n```\n",
"snippet":"default_state = cloth_prim.get_default_state()\n",
"category":"method"
},
{
"title":"get_local_pose",
"description":"Get prim's pose with respect to the local frame (the prim's parent frame)\n\n**Returns:**\n\n * Tuple\\[np.ndarray, np.ndarray\\]: first index is the position in the local frame (with shape (3, )).\n    Second index is quaternion orientation (with shape (4, )) in the local frame\n\n---\n**Example:**\n\n```python\n>>> # if the prim is in position (1.0, 0.5, 0.0) with respect to the world frame\n>>> position, orientation = prim.get_local_pose()\n>>> position\n[0. 0. 0.]\n>>> orientation\n[0. 0. 0.]\n```\n",
"snippet":"local_pose = cloth_prim.get_local_pose()\n",
"category":"method"
},
{
"title":"get_local_scale",
"description":"Get prim's scale with respect to the local frame (the parent's frame)\n\n**Returns:**\n\n * np.ndarray: scale applied to the prim's dimensions in the local frame. shape is (3, ).\n\n---\n**Example:**\n\n```python\n>>> prim.get_local_scale()\n[1. 1. 1.]\n```\n",
"snippet":"local_scale = cloth_prim.get_local_scale()\n",
"category":"method"
},
{
"title":"get_particle_group",
"description":"**Returns:**\n\n * bool: self collision.\n",
"snippet":"particle_group = cloth_prim.get_particle_group()\n",
"category":"method"
},
{
"title":"get_pressure",
"description":"**Returns:**\n\n * float: pressure value.\n",
"snippet":"pressure = cloth_prim.get_pressure()\n",
"category":"method"
},
{
"title":"get_self_collision",
"description":"**Returns:**\n\n * bool: self collision.\n",
"snippet":"self_collision = cloth_prim.get_self_collision()\n",
"category":"method"
},
{
"title":"get_self_collision_filter",
"description":"**Returns:**\n\n * bool: self collision filter.\n",
"snippet":"self_collision_filter = cloth_prim.get_self_collision_filter()\n",
"category":"method"
},
{
"title":"get_spring_damping",
"description":"Gets damping values of spring constraints\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor\\]: The spring damping.\n",
"snippet":"spring_damping = cloth_prim.get_spring_damping()\n",
"category":"method"
},
{
"title":"get_stretch_stiffness",
"description":"Gets stretch stiffness values of spring constraints\n\n**Returns:**\n\n * float: The stretch stiffness.\n",
"snippet":"stretch_stiffness = cloth_prim.get_stretch_stiffness()\n",
"category":"method"
},
{
"title":"get_visibility",
"description":"**Returns:**\n\n * bool: true if the prim is visible in stage. false otherwise.\n\n---\n**Example:**\n\n```python\n>>> # get the visible state of an visible prim on the stage\n>>> prim.get_visibility()\nTrue\n```\n",
"snippet":"visibility = cloth_prim.get_visibility()\n",
"category":"method"
},
{
"title":"get_world_pose",
"description":"Get prim's pose with respect to the world's frame\n\n**Returns:**\n\n * Tuple\\[np.ndarray, np.ndarray\\]: first index is the position in the world frame (with shape (3, )).\n    Second index is quaternion orientation (with shape (4, )) in the world frame\n\n---\n**Example:**\n\n```python\n>>> # if the prim is in position (1.0, 0.5, 0.0) with respect to the world frame\n>>> position, orientation = prim.get_world_pose()\n>>> position\n[1.  0.5 0. ]\n>>> orientation\n[1. 0. 0. 0.]\n```\n",
"snippet":"world_pose = cloth_prim.get_world_pose()\n",
"category":"method"
},
{
"title":"get_world_scale",
"description":"Get prim's scale with respect to the world's frame\n\n**Returns:**\n\n * np.ndarray: scale applied to the prim's dimensions in the world frame. shape is (3, ).\n\n---\n**Example:**\n\n```python\n>>> prim.get_world_scale()\n[1. 1. 1.]\n```\n",
"snippet":"world_scale = cloth_prim.get_world_scale()\n",
"category":"method"
},
{
"title":"initialize",
"description":"Create a physics simulation view if not passed and using PhysX tensor API\n\n*Note:*\nIf the prim has been added to the world scene (e.g., `world.scene.add(prim)`),\nit will be automatically initialized when the world is reset (e.g., `world.reset()`).\n\n**Args:**\n\n * `physics_sim_view` (omni.physics.tensors.SimulationView, optional): current physics simulation view. Defaults to None.\n\n---\n**Example:**\n\n```python\n>>> prim.initialize()\n```\n",
"snippet":"cloth_prim.initialize()\n",
"category":"method"
},
{
"title":"is_valid",
"description":"Check if the prim path has a valid USD Prim at it\n\n**Returns:**\n\n * bool: True is the current prim path corresponds to a valid prim in stage. False otherwise.\n\n---\n**Example:**\n\n```python\n>>> # given an existing and valid prim\n>>> prims.is_valid()\nTrue\n```\n",
"snippet":"value = cloth_prim.is_valid()\n",
"category":"method"
},
{
"title":"is_visual_material_applied",
"description":"Check if there is a visual material applied\n\n**Returns:**\n\n * bool: True if there is a visual material applied. False otherwise.\n\n---\n**Example:**\n\n```python\n>>> # given a visual material applied\n>>> prim.is_visual_material_applied()\nTrue\n```\n",
"snippet":"value = cloth_prim.is_visual_material_applied()\n",
"category":"method"
},
{
"title":"mesh",
"description":"**Returns:**\n\n * Usd.Prim: USD Prim object that this object tracks.\n",
"snippet":"mesh = cloth_prim.mesh\n",
"category":"property"
},
{
"title":"post_reset",
"description":"Reset the prim to its default state (position and orientation).\n\n*Note:*\nFor an articulation, in addition to configuring the root prim's default position and spatial orientation\n(defined via the `set_default_state` method), the joint's positions, velocities, and efforts\n(defined via the `set_joints_default_state` method) are imposed\n\n---\n**Example:**\n\n```python\n>>> prim.post_reset()\n```\n",
"snippet":"cloth_prim.post_reset()\n",
"category":"method"
},
{
"title":"set_cloth_bend_stiffness",
"description":"Sets a single bend stiffness value to all springs constraints in the cloth\n\n**Args:**\n\n * `stiffness` (float): The cloth springs bend stiffness value. Range: \\[0 , inf), Units: force/distance = mass/second/second\n",
"snippet":"cloth_prim.set_cloth_bend_stiffness(stiffness=stiffness)\n",
"category":"method"
},
{
"title":"set_cloth_damping",
"description":"Sets a single damping value to all springs constraints in the cloth\n\n**Args:**\n\n * `damping` (float): The cloth springs damping value. Range: \\[0 , inf), Units: force/velocity = mass/second\n",
"snippet":"cloth_prim.set_cloth_damping(damping=damping)\n",
"category":"method"
},
{
"title":"set_cloth_shear_stiffness",
"description":"Sets a single shear stiffness value to all springs constraints in the cloth\n\n**Args:**\n\n * `stiffness` (float): The cloth springs shear stiffness value. Range: \\[0 , inf), Units: force/distance = mass/second/second\n",
"snippet":"cloth_prim.set_cloth_shear_stiffness(stiffness=stiffness)\n",
"category":"method"
},
{
"title":"set_cloth_stretch_stiffness",
"description":"Sets a single stretch stiffness value to all springs constraints in the cloth\n\n**Args:**\n\n * `stiffness` (Union\\[np.ndarray, torch.Tensor\\]): The cloth springs stretch stiffness value. Range: \\[0 , inf), Units: force/distance = mass/second/second\n",
"snippet":"cloth_prim.set_cloth_stretch_stiffness(stiffness=stiffness)\n",
"category":"method"
},
{
"title":"set_default_state",
"description":"Set the default state of the prim (position and orientation), that will be used after each reset.\n\n**Args:**\n\n * `position` (Optional\\[Sequence\\[float\\]\\], optional): position in the world frame of the prim. shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the world frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n\n---\n**Example:**\n\n```python\n>>> # configure default state\n>>> prim.set_default_state(position=np.array([1.0, 0.5, 0.0]), orientation=np.array([1, 0, 0, 0]))\n>>>\n>>> # set default states during post-reset\n>>> prim.post_reset()\n```\n",
"snippet":"cloth_prim.set_default_state()\n",
"category":"method"
},
{
"title":"set_local_pose",
"description":"Set prim's pose with respect to the local frame (the prim's parent frame).\n\n*Warning:*\nThis method will change (teleport) the prim pose immediately to the indicated value\n\n**Args:**\n\n * `translation` (Optional\\[Sequence\\[float\\]\\], optional): translation in the local frame of the prim (with respect to its parent prim). shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the local frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n\n*Hint:*\nThis method belongs to the methods used to set the prim state\n\n---\n**Example:**\n\n```python\n>>> prim.set_local_pose(translation=np.array([1.0, 0.5, 0.0]), orientation=np.array([1., 0., 0., 0.]))\n```\n",
"snippet":"cloth_prim.set_local_pose()\n",
"category":"method"
},
{
"title":"set_local_scale",
"description":"Set prim's scale with respect to the local frame (the prim's parent frame).\n\n**Args:**\n\n * `scale` (Optional\\[Sequence\\[float\\]\\]): scale to be applied to the prim's dimensions. shape is (3, ). Defaults to None, which means left unchanged.\n\n---\n**Example:**\n\n```python\n>>> # scale prim 10 times smaller\n>>> prim.set_local_scale(np.array([0.1, 0.1, 0.1]))\n```\n",
"snippet":"cloth_prim.set_local_scale(scale=scale)\n",
"category":"method"
},
{
"title":"set_particle_group",
"description":"**Args:**\n\n    particle\\_group(int): particle group.\n",
"snippet":"cloth_prim.set_particle_group(particle_group=particle_group)\n",
"category":"method"
},
{
"title":"set_pressure",
"description":"**Args:**\n\n    pressure(float): pressure value.\n",
"snippet":"cloth_prim.set_pressure(pressure=pressure)\n",
"category":"method"
},
{
"title":"set_self_collision",
"description":"**Args:**\n\n    self\\_collision(bool): self collision.\n",
"snippet":"cloth_prim.set_self_collision(self_collision=self_collision)\n",
"category":"method"
},
{
"title":"set_self_collision_filter",
"description":"**Args:**\n\n    self\\_collision\\_filter(bool): self collision filter.\n",
"snippet":"cloth_prim.set_self_collision_filter(self_collision_filter=self_collision_filter)\n",
"category":"method"
},
{
"title":"set_spring_damping",
"description":"Sets damping values of spring constraints in the cloth\n\n**Args:**\n\n * `damping` (List\\[float\\]): The damping values of springs. Range: \\[0 , inf), Units: force/distance = mass/second\n",
"snippet":"cloth_prim.set_spring_damping(damping=damping)\n",
"category":"method"
},
{
"title":"set_stretch_stiffness",
"description":"Sets stretch stiffness values of spring constraints in the cloth\nIt represents a stiffness for linear springs placed between particles to counteract stretching.\n\n**Args:**\n\n * `stiffness` (Union\\[np.ndarray, torch.Tensor\\]): The stretch stiffnesses. Range: \\[0 , inf), Units: force/distance = mass/second/second\n",
"snippet":"cloth_prim.set_stretch_stiffness(stiffness=stiffness)\n",
"category":"method"
},
{
"title":"set_visibility",
"description":"Set the visibility of the prim in stage\n\n**Args:**\n\n * `visible` (bool): flag to set the visibility of the usd prim in stage.\n\n---\n**Example:**\n\n```python\n>>> # make prim not visible in the stage\n>>> prim.set_visibility(visible=False)\n```\n",
"snippet":"cloth_prim.set_visibility(visible=visible)\n",
"category":"method"
},
{
"title":"set_world_pose",
"description":"Ses prim's pose with respect to the world's frame\n\n*Warning:*\nThis method will change (teleport) the prim pose immediately to the indicated value\n\n**Args:**\n\n * `position` (Optional\\[Sequence\\[float\\]\\], optional): position in the world frame of the prim. shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the world frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n\n*Hint:*\nThis method belongs to the methods used to set the prim state\n\n---\n**Example:**\n\n```python\n>>> prim.set_world_pose(position=np.array([1.0, 0.5, 0.0]), orientation=np.array([1., 0., 0., 0.]))\n```\n",
"snippet":"cloth_prim.set_world_pose()\n",
"category":"method"
}
]
},
{
"title":"ClothPrimView",
"snippets":[
{
"title":"import ...",
"description":"Import class",
"snippet":"from omni.isaac.core.prims import ClothPrimView\n",
"category":"import"
},
{
"title":"ClothPrimView",
"description":"The view class for cloth prims.\n",
"snippet":"cloth_prim_view = ClothPrimView(prim_paths_expr=prim_paths_expr)\n",
"category":"class"
},
{
"title":"apply_visual_materials",
"description":"Apply visual material to the prims and optionally their prim descendants.\n\n**Args:**\n\n * `visual_materials` (Union\\[VisualMaterial, List\\[VisualMaterial\\]\\]): visual materials to be applied to the prims. Currently supports PreviewSurface, OmniPBR and OmniGlass. If a list is provided then its size has to be equal the view's size or indices size. If one material is provided it will be applied to all prims in the view.\n * `weaker_than_descendants` (Optional\\[Union\\[bool, List\\[bool\\]\\]\\], optional): True if the material shouldn't override the descendants materials, otherwise False. Defaults to False. If a list of visual materials is provided then a list has to be provided with the same size for this arg as well.\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Raises:**\n\n * Exception: length of visual materials != length of prims indexed\n    Exception: length of visual materials != length of weaker descendants bools arg\n\n---\n**Example:**\n\n```python\n>>> from omni.isaac.core.materials import OmniGlass\n>>>\n>>> # create a dark-red glass visual material\n>>> material = OmniGlass(\n...     prim_path=\"/World/material/glass\",  # path to the material prim to create\n...     ior=1.25,\n...     depth=0.001,\n...     thin_walled=False,\n...     color=np.array([0.5, 0.0, 0.0])\n... )\n>>> prims.apply_visual_materials(material)\n```\n",
"snippet":"cloth_prim_view.apply_visual_materials(visual_materials=visual_materials)\n",
"category":"method"
},
{
"title":"count",
"description":"**Returns:**\n\n * int: cloth counts.\n",
"snippet":"count = cloth_prim_view.count\n",
"category":"property"
},
{
"title":"get_applied_visual_materials",
"description":"Get the current applied visual materials\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Returns:**\n\n * List\\[VisualMaterial\\]: a list of the current applied visual materials to the prims if its type is currently supported.\n\n---\n**Example:**\n\n```python\n>>> # get all applied visual materials. Returned size is 5 for the example: 5 envs\n>>> prims.get_applied_visual_materials()\n[<omni.isaac.core.materials.omni_glass.OmniGlass object at 0x7f829c165de0>,\n <omni.isaac.core.materials.omni_glass.OmniGlass object at 0x7f829c165de0>,\n <omni.isaac.core.materials.omni_glass.OmniGlass object at 0x7f829c165de0>,\n <omni.isaac.core.materials.omni_glass.OmniGlass object at 0x7f829c165de0>,\n <omni.isaac.core.materials.omni_glass.OmniGlass object at 0x7f829c165de0>]\n>>>\n>>> # get the applied visual materials for the first, middle and last of the 5 envs. Returned size is 3\n>>> prims.get_applied_visual_materials(indices=np.array([0, 2, 4]))\n[<omni.isaac.core.materials.omni_glass.OmniGlass object at 0x7f829c165de0>,\n <omni.isaac.core.materials.omni_glass.OmniGlass object at 0x7f829c165de0>,\n <omni.isaac.core.materials.omni_glass.OmniGlass object at 0x7f829c165de0>]\n```\n",
"snippet":"applied_visual_materials = cloth_prim_view.get_applied_visual_materials()\n",
"category":"method"
},
{
"title":"get_cloths_bend_stiffnesses",
"description":"Gets the value of bend stiffness set to all the springs within cloths indicated by the indices.\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which cloth prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[Tuple\\[np.ndarray, np.ndarray\\], Tuple\\[torch.Tensor, torch.Tensor\\]\\]: bend stiffness tensor with shape (M, )\n",
"snippet":"cloths_bend_stiffnesses = cloth_prim_view.get_cloths_bend_stiffnesses()\n",
"category":"method"
},
{
"title":"get_cloths_dampings",
"description":"Gets the value of damping set for all the springs within cloths indicated by the indices.\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which cloth prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[Tuple\\[np.ndarray, np.ndarray\\], Tuple\\[torch.Tensor, torch.Tensor\\]\\]: damping tensor with shape (M, )\n",
"snippet":"cloths_dampings = cloth_prim_view.get_cloths_dampings()\n",
"category":"method"
},
{
"title":"get_cloths_shear_stiffnesses",
"description":"Gets the value of shear stiffness set to all the springs within cloths indicated by the indices.\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which cloth prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[Tuple\\[np.ndarray, np.ndarray\\], Tuple\\[torch.Tensor, torch.Tensor\\]\\]: shear stiffness tensor with shape (M, )\n",
"snippet":"cloths_shear_stiffnesses = cloth_prim_view.get_cloths_shear_stiffnesses()\n",
"category":"method"
},
{
"title":"get_cloths_stretch_stiffnesses",
"description":"Gets the value of stretch stiffness set to all the springs within cloths indicated by the indices.\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which cloth prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[Tuple\\[np.ndarray, np.ndarray\\], Tuple\\[torch.Tensor, torch.Tensor\\]\\]: stretch stiffness tensor with shape (M, )\n",
"snippet":"cloths_stretch_stiffnesses = cloth_prim_view.get_cloths_stretch_stiffnesses()\n",
"category":"method"
},
{
"title":"get_default_state",
"description":"Get the default states (positions and orientations) defined with the `set_default_state` method\n\n**Returns:**\n\n * XFormPrimViewState: returns the default state of the prims that is used after each reset.\n\n---\n**Example:**\n\n```python\n>>> state = prims.get_default_state()\n>>> state\n<omni.isaac.core.utils.types.XFormPrimViewState object at 0x7f82f73e3070>\n>>> state.positions\n[[ 1.5  -0.75  0.  ]\n [ 1.5   0.75  0.  ]\n [ 0.   -0.75  0.  ]\n [ 0.    0.75  0.  ]\n [-1.5  -0.75  0.  ]]\n>>> state.orientations\n[[1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]]\n```\n",
"snippet":"default_state = cloth_prim_view.get_default_state()\n",
"category":"method"
},
{
"title":"get_local_poses",
"description":"Get prim poses in the view with respect to the local frame (the prim's parent frame)\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Returns:**\n\n * Union\\[Tuple\\[np.ndarray, np.ndarray\\], Tuple\\[torch.Tensor, torch.Tensor\\], Tuple\\[wp.indexedarray, wp.indexedarray\\]\\]: first index is translations in the local frame of the prims. shape is (M, 3). second index is quaternion orientations in the local frame of the prims. quaternion is scalar-first (w, x, y, z). shape is (M, 4).\n\n---\n**Example:**\n\n```python\n>>> # get all prims poses with respect to the local frame.\n>>> # Returned shape is position (5, 3) and orientation (5, 4) for the example: 5 envs\n>>> positions, orientations = prims.get_local_poses()\n>>> positions\n[[ 1.5  -0.75  0.  ]\n [ 1.5   0.75  0.  ]\n [ 0.   -0.75  0.  ]\n [ 0.    0.75  0.  ]\n [-1.5  -0.75  0.  ]]\n>>> orientations\n[[1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]]\n>>>\n>>> # get only the prims poses with respect to the local frame for the first, middle and last of the 5 envs.\n>>> # Returned shape is position (3, 3) and orientation (3, 4) for the example: 3 envs selected\n>>> positions, orientations = prims.get_local_poses(indices=np.array([0, 2, 4]))\n>>> positions\n[[ 1.5  -0.75  0.  ]\n [ 0.   -0.75  0.  ]\n [-1.5  -0.75  0.  ]]\n>>> orientations\n[[1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]]\n```\n",
"snippet":"local_poses = cloth_prim_view.get_local_poses()\n",
"category":"method"
},
{
"title":"get_local_scales",
"description":"Get prim scales in the view with respect to the local frame (the parent's frame).\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: scales applied to the prim's dimensions in the local frame. shape is (M, 3).\n\n---\n**Example:**\n\n```python\n>>> # get all prims scales with respect to the local frame.\n>>> # Returned shape is (5, 3) for the example: 5 envs\n>>> prims.get_local_scales()\n[[1. 1. 1.]\n [1. 1. 1.]\n [1. 1. 1.]\n [1. 1. 1.]\n [1. 1. 1.]]\n>>>\n>>> # get only the prims scales with respect to the local frame for the first, middle and last of the 5 envs.\n>>> # Returned shape is (3, 3) for the example: 3 envs selected\n>>> prims.get_local_scales(indices=np.array([0, 2, 4]))\n[[1. 1. 1.]\n [1. 1. 1.]\n [1. 1. 1.]]\n```\n",
"snippet":"local_scales = cloth_prim_view.get_local_scales()\n",
"category":"method"
},
{
"title":"get_particle_groups",
"description":"Gets the particle groups of the cloths indicated by the indices.\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which cloth prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[Tuple\\[np.ndarray, np.ndarray\\], Tuple\\[torch.Tensor, torch.Tensor\\]\\]: particle groups with shape (M, ).\n",
"snippet":"particle_groups = cloth_prim_view.get_particle_groups()\n",
"category":"method"
},
{
"title":"get_particle_masses",
"description":"Gets the particle masses for the cloths indicated by the indices.\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which cloth prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[Tuple\\[np.ndarray, np.ndarray\\], Tuple\\[torch.Tensor, torch.Tensor\\]\\]: mass tensor with shape (M, max\\_particles\\_per\\_cloth)\n",
"snippet":"particle_masses = cloth_prim_view.get_particle_masses()\n",
"category":"method"
},
{
"title":"get_pressures",
"description":"Gets the pressures of the cloths indicated by the indices.\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which cloth prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[Tuple\\[np.ndarray, np.ndarray\\], Tuple\\[torch.Tensor, torch.Tensor\\]\\]: cloths pressure with shape (M, ).\n",
"snippet":"pressures = cloth_prim_view.get_pressures()\n",
"category":"method"
},
{
"title":"get_self_collision_filters",
"description":"Gets the self collision filters for the cloths indicated by the indices.\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which cloth prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[Tuple\\[np.ndarray, np.ndarray\\], Tuple\\[torch.Tensor, torch.Tensor\\]\\]: the self collision filters tensor with shape (M, )\n",
"snippet":"self_collision_filters = cloth_prim_view.get_self_collision_filters()\n",
"category":"method"
},
{
"title":"get_self_collisions",
"description":"Gets the self collision for the cloths indicated by the indices.\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which cloth prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[Tuple\\[np.ndarray, np.ndarray\\], Tuple\\[torch.Tensor, torch.Tensor\\]\\]: the self collision tensor with shape (M, )\n",
"snippet":"self_collisions = cloth_prim_view.get_self_collisions()\n",
"category":"method"
},
{
"title":"get_spring_dampings",
"description":"Gets the spring damping for the cloths indicated by the indices.\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which cloth prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[Tuple\\[np.ndarray, np.ndarray\\], Tuple\\[torch.Tensor, torch.Tensor\\]\\]: damping tensor with shape (M, max\\_springs\\_per\\_cloth)\n",
"snippet":"spring_dampings = cloth_prim_view.get_spring_dampings()\n",
"category":"method"
},
{
"title":"get_stretch_stiffnesses",
"description":"Gets the spring stretch stiffness for the cloths indicated by the indices.\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which cloth prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[Tuple\\[np.ndarray, np.ndarray\\], Tuple\\[torch.Tensor, torch.Tensor\\]\\]: stiffness tensor with shape (M, max\\_springs\\_per\\_cloth)\n",
"snippet":"stretch_stiffnesses = cloth_prim_view.get_stretch_stiffnesses()\n",
"category":"method"
},
{
"title":"get_velocities",
"description":"Gets the particle velocities for the cloths indicated by the indices.\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which cloth prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[Tuple\\[np.ndarray, np.ndarray\\], Tuple\\[torch.Tensor, torch.Tensor\\]\\]: velocity tensor with shape (M, max\\_particles\\_per\\_cloth, 3)\n",
"snippet":"velocities = cloth_prim_view.get_velocities()\n",
"category":"method"
},
{
"title":"get_visibilities",
"description":"Returns the current visibilities of the prims in stage.\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: Shape (M,) with type bool, where each item holds True if the prim is visible in stage. False otherwise.\n\n---\n**Example:**\n\n```python\n>>> # get all visibilities. Returned shape is (5,) for the example: 5 envs\n>>> prims.get_visibilities()\n[ True  True  True  True  True]\n>>>\n>>> # get the visibilities for the first, middle and last of the 5 envs. Returned shape is (3,)\n>>> prims.get_visibilities(indices=np.array([0, 2, 4]))\n[ True  True  True]\n```\n",
"snippet":"visibilities = cloth_prim_view.get_visibilities()\n",
"category":"method"
},
{
"title":"get_world_poses",
"description":"Get the poses of the prims in the view with respect to the world's frame\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Returns:**\n\n * Union\\[Tuple\\[np.ndarray, np.ndarray\\], Tuple\\[torch.Tensor, torch.Tensor\\], Tuple\\[wp.indexedarray, wp.indexedarray\\]\\]: first index is positions in the world frame of the prims. shape is (M, 3). second index is quaternion orientations in the world frame of the prims. quaternion is scalar-first (w, x, y, z). shape is (M, 4).\n\n---\n**Example:**\n\n```python\n>>> # get all prims poses with respect to the world's frame.\n>>> # Returned shape is position (5, 3) and orientation (5, 4) for the example: 5 envs\n>>> positions, orientations = prims.get_world_poses()\n>>> positions\n[[ 1.5  -0.75  0.  ]\n [ 1.5   0.75  0.  ]\n [ 0.   -0.75  0.  ]\n [ 0.    0.75  0.  ]\n [-1.5  -0.75  0.  ]]\n>>> orientations\n[[1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]]\n>>>\n>>> # get only the prims poses with respect to the world's frame for the first, middle and last of the 5 envs.\n>>> # Returned shape is position (3, 3) and orientation (3, 4) for the example: 3 envs selected\n>>> positions, orientations = prims.get_world_poses(indices=np.array([0, 2, 4]))\n>>> positions\n[[ 1.5  -0.75  0.  ]\n [ 0.   -0.75  0.  ]\n [-1.5  -0.75  0.  ]]\n>>> orientations\n[[1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]]\n```\n",
"snippet":"world_poses = cloth_prim_view.get_world_poses()\n",
"category":"method"
},
{
"title":"get_world_positions",
"description":"Gets the particle world positions for the cloths indicated by the indices.\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which cloth prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[Tuple\\[np.ndarray, np.ndarray\\], Tuple\\[torch.Tensor, torch.Tensor\\]\\]: position tensor with shape (M, max\\_particles\\_per\\_cloth, 3)\n",
"snippet":"world_positions = cloth_prim_view.get_world_positions()\n",
"category":"method"
},
{
"title":"get_world_scales",
"description":"Get prim scales in the view with respect to the world's frame\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: scales applied to the prim's dimensions in the world frame. shape is (M, 3).\n\n---\n**Example:**\n\n```python\n>>> # get all prims scales with respect to the world's frame.\n>>> # Returned shape is (5, 3) for the example: 5 envs\n>>> prims.get_world_scales()\n[[1. 1. 1.]\n [1. 1. 1.]\n [1. 1. 1.]\n [1. 1. 1.]\n [1. 1. 1.]]\n>>>\n>>> # get only the prims scales with respect to the world's frame for the first, middle and last of the 5 envs.\n>>> # Returned shape is (3, 3) for the example: 3 envs selected\n>>> prims.get_world_scales(indices=np.array([0, 2, 4]))\n[[1. 1. 1.]\n [1. 1. 1.]\n [1. 1. 1.]]\n```\n",
"snippet":"world_scales = cloth_prim_view.get_world_scales()\n",
"category":"method"
},
{
"title":"initialize",
"description":"Create a physics simulation view if not passed and creates a rigid body view in physX.\n\n**Args:**\n\n * `physics_sim_view` (omni.physics.tensors.SimulationView, optional): current physics simulation view. Defaults to None.\n",
"snippet":"cloth_prim_view.initialize()\n",
"category":"method"
},
{
"title":"initialize",
"description":"Create a physics simulation view if not passed and set other properties using the PhysX tensor API\n\n*Note:*\nFor this particular class, calling this method will do nothing\n\n**Args:**\n\n * `physics_sim_view` (omni.physics.tensors.SimulationView, optional): current physics simulation view. Defaults to None.\n\n---\n**Example:**\n\n```python\n>>> prims.initialize()\n```\n",
"snippet":"cloth_prim_view.initialize()\n",
"category":"method"
},
{
"title":"is_physics_handle_valid",
"description":"**Returns:**\n\n * bool: True if the physics handle of the view is valid (i.e physics is initialized for the view). Otherwise False.\n",
"snippet":"value = cloth_prim_view.is_physics_handle_valid()\n",
"category":"method"
},
{
"title":"is_valid",
"description":"Check that all prims have a valid USD Prim\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Returns:**\n\n * bool: True if all prim paths specified in the view correspond to a valid prim in stage. False otherwise.\n\n---\n**Example:**\n\n```python\n>>> prims.is_valid()\nTrue\n```\n",
"snippet":"value = cloth_prim_view.is_valid()\n",
"category":"method"
},
{
"title":"is_visual_material_applied",
"description":"Check if there is a visual material applied\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Returns:**\n\n * List\\[bool\\]: True if there is a visual material applied is applied to the corresponding prim in the view. False otherwise.\n\n---\n**Example:**\n\n```python\n>>> # given a visual material that is applied only to the first and the last environment\n>>> prims.is_visual_material_applied()\n[True, False, False, False, True]\n>>>\n>>> # check for the first, middle and last of the 5 envs\n>>> prims.is_visual_material_applied(indices=np.array([0, 2, 4]))\n[True, False, True]\n```\n",
"snippet":"value = cloth_prim_view.is_visual_material_applied()\n",
"category":"method"
},
{
"title":"max_particles_per_cloth",
"description":"**Returns:**\n\n * int: maximum number of particles per cloth.\n",
"snippet":"max_particles_per_cloth = cloth_prim_view.max_particles_per_cloth\n",
"category":"property"
},
{
"title":"max_springs_per_cloth",
"description":"**Returns:**\n\n * int: maximum number of springs per cloth.\n",
"snippet":"max_springs_per_cloth = cloth_prim_view.max_springs_per_cloth\n",
"category":"property"
},
{
"title":"post_reset",
"description":"Reset the prims to its default state (positions and orientations)\n\n---\n**Example:**\n\n```python\n>>> prims.post_reset()\n```\n",
"snippet":"cloth_prim_view.post_reset()\n",
"category":"method"
},
{
"title":"set_cloths_bend_stiffnesses",
"description":"Sets a single value of bend stiffnesses to all the springs within cloths indicated by the indices.\n\n**Args:**\n\n * `values` (Union\\[np.ndarray, torch.Tensor\\]): cloth spring bend stiffness values with the shape (M, ).\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which cloth prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n",
"snippet":"cloth_prim_view.set_cloths_bend_stiffnesses(values=values)\n",
"category":"method"
},
{
"title":"set_cloths_dampings",
"description":"Sets a single value of damping to all the springs within cloths indicated by the indices.\n\n**Args:**\n\n * `values` (Union\\[np.ndarray, torch.Tensor\\]): cloth spring damping with the shape (M, ).\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which cloth prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n",
"snippet":"cloth_prim_view.set_cloths_dampings(values=values)\n",
"category":"method"
},
{
"title":"set_cloths_shear_stiffnesses",
"description":"Sets a single value of shear stiffnesses to all the springs within cloths indicated by the indices.\n\n**Args:**\n\n * `values` (Union\\[np.ndarray, torch.Tensor\\]): cloth spring shear stiffness values with the shape (M, ).\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which cloth prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n",
"snippet":"cloth_prim_view.set_cloths_shear_stiffnesses(values=values)\n",
"category":"method"
},
{
"title":"set_cloths_stretch_stiffnesses",
"description":"Sets a single value of stretch stiffnesses to all the springs within cloths indicated by the indices.\n\n**Args:**\n\n * `values` (Union\\[np.ndarray, torch.Tensor\\]): cloth spring stretch stiffness values with the shape (M, ).\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which cloth prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n",
"snippet":"cloth_prim_view.set_cloths_stretch_stiffnesses(values=values)\n",
"category":"method"
},
{
"title":"set_default_state",
"description":"Set the default state of the prims (positions and orientations), that will be used after each reset.\n\n*Note:*\nThe default states will be set during post-reset (e.g., calling `.post_reset()` or `world.reset()` methods)\n\n**Args:**\n\n * `positions` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): positions in the world frame of the prim. shape is (M, 3). Defaults to None, which means left unchanged.\n * `orientations` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): quaternion orientations in the world frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (M, 4). Defaults to None, which means left unchanged.\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n---\n**Example:**\n\n```python\n>>> # configure default states for all prims\n>>> positions = np.zeros((num_envs, 3))\n>>> positions[:, 0] = np.arange(num_envs)\n>>> orientations = np.tile(np.array([1.0, 0.0, 0.0, 0.0]), (num_envs, 1))\n>>> prims.set_default_state(positions=positions, orientations=orientations)\n>>>\n>>> # set default states during post-reset\n>>> prims.post_reset()\n```\n",
"snippet":"cloth_prim_view.set_default_state()\n",
"category":"method"
},
{
"title":"set_local_poses",
"description":"Set prim poses in the view with respect to the local frame (the prim's parent frame)\n\n*Warning:*\nThis method will change (teleport) the prim poses immediately to the indicated value\n\n**Args:**\n\n * `translations` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): translations in the local frame of the prims (with respect to its parent prim). shape is (M, 3). Defaults to None, which means left unchanged.\n * `orientations` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): quaternion orientations in the local frame of the prims. quaternion is scalar-first (w, x, y, z). shape is (M, 4). Defaults to None, which means left unchanged.\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n*Hint:*\nThis method belongs to the methods used to set the prim state\n\n---\n**Example:**\n\n```python\n>>> # reposition all prims\n>>> positions = np.zeros((num_envs, 3))\n>>> positions[:,0] = np.arange(num_envs)\n>>> orientations = np.tile(np.array([1.0, 0.0, 0.0, 0.0]), (num_envs, 1))\n>>> prims.set_local_poses(positions, orientations)\n>>>\n>>> # reposition only the prims for the first, middle and last of the 5 envs\n>>> positions = np.zeros((3, 3))\n>>> positions[:,1] = np.arange(3)\n>>> orientations = np.tile(np.array([1.0, 0.0, 0.0, 0.0]), (3, 1))\n>>> prims.set_local_poses(positions, orientations, indices=np.array([0, 2, 4]))\n```\n",
"snippet":"cloth_prim_view.set_local_poses()\n",
"category":"method"
},
{
"title":"set_local_scales",
"description":"Set prim scales in the view with respect to the local frame (the prim's parent frame)\n\n**Args:**\n\n * `scales` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\]): scales to be applied to the prim's dimensions in the view. shape is (M, 3).\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n---\n**Example:**\n\n```python\n>>> # set the scale for all prims. Since there are 5 envs, the scale is repeated 5 times\n>>> scales = np.tile(np.array([1.0, 0.75, 0.5]), (num_envs, 1))\n>>> prims.set_local_scales(scales)\n>>>\n>>> # set the scale for the first, middle and last of the 5 envs\n>>> scales = np.tile(np.array([1.0, 0.75, 0.5]), (3, 1))\n>>> prims.set_local_scales(scales, indices=np.array([0, 2, 4]))\n```\n",
"snippet":"cloth_prim_view.set_local_scales(scales=scales)\n",
"category":"method"
},
{
"title":"set_particle_groups",
"description":"Sets the particle group of the cloths indicated by the indices.\n\n**Args:**\n\n * `particle_groups` (Union\\[np.ndarray, torch.Tensor\\]): particle group with shape (M, ).\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which cloth prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n",
"snippet":"cloth_prim_view.set_particle_groups(particle_groups=particle_groups)\n",
"category":"method"
},
{
"title":"set_particle_masses",
"description":"Sets the particle masses for the cloths indicated by the indices.\n\n**Args:**\n\n * `masses` (Union\\[np.ndarray, torch.Tensor\\]): cloth particle masses with the shape (M, max\\_particles\\_per\\_cloth, 3).\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which cloth prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n",
"snippet":"cloth_prim_view.set_particle_masses(masses=masses)\n",
"category":"method"
},
{
"title":"set_pressures",
"description":"Sets the pressures of the cloths indicated by the indices.\n\n**Args:**\n\n * `pressures` (Union\\[np.ndarray, torch.Tensor\\]): cloths pressure with shape (M, ).\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which cloth prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n",
"snippet":"cloth_prim_view.set_pressures(pressures=pressures)\n",
"category":"method"
},
{
"title":"set_self_collision_filters",
"description":"Sets the self collision filters for the cloths indicated by the indices.\n\n**Args:**\n\n * `self_collision_filters` (Union\\[np.ndarray, torch.Tensor\\]): self collision filters with the shape (M, ).\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which cloth prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n",
"snippet":"cloth_prim_view.set_self_collision_filters(self_collision_filters=self_collision_filters)\n",
"category":"method"
},
{
"title":"set_self_collisions",
"description":"Sets the self collision flags for the cloths indicated by the indices.\n\n**Args:**\n\n * `self_collisions` (Union\\[np.ndarray, torch.Tensor\\]): self collision flag with the shape (M, ).\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which cloth prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n",
"snippet":"cloth_prim_view.set_self_collisions(self_collisions=self_collisions)\n",
"category":"method"
},
{
"title":"set_spring_dampings",
"description":"Sets the spring damping for the cloths indicated by the indices.\n\n**Args:**\n\n * `damping` (Union\\[np.ndarray, torch.Tensor\\]): cloth spring damping with the shape (M, max\\_springs\\_per\\_cloth).\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which cloth prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n",
"snippet":"cloth_prim_view.set_spring_dampings(damping=damping)\n",
"category":"method"
},
{
"title":"set_stretch_stiffnesses",
"description":"Sets the spring stretch stiffness values for springs within the cloths indicated by the indices.\n\n**Args:**\n\n * `stiffness` (Union\\[np.ndarray, torch.Tensor\\]): cloth spring stiffness with the shape (M, max\\_springs\\_per\\_cloth).\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which cloth prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n",
"snippet":"cloth_prim_view.set_stretch_stiffnesses(stiffness=stiffness)\n",
"category":"method"
},
{
"title":"set_velocities",
"description":"Sets the particle velocities for the cloths indicated by the indices.\n\n**Args:**\n\n * `velocities` (Union\\[np.ndarray, torch.Tensor\\]): particle velocities with the shape (M, max\\_particles\\_per\\_cloth, 3).\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which cloth prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n",
"snippet":"cloth_prim_view.set_velocities(velocities=velocities)\n",
"category":"method"
},
{
"title":"set_visibilities",
"description":"Set the visibilities of the prims in stage\n\n**Args:**\n\n * `visibilities` (Union\\[np.ndarray, torch.Tensor, wp.array\\]): flag to set the visibilities of the usd prims in stage. Shape (M,). Where M \\<= size of the encapsulated prims in the view.\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Defaults to None (i.e: all prims in the view).\n\n---\n**Example:**\n\n```python\n>>> # make all prims not visible in the stage\n>>> prims.set_visibilities(visibilities=[False] * num_envs)\n```\n",
"snippet":"cloth_prim_view.set_visibilities(visibilities=visibilities)\n",
"category":"method"
},
{
"title":"set_world_poses",
"description":"Set prim poses in the view with respect to the world's frame\n\n*Warning:*\nThis method will change (teleport) the prim poses immediately to the indicated value\n\n**Args:**\n\n * `positions` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): positions in the world frame of the prims. shape is (M, 3). Defaults to None, which means left unchanged.\n * `orientations` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): quaternion orientations in the world frame of the prims. quaternion is scalar-first (w, x, y, z). shape is (M, 4). Defaults to None, which means left unchanged.\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n*Hint:*\nThis method belongs to the methods used to set the prim state\n\n---\n**Example:**\n\n```python\n>>> # reposition all prims in row (x-axis)\n>>> positions = np.zeros((num_envs, 3))\n>>> positions[:,0] = np.arange(num_envs)\n>>> orientations = np.tile(np.array([1.0, 0.0, 0.0, 0.0]), (num_envs, 1))\n>>> prims.set_world_poses(positions, orientations)\n>>>\n>>> # reposition only the prims for the first, middle and last of the 5 envs in column (y-axis)\n>>> positions = np.zeros((3, 3))\n>>> positions[:,1] = np.arange(3)\n>>> orientations = np.tile(np.array([1.0, 0.0, 0.0, 0.0]), (3, 1))\n>>> prims.set_world_poses(positions, orientations, indices=np.array([0, 2, 4]))\n```\n",
"snippet":"cloth_prim_view.set_world_poses()\n",
"category":"method"
},
{
"title":"set_world_positions",
"description":"Sets the particle world positions for the cloths indicated by the indices.\n\n**Args:**\n\n * `positions` (Union\\[np.ndarray, torch.Tensor\\]): particle positions with the shape (M, max\\_particles\\_per\\_cloth, 3).\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which cloth prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n",
"snippet":"cloth_prim_view.set_world_positions(positions=positions)\n",
"category":"method"
}
]
},
{
"title":"GeometryPrim",
"snippets":[
{
"title":"import ...",
"description":"Import class",
"snippet":"from omni.isaac.core.prims import GeometryPrim\n",
"category":"import"
},
{
"title":"GeometryPrim",
"description":"High level wrapper to deal with a Geom prim (only one geometry prim) and its attributes/properties.\n\nThe `prim_path` should correspond to type UsdGeom.Cube, UsdGeom.Capsule, UsdGeom.Cone, UsdGeom.Cylinder,\nUsdGeom.Sphere or UsdGeom.Mesh.\n\n*Warning:*\nThe geometry object must be initialized in order to be able to operate on it.\nSee the `initialize` method for more details.\n\n*Warning:*\nSome methods require the prim to have the Physx Collision API. Instantiate the class with the `collision`\nparameter to True to apply the collision API.\n\n**Args:**\n\n * `prim_path` (str): prim path of the Prim to encapsulate or create.\n\n * `name` (str, optional): shortname to be used as a key by Scene class. Note: needs to be unique if the object is added to the Scene. Defaults to \"xform\\_prim\".\n\n * `position` (Optional\\[Sequence\\[float\\]\\], optional): position in the world frame of the prim. shape is (3, ). Defaults to None, which means left unchanged.\n\n * `translation` (Optional\\[Sequence\\[float\\]\\], optional): translation in the local frame of the prim (with respect to its parent prim). shape is (3, ). Defaults to None, which means left unchanged.\n\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the world/ local frame of the prim (depends if translation or position is specified). quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n\n * `scale` (Optional\\[Sequence\\[float\\]\\], optional): local scale to be applied to the prim's dimensions. shape is (3, ). Defaults to None, which means left unchanged.\n\n * `visible` (bool, optional): set to false for an invisible prim in the stage while rendering. Defaults to True.\n\n * \n\n        `collision` (bool, optional): Set to True if the geometry should have a collider (i.e not only a visual geometry). Defaults to False.\n\n        :   track\\_contact\\_forces (bool, Optional) : if enabled, the view will track the net contact forces on each geometry prim in the view. Note that the collision flag should be set to True to report contact forces. Defaults to False.\n\n * `prepare_contact_sensors` (bool, Optional): applies contact reporter API to the prim if it already does not have one. Defaults to False.\n\n * `disable_stablization` (bool, optional): disables the contact stabilization parameter in the physics context. Defaults to True.\n\n * `contact_filter_prim_paths_expr` (Optional\\[List\\[str\\]\\], Optional): a list of filter expressions which allows for tracking contact forces between the geometry prim and this subset through get\\_contact\\_force\\_matrix().\n\n---\n**Example:**\n\n```python\n>>> import omni.isaac.core.utils.stage as stage_utils\n>>> from omni.isaac.core.prims import GeometryPrim\n>>>\n>>> # create a Cube at the given path\n>>> stage_utils.get_current_stage().DefinePrim(\"/World/Xform\", \"Xform\")\n>>> stage_utils.get_current_stage().DefinePrim(\"/World/Xform/Cube\", \"Cube\")\n>>>\n>>> # wrap the prim as geometry prim\n>>> prim = GeometryPrim(\"/World/Xform\", collision=True)\n>>> prim\n<omni.isaac.core.prims.geometry_prim.GeometryPrim object at 0x7fe960247400>\n```\n",
"snippet":"geometry_prim = GeometryPrim(prim_path=prim_path)\n",
"category":"class"
},
{
"title":"apply_physics_material",
"description":"Used to apply physics material to the held prim and optionally its descendants.\n\n**Args:**\n\n * `physics_material` (PhysicsMaterial): physics material to be applied to the held prim. This where you want to define friction, restitution..etc. Note: if a physics material is not defined, the defaults will be used from PhysX.\n * `weaker_than_descendants` (bool, optional): True if the material shouldn't override the descendants materials, otherwise False. Defaults to False.\n\n---\n**Example:**\n\n```python\n>>> from omni.isaac.core.materials import PhysicsMaterial\n>>>\n>>> # create a rigid body physical material\n>>> material = PhysicsMaterial(\n...     prim_path=\"/World/physics_material/aluminum\",  # path to the material prim to create\n...     dynamic_friction=0.4,\n...     static_friction=1.1,\n...     restitution=0.1\n... )\n>>> prim.apply_physics_material(material)\n```\n",
"snippet":"geometry_prim.apply_physics_material(physics_material=physics_material)\n",
"category":"method"
},
{
"title":"apply_visual_material",
"description":"Apply visual material to the held prim and optionally its descendants.\n\n**Args:**\n\n * `visual_material` (VisualMaterial): visual material to be applied to the held prim. Currently supports PreviewSurface, OmniPBR and OmniGlass.\n * `weaker_than_descendants` (bool, optional): True if the material shouldn't override the descendants materials, otherwise False. Defaults to False.\n\n---\n**Example:**\n\n```python\n>>> from omni.isaac.core.materials import OmniGlass\n>>>\n>>> # create a dark-red glass visual material\n>>> material = OmniGlass(\n...     prim_path=\"/World/material/glass\",  # path to the material prim to create\n...     ior=1.25,\n...     depth=0.001,\n...     thin_walled=False,\n...     color=np.array([0.5, 0.0, 0.0])\n... )\n>>> prim.apply_visual_material(material)\n```\n",
"snippet":"geometry_prim.apply_visual_material(visual_material=visual_material)\n",
"category":"method"
},
{
"title":"geom",
"description":"**Returns:**\n\n * UsdGeom.Gprim: USD geometry object encapsulated.\n",
"snippet":"geom = geometry_prim.geom\n",
"category":"property"
},
{
"title":"get_applied_physics_material",
"description":"Return the current applied physics material in case it was applied using apply\\_physics\\_material or not.\n\n**Returns:**\n\n * PhysicsMaterial: the current applied physics material.\n\n---\n**Example:**\n\n```python\n>>> # given a physics material applied\n>>> prim.get_applied_physics_material()\n<omni.isaac.core.materials.physics_material.PhysicsMaterial object at 0x7fb66c30cd30>\n```\n",
"snippet":"applied_physics_material = geometry_prim.get_applied_physics_material()\n",
"category":"method"
},
{
"title":"get_applied_visual_material",
"description":"Return the current applied visual material in case it was applied using apply\\_visual\\_material\nor it's one of the following materials that was already applied before: PreviewSurface, OmniPBR and OmniGlass.\n\n**Returns:**\n\n * VisualMaterial: the current applied visual material if its type is currently supported.\n\n---\n**Example:**\n\n```python\n>>> # given a visual material applied\n>>> prim.get_applied_visual_material()\n<omni.isaac.core.materials.omni_glass.OmniGlass object at 0x7f36263106a0>\n```\n",
"snippet":"applied_visual_material = geometry_prim.get_applied_visual_material()\n",
"category":"method"
},
{
"title":"get_collision_approximation",
"description":"Get the collision approximation\n\n| Approximation           | Full name            | Description                                                                               |\n|-------------------------|----------------------|-------------------------------------------------------------------------------------------|\n| `\"none\"`                | Triangle Mesh        | The mesh geometry is used directly as a collider without any approximation                |\n| `\"convexDecomposition\"` | Convex Decomposition | A convex mesh decomposition is performed. This results in a set of convex mesh colliders  |\n| `\"convexHull\"`          | Convex Hull          | A convex hull of the mesh is generated and used as the collider                           |\n| `\"boundingSphere\"`      | Bounding Sphere      | A bounding sphere is computed around the mesh and used as a collider                      |\n| `\"boundingCube\"`        | Bounding Cube        | An optimally fitting box collider is computed around the mesh                             |\n| `\"meshSimplification\"`  | Mesh Simplification  | A mesh simplification step is performed, resulting in a simplified triangle mesh collider |\n| `\"sdf\"`                 | SDF Mesh             | SDF (Signed-Distance-Field) use high-detail triangle meshes as collision shape            |\n| `\"sphereFill\"`          | Sphere Approximation | A sphere mesh decomposition is performed. This results in a set of sphere colliders       |\n\n**Returns:**\n\n * str: approximation used for collision\n\n---\n**Example:**\n\n```python\n>>> prim.get_collision_approximation()\nnone\n```\n",
"snippet":"collision_approximation = geometry_prim.get_collision_approximation()\n",
"category":"method"
},
{
"title":"get_collision_enabled",
"description":"Check if the Collision API is enabled\n\n**Returns:**\n\n * bool: True if the Collision API is enabled. Otherwise False\n\n---\n**Example:**\n\n```python\n>>> prim.get_collision_enabled()\nTrue\n```\n",
"snippet":"collision_enabled = geometry_prim.get_collision_enabled()\n",
"category":"method"
},
{
"title":"get_contact_force_matrix",
"description":"If the object is initialized with filter\\_paths\\_expr list, this method returns the contact forces between the prims\nin the view and the filter prims. i.e., a matrix of dimension (self.\\_contact\\_view.num\\_filters, 3)\nwhere num\\_filters is the determined according to the filter\\_paths\\_expr parameter.\n\n**Args:**\n\n * `dt` (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor\\]: Net contact forces of the prims with shape (self.\\_geometry\\_prim\\_view.\\_contact\\_view.num\\_filters, 3).\n",
"snippet":"contact_force_matrix = geometry_prim.get_contact_force_matrix()\n",
"category":"method"
},
{
"title":"get_contact_offset",
"description":"Get the contact offset\n\nShapes whose distance is less than the sum of their contact offset values will generate contacts\n\nSearch for *Advanced Collision Detection* in for more details\n\n**Returns:**\n\n * float: contact offset of the collision shape. Default value is -inf, means default is picked by simulation.\n\n---\n**Example:**\n\n```python\n>>> prim.get_contact_offset()\n-inf\n```\n",
"snippet":"contact_offset = geometry_prim.get_contact_offset()\n",
"category":"method"
},
{
"title":"get_default_state",
"description":"Get the default prim states (spatial position and orientation).\n\n**Returns:**\n\n * XFormPrimState: an object that contains the default state of the prim (position and orientation)\n\n---\n**Example:**\n\n```python\n>>> state = prim.get_default_state()\n>>> state\n<omni.isaac.core.utils.types.XFormPrimState object at 0x7f33addda650>\n>>>\n>>> state.position\n[-4.5299529e-08 -1.8347054e-09 -2.8610229e-08]\n>>> state.orientation\n[1. 0. 0. 0.]\n```\n",
"snippet":"default_state = geometry_prim.get_default_state()\n",
"category":"method"
},
{
"title":"get_local_pose",
"description":"Get prim's pose with respect to the local frame (the prim's parent frame)\n\n**Returns:**\n\n * Tuple\\[np.ndarray, np.ndarray\\]: first index is the position in the local frame (with shape (3, )).\n    Second index is quaternion orientation (with shape (4, )) in the local frame\n\n---\n**Example:**\n\n```python\n>>> # if the prim is in position (1.0, 0.5, 0.0) with respect to the world frame\n>>> position, orientation = prim.get_local_pose()\n>>> position\n[0. 0. 0.]\n>>> orientation\n[0. 0. 0.]\n```\n",
"snippet":"local_pose = geometry_prim.get_local_pose()\n",
"category":"method"
},
{
"title":"get_local_scale",
"description":"Get prim's scale with respect to the local frame (the parent's frame)\n\n**Returns:**\n\n * np.ndarray: scale applied to the prim's dimensions in the local frame. shape is (3, ).\n\n---\n**Example:**\n\n```python\n>>> prim.get_local_scale()\n[1. 1. 1.]\n```\n",
"snippet":"local_scale = geometry_prim.get_local_scale()\n",
"category":"method"
},
{
"title":"get_min_torsional_patch_radius",
"description":"Get the minimum radius of the contact patch used to apply torsional friction\n\nSearch for *\"Torsional Patch Radius\"* in for more details\n\n**Returns:**\n\n * float: minimum radius of the contact patch used to apply torsional friction. Allowed range \\[0, max\\_float\\].\n\n---\n**Example:**\n\n```python\n>>> prim.get_min_torsional_patch_radius()\n0.0\n```\n",
"snippet":"min_torsional_patch_radius = geometry_prim.get_min_torsional_patch_radius()\n",
"category":"method"
},
{
"title":"get_net_contact_forces",
"description":"If contact forces of the prims in the view are tracked, this method returns the net contact forces on prims.\ni.e., a matrix of dimension (1, 3)\n\n**Args:**\n\n * `dt` (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor\\]: Net contact forces of the prims with shape (3).\n",
"snippet":"net_contact_forces = geometry_prim.get_net_contact_forces()\n",
"category":"method"
},
{
"title":"get_rest_offset",
"description":"Get the rest offset\n\nTwo shapes will come to rest at a distance equal to the sum of their rest offset values.\nIf the rest offset is 0, they should converge to touching exactly\n\nSearch for *Advanced Collision Detection* in for more details\n\n**Returns:**\n\n * float: rest offset of the collision shape.\n\n---\n**Example:**\n\n```python\n>>> prim.get_rest_offset()\n-inf\n```\n",
"snippet":"rest_offset = geometry_prim.get_rest_offset()\n",
"category":"method"
},
{
"title":"get_torsional_patch_radius",
"description":"Get the radius of the contact patch used to apply torsional friction\n\nSearch for *\"Torsional Patch Radius\"* in for more details\n\n**Returns:**\n\n * float: radius of the contact patch used to apply torsional friction. Allowed range \\[0, max\\_float\\].\n\n---\n**Example:**\n\n```python\n>>> prim.get_torsional_patch_radius()\n0.0\n```\n",
"snippet":"torsional_patch_radius = geometry_prim.get_torsional_patch_radius()\n",
"category":"method"
},
{
"title":"get_visibility",
"description":"**Returns:**\n\n * bool: true if the prim is visible in stage. false otherwise.\n\n---\n**Example:**\n\n```python\n>>> # get the visible state of an visible prim on the stage\n>>> prim.get_visibility()\nTrue\n```\n",
"snippet":"visibility = geometry_prim.get_visibility()\n",
"category":"method"
},
{
"title":"get_world_pose",
"description":"Get prim's pose with respect to the world's frame\n\n**Returns:**\n\n * Tuple\\[np.ndarray, np.ndarray\\]: first index is the position in the world frame (with shape (3, )).\n    Second index is quaternion orientation (with shape (4, )) in the world frame\n\n---\n**Example:**\n\n```python\n>>> # if the prim is in position (1.0, 0.5, 0.0) with respect to the world frame\n>>> position, orientation = prim.get_world_pose()\n>>> position\n[1.  0.5 0. ]\n>>> orientation\n[1. 0. 0. 0.]\n```\n",
"snippet":"world_pose = geometry_prim.get_world_pose()\n",
"category":"method"
},
{
"title":"get_world_scale",
"description":"Get prim's scale with respect to the world's frame\n\n**Returns:**\n\n * np.ndarray: scale applied to the prim's dimensions in the world frame. shape is (3, ).\n\n---\n**Example:**\n\n```python\n>>> prim.get_world_scale()\n[1. 1. 1.]\n```\n",
"snippet":"world_scale = geometry_prim.get_world_scale()\n",
"category":"method"
},
{
"title":"initialize",
"description":"Create a physics simulation view if not passed and using PhysX tensor API\n\n*Note:*\nIf the prim has been added to the world scene (e.g., `world.scene.add(prim)`),\nit will be automatically initialized when the world is reset (e.g., `world.reset()`).\n\n**Args:**\n\n * `physics_sim_view` (omni.physics.tensors.SimulationView, optional): current physics simulation view. Defaults to None.\n\n---\n**Example:**\n\n```python\n>>> prim.initialize()\n```\n",
"snippet":"geometry_prim.initialize()\n",
"category":"method"
},
{
"title":"is_valid",
"description":"Check if the prim path has a valid USD Prim at it\n\n**Returns:**\n\n * bool: True is the current prim path corresponds to a valid prim in stage. False otherwise.\n\n---\n**Example:**\n\n```python\n>>> # given an existing and valid prim\n>>> prims.is_valid()\nTrue\n```\n",
"snippet":"value = geometry_prim.is_valid()\n",
"category":"method"
},
{
"title":"is_visual_material_applied",
"description":"Check if there is a visual material applied\n\n**Returns:**\n\n * bool: True if there is a visual material applied. False otherwise.\n\n---\n**Example:**\n\n```python\n>>> # given a visual material applied\n>>> prim.is_visual_material_applied()\nTrue\n```\n",
"snippet":"value = geometry_prim.is_visual_material_applied()\n",
"category":"method"
},
{
"title":"post_reset",
"description":"Reset the prim to its default state (position and orientation).\n\n*Note:*\nFor an articulation, in addition to configuring the root prim's default position and spatial orientation\n(defined via the `set_default_state` method), the joint's positions, velocities, and efforts\n(defined via the `set_joints_default_state` method) are imposed\n\n---\n**Example:**\n\n```python\n>>> prim.post_reset()\n```\n",
"snippet":"geometry_prim.post_reset()\n",
"category":"method"
},
{
"title":"set_collision_approximation",
"description":"Set the collision approximation\n\n| Approximation           | Full name            | Description                                                                               |\n|-------------------------|----------------------|-------------------------------------------------------------------------------------------|\n| `\"none\"`                | Triangle Mesh        | The mesh geometry is used directly as a collider without any approximation                |\n| `\"convexDecomposition\"` | Convex Decomposition | A convex mesh decomposition is performed. This results in a set of convex mesh colliders  |\n| `\"convexHull\"`          | Convex Hull          | A convex hull of the mesh is generated and used as the collider                           |\n| `\"boundingSphere\"`      | Bounding Sphere      | A bounding sphere is computed around the mesh and used as a collider                      |\n| `\"boundingCube\"`        | Bounding Cube        | An optimally fitting box collider is computed around the mesh                             |\n| `\"meshSimplification\"`  | Mesh Simplification  | A mesh simplification step is performed, resulting in a simplified triangle mesh collider |\n| `\"sdf\"`                 | SDF Mesh             | SDF (Signed-Distance-Field) use high-detail triangle meshes as collision shape            |\n| `\"sphereFill\"`          | Sphere Approximation | A sphere mesh decomposition is performed. This results in a set of sphere colliders       |\n\n*Warning:*\nSwitching to Convex Decomposition or SDF (Signed-Distance-Field) will have a simulation performance\nimpact due to higher computational cost\n\n**Args:**\n\n * `approximation_type` (str): approximation used for collision\n\n---\n**Example:**\n\n```python\n>>> prim.set_collision_approximation(\"convexDecomposition\")\n```\n",
"snippet":"geometry_prim.set_collision_approximation(approximation_type=approximation_type)\n",
"category":"method"
},
{
"title":"set_collision_enabled",
"description":"Enable/disable the Collision API\n\n**Args:**\n\n * `enabled` (bool): Whether to enable or disable the Collision API\n\n---\n**Example:**\n\n```python\n>>> # disable collisions\n>>> prim.set_collision_enabled(False)\n```\n",
"snippet":"geometry_prim.set_collision_enabled(enabled=enabled)\n",
"category":"method"
},
{
"title":"set_contact_offset",
"description":"Set the contact offset\n\nShapes whose distance is less than the sum of their contact offset values will generate contacts\n\nSearch for *Advanced Collision Detection* in for more details\n\n*Warning:*\nThe contact offset must be positive and greater than the rest offset\n\n**Args:**\n\n * `offset` (float): Contact offset of a collision shape. Allowed range \\[maximum(0, rest\\_offset), 0\\]. Default value is -inf, means default is picked by simulation based on the shape extent.\n\n---\n**Example:**\n\n```python\n>>> prim.set_contact_offset(0.02)\n```\n",
"snippet":"geometry_prim.set_contact_offset(offset=offset)\n",
"category":"method"
},
{
"title":"set_default_state",
"description":"Set the default state of the prim (position and orientation), that will be used after each reset.\n\n**Args:**\n\n * `position` (Optional\\[Sequence\\[float\\]\\], optional): position in the world frame of the prim. shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the world frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n\n---\n**Example:**\n\n```python\n>>> # configure default state\n>>> prim.set_default_state(position=np.array([1.0, 0.5, 0.0]), orientation=np.array([1, 0, 0, 0]))\n>>>\n>>> # set default states during post-reset\n>>> prim.post_reset()\n```\n",
"snippet":"geometry_prim.set_default_state()\n",
"category":"method"
},
{
"title":"set_local_pose",
"description":"Set prim's pose with respect to the local frame (the prim's parent frame).\n\n*Warning:*\nThis method will change (teleport) the prim pose immediately to the indicated value\n\n**Args:**\n\n * `translation` (Optional\\[Sequence\\[float\\]\\], optional): translation in the local frame of the prim (with respect to its parent prim). shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the local frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n\n*Hint:*\nThis method belongs to the methods used to set the prim state\n\n---\n**Example:**\n\n```python\n>>> prim.set_local_pose(translation=np.array([1.0, 0.5, 0.0]), orientation=np.array([1., 0., 0., 0.]))\n```\n",
"snippet":"geometry_prim.set_local_pose()\n",
"category":"method"
},
{
"title":"set_local_scale",
"description":"Set prim's scale with respect to the local frame (the prim's parent frame).\n\n**Args:**\n\n * `scale` (Optional\\[Sequence\\[float\\]\\]): scale to be applied to the prim's dimensions. shape is (3, ). Defaults to None, which means left unchanged.\n\n---\n**Example:**\n\n```python\n>>> # scale prim 10 times smaller\n>>> prim.set_local_scale(np.array([0.1, 0.1, 0.1]))\n```\n",
"snippet":"geometry_prim.set_local_scale(scale=scale)\n",
"category":"method"
},
{
"title":"set_min_torsional_patch_radius",
"description":"Set the minimum radius of the contact patch used to apply torsional friction\n\nSearch for *\"Torsional Patch Radius\"* in for more details\n\n**Args:**\n\n * `radius` (float): minimum radius of the contact patch used to apply torsional friction. Allowed range \\[0, max\\_float\\].\n\n---\n**Example:**\n\n```python\n>>> prim.set_min_torsional_patch_radius(0.05)\n```\n",
"snippet":"geometry_prim.set_min_torsional_patch_radius(radius=radius)\n",
"category":"method"
},
{
"title":"set_rest_offset",
"description":"Set the rest offset\n\nTwo shapes will come to rest at a distance equal to the sum of their rest offset values.\nIf the rest offset is 0, they should converge to touching exactly\n\nSearch for *Advanced Collision Detection* in for more details\n\n*Warning:*\nThe contact offset must be positive and greater than the rest offset\n\n**Args:**\n\n * `offset` (float): Rest offset of a collision shape. Allowed range \\[-max\\_float, contact\\_offset. Default value is -inf, means default is picked by simulation. For rigid bodies its zero.\n\n---\n**Example:**\n\n```python\n>>> prim.set_rest_offset(0.01)\n```\n",
"snippet":"geometry_prim.set_rest_offset(offset=offset)\n",
"category":"method"
},
{
"title":"set_torsional_patch_radius",
"description":"Set the radius of the contact patch used to apply torsional friction\n\nSearch for *\"Torsional Patch Radius\"* in for more details\n\n**Args:**\n\n * `radius` (float): radius of the contact patch used to apply torsional friction. Allowed range \\[0, max\\_float\\].\n\n---\n**Example:**\n\n```python\n>>> prim.set_torsional_patch_radius(0.1)\n```\n",
"snippet":"geometry_prim.set_torsional_patch_radius(radius=radius)\n",
"category":"method"
},
{
"title":"set_visibility",
"description":"Set the visibility of the prim in stage\n\n**Args:**\n\n * `visible` (bool): flag to set the visibility of the usd prim in stage.\n\n---\n**Example:**\n\n```python\n>>> # make prim not visible in the stage\n>>> prim.set_visibility(visible=False)\n```\n",
"snippet":"geometry_prim.set_visibility(visible=visible)\n",
"category":"method"
},
{
"title":"set_world_pose",
"description":"Ses prim's pose with respect to the world's frame\n\n*Warning:*\nThis method will change (teleport) the prim pose immediately to the indicated value\n\n**Args:**\n\n * `position` (Optional\\[Sequence\\[float\\]\\], optional): position in the world frame of the prim. shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the world frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n\n*Hint:*\nThis method belongs to the methods used to set the prim state\n\n---\n**Example:**\n\n```python\n>>> prim.set_world_pose(position=np.array([1.0, 0.5, 0.0]), orientation=np.array([1., 0., 0., 0.]))\n```\n",
"snippet":"geometry_prim.set_world_pose()\n",
"category":"method"
}
]
},
{
"title":"GeometryPrimView",
"snippets":[
{
"title":"import ...",
"description":"Import class",
"snippet":"from omni.isaac.core.prims import GeometryPrimView\n",
"category":"import"
},
{
"title":"GeometryPrimView",
"description":"High level wrapper to deal with geom prims (one or many) as well as their attributes/properties.\n\nThis class wraps all matching geom prims found at the regex provided at the `prim_paths_expr` argument\n\n*Note:*\nEach prim will have `xformOp:orient`, `xformOp:translate` and `xformOp:scale` only post-init,\nunless it is a non-root articulation link.\n\n*Warning:*\nThe geometry prim view object must be initialized in order to be able to operate on it.\nSee the `initialize` method for more details.\n\n*Warning:*\nSome methods require the prims to have the Physx Collision API. Instantiate the class with the `collision`\nparameter to a list of True values to apply the collision API.\n\n**Args:**\n\n * `prim_paths_expr` (str): prim paths regex to encapsulate all prims that match it. example: \"/World/Env\\[1-5\\]/Microwave\" will match /World/Env1/Microwave, /World/Env2/Microwave..etc. (a non regex prim path can also be used to encapsulate one XForm).\n\n * `name` (str, optional): shortname to be used as a key by Scene class. Note: needs to be unique if the object is added to the Scene. Defaults to \"geometry\\_prim\\_view\".\n\n * `positions` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): default positions in the world frame of the prim. shape is (N, 3). Defaults to None, which means left unchanged.\n\n * `translations` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): default translations in the local frame of the prims (with respect to its parent prims). shape is (N, 3). Defaults to None, which means left unchanged.\n\n * `orientations` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): default quaternion orientations in the world/ local frame of the prim (depends if translation or position is specified). quaternion is scalar-first (w, x, y, z). shape is (N, 4). Defaults to None, which means left unchanged.\n\n * `scales` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): local scales to be applied to the prim's dimensions. shape is (N, 3). Defaults to None, which means left unchanged.\n\n * `visibilities` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\], optional): set to false for an invisible prim in the stage while rendering. shape is (N,). Defaults to None.\n\n * `reset_xform_properties` (bool, optional): True if the prims don't have the right set of xform properties (i.e: translate, orient and scale) ONLY and in that order. Set this parameter to False if the object were cloned using using the cloner api in omni.isaac.cloner. Defaults to True.\n\n * \n\n        `collisions` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): Set to True if the geometry already have/ should have a collider (i.e not only a visual geometry). shape is (N,). Defaults to None.\n\n        :   track\\_contact\\_forces (bool, Optional) : if enabled, the view will track the net contact forces on each geometry prim in the view. Note that the collision flag should be set to True to report contact forces. Defaults to False.\n\n * `prepare_contact_sensors` (bool, Optional): applies contact reporter API to the prim if it already does not have one. Defaults to False.\n\n * `disable_stablization` (bool, optional): disables the contact stabilization parameter in the physics context. Defaults to True.\n\n * `contact_filter_prim_paths_expr` (Optional\\[List\\[str\\]\\], Optional): a list of filter expressions which allows for tracking contact forces between the geometry prim and this subset through get\\_contact\\_force\\_matrix().\n\n * `max_contact_count` (int, optional): maximum number of contact data to report when detailed contact information is needed\n\n---\n**Example:**\n\n```python\n>>> import omni.isaac.core.utils.stage as stage_utils\n>>> from omni.isaac.cloner import GridCloner\n>>> from omni.isaac.core.prims import GeometryPrimView\n>>> from pxr import UsdGeom\n>>>\n>>> env_zero_path = \"/World/envs/env_0\"\n>>> num_envs = 5\n>>>\n>>> # clone the environment (num_envs)\n>>> cloner = GridCloner(spacing=1.5)\n>>> cloner.define_base_env(env_zero_path)\n>>> UsdGeom.Xform.Define(stage_utils.get_current_stage(), env_zero_path)\n>>> stage_utils.get_current_stage().DefinePrim(f\"{env_zero_path}/Xform\", \"Xform\")\n>>> stage_utils.get_current_stage().DefinePrim(f\"{env_zero_path}/Xform/Cube\", \"Cube\")\n>>> env_pos = cloner.clone(\n...     source_prim_path=env_zero_path,\n...     prim_paths=cloner.generate_paths(\"/World/envs/env\", num_envs),\n...     copy_from_source=True\n... )\n>>>\n>>> # wrap the prims\n>>> prims = GeometryPrimView(\n...     prim_paths_expr=\"/World/envs/env.*/Xform\",\n...     name=\"geometry_prim_view\",\n...     collisions=[True] * num_envs\n... )\n>>> prims\n<omni.isaac.core.prims.geometry_prim_view.GeometryPrimView object at 0x7f372bb21630>\n```\n",
"snippet":"geometry_prim_view = GeometryPrimView(prim_paths_expr=prim_paths_expr)\n",
"category":"class"
},
{
"title":"apply_collision_apis",
"description":"Apply the collision API to prims in the view and update internal variables\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n---\n**Example:**\n\n```python\n>>> # apply the collision API for all prims\n>>> prims.apply_collision_apis()\n>>>\n>>> # apply the collision API for the first, middle and last of the 5 envs\n>>> prims.apply_collision_apis(indices=np.array([0, 2, 4]))\n```\n",
"snippet":"geometry_prim_view.apply_collision_apis()\n",
"category":"method"
},
{
"title":"apply_physics_materials",
"description":"Used to apply physics material to prims in the view and optionally its descendants.\n\n**Args:**\n\n * `physics_materials` (Union\\[PhysicsMaterial, List\\[PhysicsMaterial\\]\\]): physics materials to be applied to prims in the view. Physics material can be used to define friction, restitution..etc. Note: if a physics material is not defined, the defaults will be used from PhysX. If a list is provided then its size has to be equal the view's size or indices size. If one material is provided it will be applied to all prims in the view.\n * `weaker_than_descendants` (Optional\\[Union\\[bool, List\\[bool\\]\\]\\], optional): True if the material shouldn't override the descendants materials, otherwise False. Defaults to False. If a list of visual materials is provided then a list has to be provided with the same size for this arg as well.\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Raises:**\n\n * Exception: length of physics materials != length of prims indexed\n    Exception: length of physics materials != length of weaker descendants arg\n\n---\n**Example:**\n\n```python\n>>> from omni.isaac.core.materials import PhysicsMaterial\n>>>\n>>> # create a rigid body physical material\n>>> material = PhysicsMaterial(\n...     prim_path=\"/World/physics_material/aluminum\",  # path to the material prim to create\n...     dynamic_friction=0.4,\n...     static_friction=1.1,\n...     restitution=0.1\n... )\n>>>\n>>> # apply the material to all prims\n>>> prims.apply_physics_materials(material)  # or [material] * num_envs\n>>>\n>>> # apply the collision API for the first, middle and last of the 5 envs\n>>> prims.apply_physics_materials(material, indices=np.array([0, 2, 4]))\n```\n",
"snippet":"geometry_prim_view.apply_physics_materials(physics_materials=physics_materials)\n",
"category":"method"
},
{
"title":"apply_visual_materials",
"description":"Apply visual material to the prims and optionally their prim descendants.\n\n**Args:**\n\n * `visual_materials` (Union\\[VisualMaterial, List\\[VisualMaterial\\]\\]): visual materials to be applied to the prims. Currently supports PreviewSurface, OmniPBR and OmniGlass. If a list is provided then its size has to be equal the view's size or indices size. If one material is provided it will be applied to all prims in the view.\n * `weaker_than_descendants` (Optional\\[Union\\[bool, List\\[bool\\]\\]\\], optional): True if the material shouldn't override the descendants materials, otherwise False. Defaults to False. If a list of visual materials is provided then a list has to be provided with the same size for this arg as well.\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Raises:**\n\n * Exception: length of visual materials != length of prims indexed\n    Exception: length of visual materials != length of weaker descendants bools arg\n\n---\n**Example:**\n\n```python\n>>> from omni.isaac.core.materials import OmniGlass\n>>>\n>>> # create a dark-red glass visual material\n>>> material = OmniGlass(\n...     prim_path=\"/World/material/glass\",  # path to the material prim to create\n...     ior=1.25,\n...     depth=0.001,\n...     thin_walled=False,\n...     color=np.array([0.5, 0.0, 0.0])\n... )\n>>> prims.apply_visual_materials(material)\n```\n",
"snippet":"geometry_prim_view.apply_visual_materials(visual_materials=visual_materials)\n",
"category":"method"
},
{
"title":"disable_collision",
"description":"Disables collision on prims in the view.\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n---\n**Example:**\n\n```python\n>>> # disable the collision API for all prims\n>>> prims.disable_collision()\n>>>\n>>> # disable the collision API for the prims for the first, middle and last of the 5 envs\n>>> prims.disable_collision(indices=np.array([0, 2, 4]))\n```\n",
"snippet":"geometry_prim_view.disable_collision()\n",
"category":"method"
},
{
"title":"enable_collision",
"description":"Enables collision on prims in the view.\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n---\n**Example:**\n\n```python\n>>> # enable the collision API for all prims\n>>> prims.enable_collision()\n>>>\n>>> # enable the collision API for the prims for the first, middle and last of the 5 envs\n>>> prims.enable_collision(indices=np.array([0, 2, 4]))\n```\n",
"snippet":"geometry_prim_view.enable_collision()\n",
"category":"method"
},
{
"title":"geoms",
"description":"**Returns:**\n\n * List\\[UsdGeom.Gprim\\]: USD geom objects encapsulated.\n\n---\n**Example:**\n\n```python\n>>> prims.geoms\n[UsdGeom.Gprim(Usd.Prim(</World/envs/env_0/Xform>)), UsdGeom.Gprim(Usd.Prim(</World/envs/env_1/Xform>)),\n UsdGeom.Gprim(Usd.Prim(</World/envs/env_2/Xform>)), UsdGeom.Gprim(Usd.Prim(</World/envs/env_3/Xform>)),\n UsdGeom.Gprim(Usd.Prim(</World/envs/env_4/Xform>))]\n```\n",
"snippet":"geoms = geometry_prim_view.geoms\n",
"category":"property"
},
{
"title":"get_applied_physics_materials",
"description":"Get the applied physics material to prims in the view.\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Returns:**\n\n * List\\[PhysicsMaterial\\]: the current applied physics materials for prims in the view.\n\n---\n**Example:**\n\n```python\n>>> # get the applied material for all prims\n>>> prims.get_applied_physics_materials()\n[<omni.isaac.core.materials.physics_material.PhysicsMaterial object at 0x7f720859ece0>,\n <omni.isaac.core.materials.physics_material.PhysicsMaterial object at 0x7f720859ece0>,\n <omni.isaac.core.materials.physics_material.PhysicsMaterial object at 0x7f720859ece0>,\n <omni.isaac.core.materials.physics_material.PhysicsMaterial object at 0x7f720859ece0>,\n <omni.isaac.core.materials.physics_material.PhysicsMaterial object at 0x7f720859ece0>]\n>>>\n>>> # get the applied material for the first, middle and last of the 5 envs\n>>> prims.get_applied_physics_materials(indices=np.array([0, 2, 4]))\n[<omni.isaac.core.materials.physics_material.PhysicsMaterial object at 0x7f720859ece0>,\n <omni.isaac.core.materials.physics_material.PhysicsMaterial object at 0x7f720859ece0>,\n <omni.isaac.core.materials.physics_material.PhysicsMaterial object at 0x7f720859ece0>]\n```\n",
"snippet":"applied_physics_materials = geometry_prim_view.get_applied_physics_materials()\n",
"category":"method"
},
{
"title":"get_applied_visual_materials",
"description":"Get the current applied visual materials\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Returns:**\n\n * List\\[VisualMaterial\\]: a list of the current applied visual materials to the prims if its type is currently supported.\n\n---\n**Example:**\n\n```python\n>>> # get all applied visual materials. Returned size is 5 for the example: 5 envs\n>>> prims.get_applied_visual_materials()\n[<omni.isaac.core.materials.omni_glass.OmniGlass object at 0x7f829c165de0>,\n <omni.isaac.core.materials.omni_glass.OmniGlass object at 0x7f829c165de0>,\n <omni.isaac.core.materials.omni_glass.OmniGlass object at 0x7f829c165de0>,\n <omni.isaac.core.materials.omni_glass.OmniGlass object at 0x7f829c165de0>,\n <omni.isaac.core.materials.omni_glass.OmniGlass object at 0x7f829c165de0>]\n>>>\n>>> # get the applied visual materials for the first, middle and last of the 5 envs. Returned size is 3\n>>> prims.get_applied_visual_materials(indices=np.array([0, 2, 4]))\n[<omni.isaac.core.materials.omni_glass.OmniGlass object at 0x7f829c165de0>,\n <omni.isaac.core.materials.omni_glass.OmniGlass object at 0x7f829c165de0>,\n <omni.isaac.core.materials.omni_glass.OmniGlass object at 0x7f829c165de0>]\n```\n",
"snippet":"applied_visual_materials = geometry_prim_view.get_applied_visual_materials()\n",
"category":"method"
},
{
"title":"get_collision_approximations",
"description":"Get collision approximation types for prims in the view.\n\n| Approximation           | Full name            | Description                                                                               |\n|-------------------------|----------------------|-------------------------------------------------------------------------------------------|\n| `\"none\"`                | Triangle Mesh        | The mesh geometry is used directly as a collider without any approximation                |\n| `\"convexDecomposition\"` | Convex Decomposition | A convex mesh decomposition is performed. This results in a set of convex mesh colliders  |\n| `\"convexHull\"`          | Convex Hull          | A convex hull of the mesh is generated and used as the collider                           |\n| `\"boundingSphere\"`      | Bounding Sphere      | A bounding sphere is computed around the mesh and used as a collider                      |\n| `\"boundingCube\"`        | Bounding Cube        | An optimally fitting box collider is computed around the mesh                             |\n| `\"meshSimplification\"`  | Mesh Simplification  | A mesh simplification step is performed, resulting in a simplified triangle mesh collider |\n| `\"sdf\"`                 | SDF Mesh             | SDF (Signed-Distance-Field) use high-detail triangle meshes as collision shape            |\n| `\"sphereFill\"`          | Sphere Approximation | A sphere mesh decomposition is performed. This results in a set of sphere colliders       |\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Returns:**\n\n * List\\[str\\]: approximations used for collision. size == M or size of the view.\n\n---\n**Example:**\n\n```python\n>>> # get the collision approximation of all prims. Returned size is (5,).\n>>> prims.get_collision_approximations()\n['none', 'none', 'none', 'none', 'none']\n>>>\n>>> # get the collision approximation of the prims for the first, middle and last of the 5 envs\n>>> prims.get_collision_approximations(indices=np.array([0, 2, 4]))\n['none', 'none', 'none']\n```\n",
"snippet":"collision_approximations = geometry_prim_view.get_collision_approximations()\n",
"category":"method"
},
{
"title":"get_contact_force_data",
"description":"Get more detailed contact information between the prims in the view and the filter prims. Specifically, this method provides individual\ncontact normals, contact points, contact separations as well as contact forces for each pair\n(the sum of which equals the forces that the get\\_contact\\_force\\_matrix method provides as the force aggregate of a pair)\nGiven to the dynamic nature of collision between bodies, this method will provide buffers of contact data which are arranged sequentially for each pair.\nThe starting index and the number of contact data points for each pair in this stream can be realized from pair\\_contacts\\_start\\_indices,\nand pair\\_contacts\\_count tensors. They both have a dimension of (self.num\\_shapes, self.num\\_filters) where filter\\_count is determined\naccording to the filter\\_paths\\_expr parameter.\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n * `dt` (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n**Returns:**\n\n * Tuple\\[Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\], Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\], Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\], Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\], Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\], Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]\\]: A set of buffers for normal forces with shape (max\\_contact\\_count, 1), points with shape (max\\_contact\\_count, 3), normals with shape (max\\_contact\\_count, 3), and distances with shape (max\\_contact\\_count, 1), as well as two tensors with shape (M, self.num\\_filters) to indicate the starting index and the number of contact data points per pair in the aforementioned buffers.\n",
"snippet":"contact_force_data = geometry_prim_view.get_contact_force_data()\n",
"category":"method"
},
{
"title":"get_contact_force_matrix",
"description":"If the object is initialized with filter\\_paths\\_expr list, this method returns the contact forces between the prims\nin the view and the filter prims. i.e., a matrix of dimension (self.count, self.\\_contact\\_view.num\\_filters, 3)\nwhere num\\_filters is the determined according to the filter\\_paths\\_expr parameter.\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n * `dt` (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: Net contact forces of the prims with shape (M, self.\\_contact\\_view.num\\_filters, 3).\n",
"snippet":"contact_force_matrix = geometry_prim_view.get_contact_force_matrix()\n",
"category":"method"
},
{
"title":"get_contact_offsets",
"description":"Get contact offsets for prims in the view.\n\nShapes whose distance is less than the sum of their contact offset values will generate contacts\n\nSearch for *Advanced Collision Detection* in for more details\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: Contact offsets of the collision shapes. Shape is (M,).\n\n---\n**Example:**\n\n```python\n>>> # get the contact offsets of all prims. Returned shape is (5,).\n>>> prims.get_contact_offsets()\n[-inf -inf -inf -inf -inf]\n>>>\n>>> # get the contact offsets of the prims for the first, middle and last of the 5 envs\n>>> prims.get_contact_offsets(indices=np.array([0, 2, 4]))\n[-inf -inf -inf]\n```\n",
"snippet":"contact_offsets = geometry_prim_view.get_contact_offsets()\n",
"category":"method"
},
{
"title":"get_default_state",
"description":"Get the default states (positions and orientations) defined with the `set_default_state` method\n\n**Returns:**\n\n * XFormPrimViewState: returns the default state of the prims that is used after each reset.\n\n---\n**Example:**\n\n```python\n>>> state = prims.get_default_state()\n>>> state\n<omni.isaac.core.utils.types.XFormPrimViewState object at 0x7f82f73e3070>\n>>> state.positions\n[[ 1.5  -0.75  0.  ]\n [ 1.5   0.75  0.  ]\n [ 0.   -0.75  0.  ]\n [ 0.    0.75  0.  ]\n [-1.5  -0.75  0.  ]]\n>>> state.orientations\n[[1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]]\n```\n",
"snippet":"default_state = geometry_prim_view.get_default_state()\n",
"category":"method"
},
{
"title":"get_local_poses",
"description":"Get prim poses in the view with respect to the local frame (the prim's parent frame)\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Returns:**\n\n * Union\\[Tuple\\[np.ndarray, np.ndarray\\], Tuple\\[torch.Tensor, torch.Tensor\\], Tuple\\[wp.indexedarray, wp.indexedarray\\]\\]: first index is translations in the local frame of the prims. shape is (M, 3). second index is quaternion orientations in the local frame of the prims. quaternion is scalar-first (w, x, y, z). shape is (M, 4).\n\n---\n**Example:**\n\n```python\n>>> # get all prims poses with respect to the local frame.\n>>> # Returned shape is position (5, 3) and orientation (5, 4) for the example: 5 envs\n>>> positions, orientations = prims.get_local_poses()\n>>> positions\n[[ 1.5  -0.75  0.  ]\n [ 1.5   0.75  0.  ]\n [ 0.   -0.75  0.  ]\n [ 0.    0.75  0.  ]\n [-1.5  -0.75  0.  ]]\n>>> orientations\n[[1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]]\n>>>\n>>> # get only the prims poses with respect to the local frame for the first, middle and last of the 5 envs.\n>>> # Returned shape is position (3, 3) and orientation (3, 4) for the example: 3 envs selected\n>>> positions, orientations = prims.get_local_poses(indices=np.array([0, 2, 4]))\n>>> positions\n[[ 1.5  -0.75  0.  ]\n [ 0.   -0.75  0.  ]\n [-1.5  -0.75  0.  ]]\n>>> orientations\n[[1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]]\n```\n",
"snippet":"local_poses = geometry_prim_view.get_local_poses()\n",
"category":"method"
},
{
"title":"get_local_scales",
"description":"Get prim scales in the view with respect to the local frame (the parent's frame).\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: scales applied to the prim's dimensions in the local frame. shape is (M, 3).\n\n---\n**Example:**\n\n```python\n>>> # get all prims scales with respect to the local frame.\n>>> # Returned shape is (5, 3) for the example: 5 envs\n>>> prims.get_local_scales()\n[[1. 1. 1.]\n [1. 1. 1.]\n [1. 1. 1.]\n [1. 1. 1.]\n [1. 1. 1.]]\n>>>\n>>> # get only the prims scales with respect to the local frame for the first, middle and last of the 5 envs.\n>>> # Returned shape is (3, 3) for the example: 3 envs selected\n>>> prims.get_local_scales(indices=np.array([0, 2, 4]))\n[[1. 1. 1.]\n [1. 1. 1.]\n [1. 1. 1.]]\n```\n",
"snippet":"local_scales = geometry_prim_view.get_local_scales()\n",
"category":"method"
},
{
"title":"get_min_torsional_patch_radii",
"description":"Get minimum torsional patch radii for prims in the view.\n\nSearch for *\"Torsional Patch Radius\"* in for more details\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor\\]: minimum radius of the contact patch used to apply torsional friction. shape is (M,).\n\n---\n**Example:**\n\n```python\n>>> # get the minimum torsional patch radius of all prims. Returned shape is (5,).\n>>> prims.get_min_torsional_patch_radii()\n[0. 0. 0. 0. 0.]\n>>>\n>>> # get the minimum torsional patch radius of the prims for the first, middle and last of the 5 envs\n>>> prims.get_min_torsional_patch_radii(indices=np.array([0, 2, 4]))\n[0. 0. 0.]\n```\n",
"snippet":"min_torsional_patch_radii = geometry_prim_view.get_min_torsional_patch_radii()\n",
"category":"method"
},
{
"title":"get_net_contact_forces",
"description":"If contact forces of the prims in the view are tracked, this method returns the net contact forces on prims.\ni.e., a matrix of dimension (self.count, 3)\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n * `dt` (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: Net contact forces of the prims with shape (M,3).\n",
"snippet":"net_contact_forces = geometry_prim_view.get_net_contact_forces()\n",
"category":"method"
},
{
"title":"get_rest_offsets",
"description":"Get rest offsets for prims in the view.\n\nTwo shapes will come to rest at a distance equal to the sum of their rest offset values.\nIf the rest offset is 0, they should converge to touching exactly\n\nSearch for *Advanced Collision Detection* in for more details\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: Rest offsets of the collision shapes. Shape is (M,).\n\n---\n**Example:**\n\n```python\n>>> # get the rest offsets of all prims. Returned shape is (5,).\n>>> prims.get_rest_offsets()\n[-inf -inf -inf -inf -inf]\n>>>\n>>> # get the rest offsets of the prims for the first, middle and last of the 5 envs\n>>> prims.get_rest_offsets(indices=np.array([0, 2, 4]))\n[-inf -inf -inf]\n```\n",
"snippet":"rest_offsets = geometry_prim_view.get_rest_offsets()\n",
"category":"method"
},
{
"title":"get_torsional_patch_radii",
"description":"Get torsional patch radii for prims in the view.\n\nSearch for *\"Torsional Patch Radius\"* in for more details\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: radius of the contact patch used to apply torsional friction. shape is (M,).\n\n---\n**Example:**\n\n```python\n>>> # get the torsional patch radius of all prims. Returned shape is (5,).\n>>> prims.get_torsional_patch_radii()\n[0. 0. 0. 0. 0.]\n>>>\n>>> # get the torsional patch radius of the prims for the first, middle and last of the 5 envs\n>>> prims.get_torsional_patch_radii(indices=np.array([0, 2, 4]))\n[0. 0. 0.]\n```\n",
"snippet":"torsional_patch_radii = geometry_prim_view.get_torsional_patch_radii()\n",
"category":"method"
},
{
"title":"get_visibilities",
"description":"Returns the current visibilities of the prims in stage.\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: Shape (M,) with type bool, where each item holds True if the prim is visible in stage. False otherwise.\n\n---\n**Example:**\n\n```python\n>>> # get all visibilities. Returned shape is (5,) for the example: 5 envs\n>>> prims.get_visibilities()\n[ True  True  True  True  True]\n>>>\n>>> # get the visibilities for the first, middle and last of the 5 envs. Returned shape is (3,)\n>>> prims.get_visibilities(indices=np.array([0, 2, 4]))\n[ True  True  True]\n```\n",
"snippet":"visibilities = geometry_prim_view.get_visibilities()\n",
"category":"method"
},
{
"title":"get_world_poses",
"description":"Get the poses of the prims in the view with respect to the world's frame\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Returns:**\n\n * Union\\[Tuple\\[np.ndarray, np.ndarray\\], Tuple\\[torch.Tensor, torch.Tensor\\], Tuple\\[wp.indexedarray, wp.indexedarray\\]\\]: first index is positions in the world frame of the prims. shape is (M, 3). second index is quaternion orientations in the world frame of the prims. quaternion is scalar-first (w, x, y, z). shape is (M, 4).\n\n---\n**Example:**\n\n```python\n>>> # get all prims poses with respect to the world's frame.\n>>> # Returned shape is position (5, 3) and orientation (5, 4) for the example: 5 envs\n>>> positions, orientations = prims.get_world_poses()\n>>> positions\n[[ 1.5  -0.75  0.  ]\n [ 1.5   0.75  0.  ]\n [ 0.   -0.75  0.  ]\n [ 0.    0.75  0.  ]\n [-1.5  -0.75  0.  ]]\n>>> orientations\n[[1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]]\n>>>\n>>> # get only the prims poses with respect to the world's frame for the first, middle and last of the 5 envs.\n>>> # Returned shape is position (3, 3) and orientation (3, 4) for the example: 3 envs selected\n>>> positions, orientations = prims.get_world_poses(indices=np.array([0, 2, 4]))\n>>> positions\n[[ 1.5  -0.75  0.  ]\n [ 0.   -0.75  0.  ]\n [-1.5  -0.75  0.  ]]\n>>> orientations\n[[1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]]\n```\n",
"snippet":"world_poses = geometry_prim_view.get_world_poses()\n",
"category":"method"
},
{
"title":"get_world_scales",
"description":"Get prim scales in the view with respect to the world's frame\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: scales applied to the prim's dimensions in the world frame. shape is (M, 3).\n\n---\n**Example:**\n\n```python\n>>> # get all prims scales with respect to the world's frame.\n>>> # Returned shape is (5, 3) for the example: 5 envs\n>>> prims.get_world_scales()\n[[1. 1. 1.]\n [1. 1. 1.]\n [1. 1. 1.]\n [1. 1. 1.]\n [1. 1. 1.]]\n>>>\n>>> # get only the prims scales with respect to the world's frame for the first, middle and last of the 5 envs.\n>>> # Returned shape is (3, 3) for the example: 3 envs selected\n>>> prims.get_world_scales(indices=np.array([0, 2, 4]))\n[[1. 1. 1.]\n [1. 1. 1.]\n [1. 1. 1.]]\n```\n",
"snippet":"world_scales = geometry_prim_view.get_world_scales()\n",
"category":"method"
},
{
"title":"initialize",
"description":"Create a physics simulation view if not passed and set other properties using the PhysX tensor API\n\n*Note:*\nIf the rigid prim view has been added to the world scene (e.g., `world.scene.add(prims)`),\nit will be automatically initialized when the world is reset (e.g., `world.reset()`).\n\n*Warning:*\nThis method needs to be called after each hard reset (e.g., Stop + Play on the timeline)\nbefore interacting with any other class method.\n\n**Args:**\n\n * `physics_sim_view` (omni.physics.tensors.SimulationView, optional): current physics simulation view. Defaults to None.\n\n---\n**Example:**\n\n```python\n>>> prims.initialize()\n```\n",
"snippet":"geometry_prim_view.initialize()\n",
"category":"method"
},
{
"title":"initialize",
"description":"Create a physics simulation view if not passed and set other properties using the PhysX tensor API\n\n*Note:*\nFor this particular class, calling this method will do nothing\n\n**Args:**\n\n * `physics_sim_view` (omni.physics.tensors.SimulationView, optional): current physics simulation view. Defaults to None.\n\n---\n**Example:**\n\n```python\n>>> prims.initialize()\n```\n",
"snippet":"geometry_prim_view.initialize()\n",
"category":"method"
},
{
"title":"is_collision_enabled",
"description":"Queries if collision is enabled on prims in the view.\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: True if collision is enabled. Shape is (M,).\n\n---\n**Example:**\n\n```python\n>>> # check if the collision is enabled for all prims. Returned size is (5,).\n>>> prims.is_collision_enabled()\n[ True  True  True  True  True]\n>>>\n>>> # check if the collision is enabled for the first, middle and last of the 5 envs\n>>> prims.is_collision_enabled(indices=np.array([0, 2, 4]))\n[ True  True  True]\n```\n",
"snippet":"value = geometry_prim_view.is_collision_enabled()\n",
"category":"method"
},
{
"title":"is_valid",
"description":"Check that all prims have a valid USD Prim\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Returns:**\n\n * bool: True if all prim paths specified in the view correspond to a valid prim in stage. False otherwise.\n\n---\n**Example:**\n\n```python\n>>> prims.is_valid()\nTrue\n```\n",
"snippet":"value = geometry_prim_view.is_valid()\n",
"category":"method"
},
{
"title":"is_visual_material_applied",
"description":"Check if there is a visual material applied\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Returns:**\n\n * List\\[bool\\]: True if there is a visual material applied is applied to the corresponding prim in the view. False otherwise.\n\n---\n**Example:**\n\n```python\n>>> # given a visual material that is applied only to the first and the last environment\n>>> prims.is_visual_material_applied()\n[True, False, False, False, True]\n>>>\n>>> # check for the first, middle and last of the 5 envs\n>>> prims.is_visual_material_applied(indices=np.array([0, 2, 4]))\n[True, False, True]\n```\n",
"snippet":"value = geometry_prim_view.is_visual_material_applied()\n",
"category":"method"
},
{
"title":"post_reset",
"description":"Reset the prims to its default state (positions and orientations)\n\n---\n**Example:**\n\n```python\n>>> prims.post_reset()\n```\n",
"snippet":"geometry_prim_view.post_reset()\n",
"category":"method"
},
{
"title":"set_collision_approximations",
"description":"Set collision approximation types for prims in the view.\n\n| Approximation           | Full name            | Description                                                                               |\n|-------------------------|----------------------|-------------------------------------------------------------------------------------------|\n| `\"none\"`                | Triangle Mesh        | The mesh geometry is used directly as a collider without any approximation                |\n| `\"convexDecomposition\"` | Convex Decomposition | A convex mesh decomposition is performed. This results in a set of convex mesh colliders  |\n| `\"convexHull\"`          | Convex Hull          | A convex hull of the mesh is generated and used as the collider                           |\n| `\"boundingSphere\"`      | Bounding Sphere      | A bounding sphere is computed around the mesh and used as a collider                      |\n| `\"boundingCube\"`        | Bounding Cube        | An optimally fitting box collider is computed around the mesh                             |\n| `\"meshSimplification\"`  | Mesh Simplification  | A mesh simplification step is performed, resulting in a simplified triangle mesh collider |\n| `\"sdf\"`                 | SDF Mesh             | SDF (Signed-Distance-Field) use high-detail triangle meshes as collision shape            |\n| `\"sphereFill\"`          | Sphere Approximation | A sphere mesh decomposition is performed. This results in a set of sphere colliders       |\n\n**Args:**\n\n * `approximation_types` (List\\[str\\]): approximations used for collision. List size == M or the size of the view.\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n---\n**Example:**\n\n```python\n>>> # set the collision approximations for all the prims to the specified values.\n>>> prims.set_collision_approximations([\"convexDecomposition\"] * num_envs)\n>>>\n>>> # set the collision approximations for the first, middle and last of the 5 envs\n>>> types = [\"convexDecomposition\", \"convexHull\", \"meshSimplification\"]\n>>> prims.set_collision_approximations(types, indices=np.array([0, 2, 4]))\n```\n",
"snippet":"geometry_prim_view.set_collision_approximations(approximation_types=approximation_types)\n",
"category":"method"
},
{
"title":"set_contact_offsets",
"description":"Set contact offsets for prims in the view.\n\nShapes whose distance is less than the sum of their contact offset values will generate contacts\n\nSearch for *Advanced Collision Detection* in for more details\n\n**Args:**\n\n * `offsets` (Union\\[np.ndarray, torch.Tensor, wp.array\\]): Contact offsets of the collision shapes. Allowed range \\[maximum(0, rest\\_offset), 0\\]. Default value is -inf, means default is picked by simulation based on the shape extent. Shape (M,).\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n---\n**Example:**\n\n```python\n>>> # set the contact offset for all the prims to the specified values.\n>>> prims.set_contact_offsets(np.full(num_envs, 0.02))\n>>>\n>>> # set the contact offset for the first, middle and last of the 5 envs\n>>> prims.set_contact_offsets(np.full(3, 0.02), indices=np.array([0, 2, 4]))\n```\n",
"snippet":"geometry_prim_view.set_contact_offsets(offsets=offsets)\n",
"category":"method"
},
{
"title":"set_default_state",
"description":"Set the default state of the prims (positions and orientations), that will be used after each reset.\n\n*Note:*\nThe default states will be set during post-reset (e.g., calling `.post_reset()` or `world.reset()` methods)\n\n**Args:**\n\n * `positions` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): positions in the world frame of the prim. shape is (M, 3). Defaults to None, which means left unchanged.\n * `orientations` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): quaternion orientations in the world frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (M, 4). Defaults to None, which means left unchanged.\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n---\n**Example:**\n\n```python\n>>> # configure default states for all prims\n>>> positions = np.zeros((num_envs, 3))\n>>> positions[:, 0] = np.arange(num_envs)\n>>> orientations = np.tile(np.array([1.0, 0.0, 0.0, 0.0]), (num_envs, 1))\n>>> prims.set_default_state(positions=positions, orientations=orientations)\n>>>\n>>> # set default states during post-reset\n>>> prims.post_reset()\n```\n",
"snippet":"geometry_prim_view.set_default_state()\n",
"category":"method"
},
{
"title":"set_local_poses",
"description":"Set prim poses in the view with respect to the local frame (the prim's parent frame)\n\n*Warning:*\nThis method will change (teleport) the prim poses immediately to the indicated value\n\n**Args:**\n\n * `translations` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): translations in the local frame of the prims (with respect to its parent prim). shape is (M, 3). Defaults to None, which means left unchanged.\n * `orientations` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): quaternion orientations in the local frame of the prims. quaternion is scalar-first (w, x, y, z). shape is (M, 4). Defaults to None, which means left unchanged.\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n*Hint:*\nThis method belongs to the methods used to set the prim state\n\n---\n**Example:**\n\n```python\n>>> # reposition all prims\n>>> positions = np.zeros((num_envs, 3))\n>>> positions[:,0] = np.arange(num_envs)\n>>> orientations = np.tile(np.array([1.0, 0.0, 0.0, 0.0]), (num_envs, 1))\n>>> prims.set_local_poses(positions, orientations)\n>>>\n>>> # reposition only the prims for the first, middle and last of the 5 envs\n>>> positions = np.zeros((3, 3))\n>>> positions[:,1] = np.arange(3)\n>>> orientations = np.tile(np.array([1.0, 0.0, 0.0, 0.0]), (3, 1))\n>>> prims.set_local_poses(positions, orientations, indices=np.array([0, 2, 4]))\n```\n",
"snippet":"geometry_prim_view.set_local_poses()\n",
"category":"method"
},
{
"title":"set_local_scales",
"description":"Set prim scales in the view with respect to the local frame (the prim's parent frame)\n\n**Args:**\n\n * `scales` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\]): scales to be applied to the prim's dimensions in the view. shape is (M, 3).\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n---\n**Example:**\n\n```python\n>>> # set the scale for all prims. Since there are 5 envs, the scale is repeated 5 times\n>>> scales = np.tile(np.array([1.0, 0.75, 0.5]), (num_envs, 1))\n>>> prims.set_local_scales(scales)\n>>>\n>>> # set the scale for the first, middle and last of the 5 envs\n>>> scales = np.tile(np.array([1.0, 0.75, 0.5]), (3, 1))\n>>> prims.set_local_scales(scales, indices=np.array([0, 2, 4]))\n```\n",
"snippet":"geometry_prim_view.set_local_scales(scales=scales)\n",
"category":"method"
},
{
"title":"set_min_torsional_patch_radii",
"description":"Set minimum torsional patch radii for prims in the view.\n\nSearch for *\"Torsional Patch Radius\"* in for more details\n\n**Args:**\n\n * `radii` (Union\\[np.ndarray, torch.Tensor, wp.array\\]): minimum radius of the contact patch used to apply torsional friction. Allowed range \\[0, max\\_float\\]. shape is (M, ).\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n---\n**Example:**\n\n```python\n>>> # set the minimum torsional patch radius for all the prims to the specified values.\n>>> prims.set_min_torsional_patch_radii(np.full(num_envs, 0.05))\n>>>\n>>> # set the minimum torsional patch radius for the first, middle and last of the 5 envs\n>>> prims.set_min_torsional_patch_radii(np.full(3, 0.05), indices=np.array([0, 2, 4]))\n```\n",
"snippet":"geometry_prim_view.set_min_torsional_patch_radii(radii=radii)\n",
"category":"method"
},
{
"title":"set_rest_offsets",
"description":"Set rest offsets for prims in the view.\n\nTwo shapes will come to rest at a distance equal to the sum of their rest offset values.\nIf the rest offset is 0, they should converge to touching exactly\n\nSearch for *Advanced Collision Detection* in for more details\n\n*Warning:*\nThe contact offset must be positive and greater than the rest offset\n\n**Args:**\n\n * `offsets` (Union\\[np.ndarray, torch.Tensor, wp.array\\]): Rest offset of a collision shape. Allowed range \\[-max\\_float, contact\\_offset\\]. Default value is -inf, means default is picked by simulation. For rigid bodies its zero. Shape (M,).\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n---\n**Example:**\n\n```python\n>>> # set the rest offset for all the prims to the specified values.\n>>> prims.set_rest_offsets(np.full(num_envs, 0.01))\n>>>\n>>> # set the rest offset for the first, middle and last of the 5 envs\n>>> prims.set_rest_offsets(np.full(3, 0.01), indices=np.array([0, 2, 4]))\n```\n",
"snippet":"geometry_prim_view.set_rest_offsets(offsets=offsets)\n",
"category":"method"
},
{
"title":"set_torsional_patch_radii",
"description":"Set torsional patch radii for prims in the view.\n\nSearch for *\"Torsional Patch Radius\"* in for more details\n\n**Args:**\n\n * `radii` (Union\\[np.ndarray, torch.Tensor, wp.array\\]): radius of the contact patch used to apply torsional friction. Allowed range \\[0, max\\_float\\]. shape is (M,).\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n---\n**Example:**\n\n```python\n>>> # set the torsional patch radius for all the prims to the specified values.\n>>> prims.set_torsional_patch_radii(np.full(num_envs, 0.1))\n>>>\n>>> # set the torsional patch radius for the first, middle and last of the 5 envs\n>>> prims.set_torsional_patch_radii(np.full(3, 0.1), indices=np.array([0, 2, 4]))\n```\n",
"snippet":"geometry_prim_view.set_torsional_patch_radii(radii=radii)\n",
"category":"method"
},
{
"title":"set_visibilities",
"description":"Set the visibilities of the prims in stage\n\n**Args:**\n\n * `visibilities` (Union\\[np.ndarray, torch.Tensor, wp.array\\]): flag to set the visibilities of the usd prims in stage. Shape (M,). Where M \\<= size of the encapsulated prims in the view.\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Defaults to None (i.e: all prims in the view).\n\n---\n**Example:**\n\n```python\n>>> # make all prims not visible in the stage\n>>> prims.set_visibilities(visibilities=[False] * num_envs)\n```\n",
"snippet":"geometry_prim_view.set_visibilities(visibilities=visibilities)\n",
"category":"method"
},
{
"title":"set_world_poses",
"description":"Set prim poses in the view with respect to the world's frame\n\n*Warning:*\nThis method will change (teleport) the prim poses immediately to the indicated value\n\n**Args:**\n\n * `positions` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): positions in the world frame of the prims. shape is (M, 3). Defaults to None, which means left unchanged.\n * `orientations` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): quaternion orientations in the world frame of the prims. quaternion is scalar-first (w, x, y, z). shape is (M, 4). Defaults to None, which means left unchanged.\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n*Hint:*\nThis method belongs to the methods used to set the prim state\n\n---\n**Example:**\n\n```python\n>>> # reposition all prims in row (x-axis)\n>>> positions = np.zeros((num_envs, 3))\n>>> positions[:,0] = np.arange(num_envs)\n>>> orientations = np.tile(np.array([1.0, 0.0, 0.0, 0.0]), (num_envs, 1))\n>>> prims.set_world_poses(positions, orientations)\n>>>\n>>> # reposition only the prims for the first, middle and last of the 5 envs in column (y-axis)\n>>> positions = np.zeros((3, 3))\n>>> positions[:,1] = np.arange(3)\n>>> orientations = np.tile(np.array([1.0, 0.0, 0.0, 0.0]), (3, 1))\n>>> prims.set_world_poses(positions, orientations, indices=np.array([0, 2, 4]))\n```\n",
"snippet":"geometry_prim_view.set_world_poses()\n",
"category":"method"
}
]
},
{
"title":"ParticleSystem",
"snippets":[
{
"title":"import ...",
"description":"Import class",
"snippet":"from omni.isaac.core.prims import ParticleSystem\n",
"category":"import"
},
{
"title":"ParticleSystem",
"description":"A wrapper around PhysX particle system.\n\nPhysX uses GPU-accelerated position-based-dynamics (PBD) particle simulation \\[1\\]. The particle system\ncan be used to simulate fluids, cloth and inflatables \\[2\\].\n\nThe wrapper is useful for creating and setting solver parameters common to the particle objects\nassociated with the system. The particle system's solver parameters cannot be changed once the scene\nis playing.\n\nNote:\n\n:   CPU simulation of particles is not supported. PhysX must be simulated with GPU enabled.\n\nReference:\n\n:   \\[1\\] <https://mmacklin.com/pbf_sig_preprint.pdf>\n    \\[2\\] <https://docs.omniverse.nvidia.com/prod_extensions/prod_extensions/ext_physics.html#particle-simulation>\n",
"snippet":"particle_system = ParticleSystem(prim_path=prim_path)\n",
"category":"class"
},
{
"title":"apply_particle_anisotropy",
"description":"Applies anisotropy to the particle system.\n\nThis is used to compute anisotropic scaling of particles in a post-processing step.\nIt only affects the rendering output including iso-surface generation.\n",
"snippet":"value = particle_system.apply_particle_anisotropy()\n",
"category":"method"
},
{
"title":"apply_particle_isotropy",
"description":"Applies iso-surface extraction to the particle system.\n\nThis is used to define settings to extract an iso-surface from the particles\nin a post-processing step. It only affects the rendering output including iso-surface generation.\n",
"snippet":"value = particle_system.apply_particle_isotropy()\n",
"category":"method"
},
{
"title":"apply_particle_material",
"description":"",
"snippet":"particle_system.apply_particle_material(particle_materials=particle_materials)\n",
"category":"method"
},
{
"title":"apply_particle_smoothing",
"description":"Applies smoothing to the simulated particle system.\n\nThis is used to control smoothing of particles in a post-processing step.\nIt only affects the rendering output including iso-surface generation.\n",
"snippet":"value = particle_system.apply_particle_smoothing()\n",
"category":"method"
},
{
"title":"get_applied_particle_material",
"description":"",
"snippet":"applied_particle_material = particle_system.get_applied_particle_material()\n",
"category":"method"
},
{
"title":"get_contact_offset",
"description":"**Returns:**\n\n * float: The contact offset used for collisions with non-particle objects.\n",
"snippet":"contact_offset = particle_system.get_contact_offset()\n",
"category":"method"
},
{
"title":"get_enable_ccd",
"description":"**Returns:**\n\n * bool: Whether continuous collision detection for particles is enabled or disabled.\n",
"snippet":"enable_ccd = particle_system.get_enable_ccd()\n",
"category":"method"
},
{
"title":"get_fluid_rest_offset",
"description":"**Returns:**\n\n * float: The rest offset used for fluid-fluid particle interactions.\n",
"snippet":"fluid_rest_offset = particle_system.get_fluid_rest_offset()\n",
"category":"method"
},
{
"title":"get_global_self_collision_enabled",
"description":"**Returns:**\n\n * bool: Whether self collisions to follow particle-object-specific settings is enabled or disabled.\n",
"snippet":"global_self_collision_enabled = particle_system.get_global_self_collision_enabled()\n",
"category":"method"
},
{
"title":"get_max_depenetration_velocity",
"description":"**Returns:**\n\n * float: The maximum velocity permitted between intersecting particles.\n",
"snippet":"particle_system.get_max_depenetration_velocity()\n",
"category":"method"
},
{
"title":"get_max_neighborhood",
"description":"**Returns:**\n\n * int: The particle neighborhood size.\n",
"snippet":"max_neighborhood = particle_system.get_max_neighborhood()\n",
"category":"method"
},
{
"title":"get_max_velocity",
"description":"**Returns:**\n\n * float: The maximum particle velocity.\n",
"snippet":"max_velocity = particle_system.get_max_velocity()\n",
"category":"method"
},
{
"title":"get_particle_contact_offset",
"description":"**Returns:**\n\n * float: The contact offset used for interactions between particles.\n",
"snippet":"particle_contact_offset = particle_system.get_particle_contact_offset()\n",
"category":"method"
},
{
"title":"get_particle_system_enabled",
"description":"**Returns:**\n\n * bool: Whether particle system is enabled or not.\n",
"snippet":"particle_system_enabled = particle_system.get_particle_system_enabled()\n",
"category":"method"
},
{
"title":"get_rest_offset",
"description":"**Returns:**\n\n * float: The rest offset used for collisions with non-particle objects.\n",
"snippet":"rest_offset = particle_system.get_rest_offset()\n",
"category":"method"
},
{
"title":"get_simulation_owner",
"description":"**Returns:**\n\n * Usd.Prim: The physics scene prim attached to particle system.\n",
"snippet":"simulation_owner = particle_system.get_simulation_owner()\n",
"category":"method"
},
{
"title":"get_solid_rest_offset",
"description":"**Returns:**\n\n * float: The rest offset used for solid-solid or solid-fluid particle interactions.\n",
"snippet":"solid_rest_offset = particle_system.get_solid_rest_offset()\n",
"category":"method"
},
{
"title":"get_solver_position_iteration_count",
"description":"**Returns:**\n\n * int: The number of solver iterations for positions.\n",
"snippet":"solver_position_iteration_count = particle_system.get_solver_position_iteration_count()\n",
"category":"method"
},
{
"title":"get_wind",
"description":"**Returns:**\n\n * Sequence\\[float\\]: The wind applied to the current particle system.\n",
"snippet":"wind = particle_system.get_wind()\n",
"category":"method"
},
{
"title":"initialize",
"description":"",
"snippet":"particle_system.initialize()\n",
"category":"method"
},
{
"title":"is_valid",
"description":"**Returns:**\n\n * bool: True is the current prim path corresponds to a valid prim in stage. False otherwise.\n",
"snippet":"value = particle_system.is_valid()\n",
"category":"method"
},
{
"title":"name",
"description":"**Returns:**\n\n * str: name given to the prim when instantiating it. Otherwise None.\n",
"snippet":"name = particle_system.name\n",
"category":"property"
},
{
"title":"particle_system",
"description":"**Returns:**\n\n * PhysxSchema.PhysxParticleSystem: The particle system.\n",
"snippet":"particle_system = particle_system.particle_system\n",
"category":"property"
},
{
"title":"post_reset",
"description":"",
"snippet":"particle_system.post_reset()\n",
"category":"method"
},
{
"title":"prim",
"description":"**Returns:**\n\n * Usd.Prim: The USD prim present.\n",
"snippet":"prim = particle_system.prim\n",
"category":"property"
},
{
"title":"prim_path",
"description":"**Returns:**\n\n * str: The stage path to the particle system.\n",
"snippet":"prim_path = particle_system.prim_path\n",
"category":"property"
},
{
"title":"set_contact_offset",
"description":"Set the contact offset used for collisions with non-particle objects such as rigid or deformable bodies.\n\n**Args:**\n\n * `value` (float): The contact offset.\n",
"snippet":"particle_system.set_contact_offset(value=value)\n",
"category":"method"
},
{
"title":"set_enable_ccd",
"description":"Enable continuous collision detection for particles.\n\n**Args:**\n\n * `value` (bool): Whether to enable or disable.\n",
"snippet":"particle_system.set_enable_ccd(value=value)\n",
"category":"method"
},
{
"title":"set_fluid_rest_offset",
"description":"Set the rest offset used for fluid-fluid particle interactions.\n\nNote: Must be smaller than particle contact offset.\n\n**Args:**\n\n * `value` (float): The rest offset.\n",
"snippet":"particle_system.set_fluid_rest_offset(value=value)\n",
"category":"method"
},
{
"title":"set_global_self_collision_enabled",
"description":"Enable self collisions to follow particle-object-specific settings.\n\nIf True, self collisions follow particle-object-specific settings. If False,\nall particle self collisions are disabled, regardless of any other settings.\n\nNote: Improves performance if self collisions are not needed.\n\n**Args:**\n\n * `value` (bool): Whether to enable or disable.\n",
"snippet":"particle_system.set_global_self_collision_enabled(value=value)\n",
"category":"method"
},
{
"title":"set_max_depenetration_velocity",
"description":"Set the maximum velocity permitted to be introduced by the solver to\ndepenetrate intersecting particles.\n\n**Args:**\n\n * `value` (float): The maximum depenetration velocity.\n",
"snippet":"particle_system.set_max_depenetration_velocity(value=value)\n",
"category":"method"
},
{
"title":"set_max_neighborhood",
"description":"Set the particle neighborhood size.\n\n**Args:**\n\n * `value` (int): The neighborhood size.\n",
"snippet":"particle_system.set_max_neighborhood(value=value)\n",
"category":"method"
},
{
"title":"set_max_velocity",
"description":"Set the maximum particle velocity.\n\n**Args:**\n\n * `value` (float): The maximum velocity.\n",
"snippet":"particle_system.set_max_velocity(value=value)\n",
"category":"method"
},
{
"title":"set_particle_contact_offset",
"description":"Set the contact offset used for interactions between particles.\n\nNote: Must be larger than solid and fluid rest offsets.\n\n**Args:**\n\n * `value` (float): The contact offset.\n",
"snippet":"particle_system.set_particle_contact_offset(value=value)\n",
"category":"method"
},
{
"title":"set_particle_system_enabled",
"description":"Set enabling of the particle system.\n\n**Args:**\n\n * `value` (bool): Whether to enable or disable.\n",
"snippet":"particle_system.set_particle_system_enabled(value=value)\n",
"category":"method"
},
{
"title":"set_rest_offset",
"description":"Set the rest offset used for collisions with non-particle objects such as rigid or deformable bodies.\n\n**Args:**\n\n * `value` (float): The rest offset.\n",
"snippet":"particle_system.set_rest_offset(value=value)\n",
"category":"method"
},
{
"title":"set_simulation_owner",
"description":"Set the PhysicsScene that simulates this particle system.\n\n**Args:**\n\n * `value` (str): The prim path to the physics scene.\n",
"snippet":"particle_system.set_simulation_owner(value=value)\n",
"category":"method"
},
{
"title":"set_solid_rest_offset",
"description":"Set the rest offset used for solid-solid or solid-fluid particle interactions.\n\nNote: Must be smaller than particle contact offset.\n\n**Args:**\n\n * `value` (float): The rest offset.\n",
"snippet":"particle_system.set_solid_rest_offset(value=value)\n",
"category":"method"
},
{
"title":"set_solver_position_iteration_count",
"description":"Set the number of solver iterations for position.\n\n**Args:**\n\n * `value` (int): Number of solver iterations.\n",
"snippet":"particle_system.set_solver_position_iteration_count(value=value)\n",
"category":"method"
},
{
"title":"set_wind",
"description":"Set the wind velocity applied to the current particle system.\n\n**Args:**\n\n * `value` (Sequence\\[float\\]): The wind applied to the current particle system.\n",
"snippet":"particle_system.set_wind(value=value)\n",
"category":"method"
}
]
},
{
"title":"ParticleSystemView",
"snippets":[
{
"title":"import ...",
"description":"Import class",
"snippet":"from omni.isaac.core.prims import ParticleSystemView\n",
"category":"import"
},
{
"title":"ParticleSystemView",
"description":"Provides high level functions to deal with particle systems (1 or more particle systems) as well as its attributes/ properties.\nThis object wraps all matching particle systems found at the regex provided at the prim\\_paths\\_expr.\nNote: not all the attributes of the PhysxSchema.PhysxParticleSystem is currently controlled with this view class\nTensor API support will be added in the future to extend the functionality of this class to applications beyond cloth.\n",
"snippet":"particle_system_view = ParticleSystemView(prim_paths_expr=prim_paths_expr)\n",
"category":"class"
},
{
"title":"apply_particle_materials",
"description":"Used to apply particle material to prims in the view.\n\n**Args:**\n\n * `particle_materials` (Union\\[ParticleMaterial, List\\[ParticleMaterial\\]\\]): particle materials to be applied to prims in the view. Note: if a physics material is not defined, the defaults will be used from PhysX. If a list is provided then its size has to be equal the view's size or indices size. If one material is provided it will be applied to all prims in the view.\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Raises:**\n\n * Exception: length of physics materials != length of prims indexed\n",
"snippet":"particle_system_view.apply_particle_materials(particle_materials=particle_materials)\n",
"category":"method"
},
{
"title":"count",
"description":"**Returns:**\n\n * int: number of rigid shapes for the prims in the view.\n",
"snippet":"count = particle_system_view.count\n",
"category":"property"
},
{
"title":"get_applied_particle_materials",
"description":"Gets the applied particle material to prims in the view.\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Returns:**\n\n * List\\[ParticleMaterial\\]: the current applied particle materials for prims in the view.\n",
"snippet":"applied_particle_materials = particle_system_view.get_applied_particle_materials()\n",
"category":"method"
},
{
"title":"get_contact_offsets",
"description":"**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor\\]: The contact offset used for collisions with non-particle objects for each particle system. shape is (M, ).\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view)\n",
"snippet":"contact_offsets = particle_system_view.get_contact_offsets()\n",
"category":"method"
},
{
"title":"get_enable_ccds",
"description":"**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor\\]: Whether continuous collision detection for particles is enabled or disabled for each particle system. shape is (M, ).\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view)\n",
"snippet":"enable_ccds = particle_system_view.get_enable_ccds()\n",
"category":"method"
},
{
"title":"get_fluid_rest_offsets",
"description":"**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor\\]: The rest offset used for fluid-fluid particle interactions. shape is (M, ).\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view)\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n",
"snippet":"fluid_rest_offsets = particle_system_view.get_fluid_rest_offsets()\n",
"category":"method"
},
{
"title":"get_global_self_collisions_enabled",
"description":"**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor\\]: Whether self collisions to follow particle-object-specific settings is enabled or disabled. for each particle system. shape is (M, ).\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view)\n",
"snippet":"global_self_collisions_enabled = particle_system_view.get_global_self_collisions_enabled()\n",
"category":"method"
},
{
"title":"get_max_depenetration_velocities",
"description":"**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor\\]: The maximum velocity permitted to be introduced by the solver to depenetrate intersecting particles for particle systems for each particle system. shape is (M, ).\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view)\n",
"snippet":"max_depenetration_velocities = particle_system_view.get_max_depenetration_velocities()\n",
"category":"method"
},
{
"title":"get_max_neighborhoods",
"description":"**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor\\]: The particle neighborhood size for each particle system. shape is (M, ).\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view)\n",
"snippet":"max_neighborhoods = particle_system_view.get_max_neighborhoods()\n",
"category":"method"
},
{
"title":"get_max_velocities",
"description":"**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor\\]: The maximum particle velocities for each particle system. shape is (M, ).\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view)\n",
"snippet":"max_velocities = particle_system_view.get_max_velocities()\n",
"category":"method"
},
{
"title":"get_particle_contact_offsets",
"description":"**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor\\]: The contact offset used for interactions between particles in the view concatenated. shape is (M, ).\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view)\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n",
"snippet":"particle_contact_offsets = particle_system_view.get_particle_contact_offsets()\n",
"category":"method"
},
{
"title":"get_particle_systems_enabled",
"description":"**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor\\]: Whether particle system is enabled or not for each particle system. shape is (M, ).\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view)\n",
"snippet":"particle_systems_enabled = particle_system_view.get_particle_systems_enabled()\n",
"category":"method"
},
{
"title":"get_rest_offsets",
"description":"**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor\\]: The rest offset used for collisions with non-particle objects for each particle system. shape is (M, ).\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view)\n",
"snippet":"rest_offsets = particle_system_view.get_rest_offsets()\n",
"category":"method"
},
{
"title":"get_simulation_owners",
"description":"**Returns:**\n\n * Sequence\\[str\\]: The physics scene prim path attached to particle system. shape is (M, ).\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view)\n",
"snippet":"simulation_owners = particle_system_view.get_simulation_owners()\n",
"category":"method"
},
{
"title":"get_solid_rest_offsets",
"description":"**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor\\]: The rest offset used for solid-solid or solid-fluid particle interactions. shape is (M, ).\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view)\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n",
"snippet":"solid_rest_offsets = particle_system_view.get_solid_rest_offsets()\n",
"category":"method"
},
{
"title":"get_solver_position_iteration_counts",
"description":"**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor\\]: The number of solver iterations for positions for each particle system. shape is (M, ).\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view)\n",
"snippet":"solver_position_iteration_counts = particle_system_view.get_solver_position_iteration_counts()\n",
"category":"method"
},
{
"title":"get_winds",
"description":"**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor\\]: The winds applied to the current particle system. shape is (M, 3).\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view)\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n",
"snippet":"winds = particle_system_view.get_winds()\n",
"category":"method"
},
{
"title":"initialize",
"description":"Create a physics simulation view if not passed and creates a Particle System View.\n\n**Args:**\n\n * `physics_sim_view` (omni.physics.tensors.SimulationView, optional): current physics simulation view. Defaults to None.\n",
"snippet":"particle_system_view.initialize()\n",
"category":"method"
},
{
"title":"is_physics_handle_valid",
"description":"**Returns:**\n\n * bool: True if the physics handle of the view is valid (i.e physics is initialized for the view). Otherwise False.\n",
"snippet":"value = particle_system_view.is_physics_handle_valid()\n",
"category":"method"
},
{
"title":"is_valid",
"description":"**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Returns:**\n\n * bool: True if all prim paths specified in the view correspond to a valid prim in stage. False otherwise.\n",
"snippet":"value = particle_system_view.is_valid()\n",
"category":"method"
},
{
"title":"name",
"description":"**Returns:**\n\n * str: name given to the view when instantiating it.\n",
"snippet":"name = particle_system_view.name\n",
"category":"property"
},
{
"title":"post_reset",
"description":"Resets the particles to their initial states.\n",
"snippet":"particle_system_view.post_reset()\n",
"category":"method"
},
{
"title":"set_contact_offsets",
"description":"Set the contact offset used for collisions with non-particle objects such as rigid or deformable bodies for particle systems.\n\n**Args:**\n\n * `values` (Optional\\[Union\\[np.ndarray, torch.Tensor\\]\\]): maximum particle velocity tensor to set particle systems to. shape is (M, ).\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n",
"snippet":"particle_system_view.set_contact_offsets(values=values)\n",
"category":"method"
},
{
"title":"set_enable_ccds",
"description":"Enable continuous collision detection for particles for particle systems.\n\n**Args:**\n\n * `values` (Optional\\[Union\\[np.ndarray, torch.Tensor\\]\\]): maximum particle velocity tensor to set particle systems to. shape is (M, ).\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n",
"snippet":"particle_system_view.set_enable_ccds(values=values)\n",
"category":"method"
},
{
"title":"set_fluid_rest_offsets",
"description":"Set the rest offset used for fluid-fluid particle interactions.\n\nNote: Must be smaller than particle contact offset.\n\n**Args:**\n\n * `values` (Optional\\[Union\\[np.ndarray, torch.Tensor\\]\\]): fluid rest offset to set particle systems to. shape is (M, ).\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n",
"snippet":"particle_system_view.set_fluid_rest_offsets(values=values)\n",
"category":"method"
},
{
"title":"set_global_self_collisions_enabled",
"description":"Enable self collisions to follow particle-object-specific settings for particle systems.\n\n**Args:**\n\n * `values` (Optional\\[Union\\[np.ndarray, torch.Tensor\\]\\]): maximum particle velocity tensor to set particle systems to. shape is (M, ).\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n",
"snippet":"particle_system_view.set_global_self_collisions_enabled(values=values)\n",
"category":"method"
},
{
"title":"set_max_depenetration_velocities",
"description":"Set the maximum velocity permitted to be introduced by the solver to depenetrate intersecting particles for particle systems.\n\n**Args:**\n\n * `values` (Optional\\[Union\\[np.ndarray, torch.Tensor\\]\\]): maximum particle velocity tensor to set particle systems to. shape is (M, ).\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n",
"snippet":"particle_system_view.set_max_depenetration_velocities(values=values)\n",
"category":"method"
},
{
"title":"set_max_neighborhoods",
"description":"Set the particle neighborhood size for particle systems.\n\n**Args:**\n\n * `values` (Optional\\[Union\\[np.ndarray, torch.Tensor\\]\\]): maximum particle velocity tensor to set particle systems to. shape is (M, ).\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n",
"snippet":"particle_system_view.set_max_neighborhoods(values=values)\n",
"category":"method"
},
{
"title":"set_max_velocities",
"description":"Set the maximum particle velocity for particle systems.\n\n**Args:**\n\n * `values` (Optional\\[Union\\[np.ndarray, torch.Tensor\\]\\]): maximum particle velocity tensor to set particle systems to. shape is (M, ).\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n",
"snippet":"particle_system_view.set_max_velocities(values=values)\n",
"category":"method"
},
{
"title":"set_particle_contact_offsets",
"description":"Set the contact offset used for interactions between particles.\n\nNote: Must be larger than solid and fluid rest offsets.\n\n**Args:**\n\n * `values` (Optional\\[Union\\[np.ndarray, torch.Tensor\\]\\]): The contact offset.\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n",
"snippet":"particle_system_view.set_particle_contact_offsets(values=values)\n",
"category":"method"
},
{
"title":"set_particle_systems_enabled",
"description":"Set enabling of the particle systems.\n\n**Args:**\n\n * `values` (Optional\\[Union\\[np.ndarray, torch.Tensor\\]\\]): maximum particle velocity tensor to set particle systems to. shape is (M, ).\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n",
"snippet":"particle_system_view.set_particle_systems_enabled(values=values)\n",
"category":"method"
},
{
"title":"set_rest_offsets",
"description":"Set the rest offset used for collisions with non-particle objects such as rigid or deformable bodies for particle systems.\n\n**Args:**\n\n * `values` (Optional\\[Union\\[np.ndarray, torch.Tensor\\]\\]): maximum particle velocity tensor to set particle systems to. shape is (M, ).\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n",
"snippet":"particle_system_view.set_rest_offsets(values=values)\n",
"category":"method"
},
{
"title":"set_simulation_owners",
"description":"Set the PhysicsScene that simulates particle systems.\n\n**Args:**\n\n * `values` (Sequence\\[str\\]): PhysicsScene list to set particle systems to. shape is (M, ).\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n",
"snippet":"particle_system_view.set_simulation_owners(values=values)\n",
"category":"method"
},
{
"title":"set_solid_rest_offsets",
"description":"Set the rest offset used for solid-solid or solid-fluid particle interactions.\n\nNote: Must be smaller than particle contact offset.\n\n**Args:**\n\n * `values` (Optional\\[Union\\[np.ndarray, torch.Tensor\\]\\]): solid rest offset to set particle systems to. shape is (M, ).\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n",
"snippet":"particle_system_view.set_solid_rest_offsets(values=values)\n",
"category":"method"
},
{
"title":"set_solver_position_iteration_counts",
"description":"Set the number of solver iterations for position for particle systems.\n\n**Args:**\n\n * `values` (Optional\\[Union\\[np.ndarray, torch.Tensor\\]\\]): maximum particle velocity tensor to set particle systems to. shape is (M, ).\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n",
"snippet":"particle_system_view.set_solver_position_iteration_counts(values=values)\n",
"category":"method"
},
{
"title":"set_winds",
"description":"Set the winds velocities applied to the current particle system.\n\n**Args:**\n\n * `values` (Optional\\[Union\\[np.ndarray, torch.Tensor\\]\\]): The wind applied to the current particle system. shape is (M, 3).\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n",
"snippet":"particle_system_view.set_winds(values=values)\n",
"category":"method"
}
]
},
{
"title":"RigidContactView",
"snippets":[
{
"title":"import ...",
"description":"Import class",
"snippet":"from omni.isaac.core.prims import RigidContactView\n",
"category":"import"
},
{
"title":"RigidContactView",
"description":"Provides high level functions to deal with rigid prims (one or many) that track their contacts through filters\nas well as their attributes/properties.\n\nThis class wraps all matching rigid prims found at the regex provided at the `prim_paths_expr` argument\n\n*Warning:*\nThe rigid prim view object must be initialized in order to be able to operate on it.\nSee the `initialize` method for more details.\n\n**Args:**\n\n * `prim_paths_expr` (str): prim paths regex to encapsulate all prims that match it. example: \"/World/Env\\[1-5\\]/Cube\" will match /World/Env1/Cube, /World/Env2/Cube..etc. (a non regex prim path can also be used to encapsulate one rigid prim).\n * `name` (str, optional): shortname to be used as a key by Scene class. Note: needs to be unique if the object is added to the Scene. Defaults to \"rigid\\_contact\\_view\".\n * `prepare_contact_sensors` (bool, Optional): if rigid prims in the view are not cloned from a prim in a prepared state, (although slow for large number of prims) this ensures that appropriate physics settings are applied on all the prim in the view.\n * `disable_stablization` (bool, optional): disables the contact stabilization parameter in the physics context\n * `max_contact_count` (int, optional): maximum number of contact data to report when detailed contact information is needed\n\n---\n**Example:**\n\n```python\n>>> import omni.isaac.core.utils.stage as stage_utils\n>>> from omni.isaac.cloner import GridCloner\n>>> from omni.isaac.core.prims import RigidContactView\n>>> from pxr import UsdGeom\n>>>\n>>> env_zero_path = \"/World/envs/env_0\"\n>>> num_envs = 5\n>>>\n>>> # clone the environment (num_envs)\n>>> cloner = GridCloner(spacing=0)\n>>> cloner.define_base_env(env_zero_path)\n>>> UsdGeom.Xform.Define(stage_utils.get_current_stage(), env_zero_path)\n>>> stage_utils.get_current_stage().DefinePrim(f\"{env_zero_path}/Xform\", \"Xform\")\n>>> stage_utils.get_current_stage().DefinePrim(f\"{env_zero_path}/Xform/Cube\", \"Cube\")\n>>> # position the cubes on top of each other\n>>> position_offsets = np.zeros((num_envs, 3))\n>>> position_offsets[:, 2] = np.arange(num_envs) * 1.1\n>>> env_pos = cloner.clone(\n...     source_prim_path=env_zero_path,\n...     prim_paths=cloner.generate_paths(\"/World/envs/env\", num_envs),\n...     position_offsets=position_offsets\n...     copy_from_source=True,\n... )\n>>>\n>>> # wrap the prims\n>>> prims = RigidContactView(\n...     prim_paths_expr=\"/World/envs/env.*/Xform\",\n...     name=\"RigidContactView_view\",\n...     filter_paths_expr=[\"/World/envs/env_2/Xform\"],\n...     max_contact_count=10,\n... )\n>>> prims\n<omni.isaac.core.prims.rigid_contact_view.RigidContactView object at 0x7f8d4eb1abf0>\n```\n",
"snippet":"rigid_contact_view = RigidContactView(prim_paths_expr=prim_paths_expr, filter_paths_expr=filter_paths_expr)\n",
"category":"class"
},
{
"title":"get_contact_force_data",
"description":"Get more detailed contact information between the prims in the view and the filter prims.\n\nSpecifically, this method provides individual contact normals, contact points, contact separations as well as\ncontact forces for each pair (the sum of which equals the forces that the `get_contact_force_matrix`\nmethod provides as the force aggregate of a pair)\n\nGiven to the dynamic nature of collision between bodies, this method will provide buffers of contact data which\nare arranged sequentially for each pair. The starting index and the number of contact data points for each pair\nin this stream can be realized from pair\\_contacts\\_start\\_indices, and pair\\_contacts\\_count tensors.\nThey both have a dimension of `(num_shapes, num_filters)` where `num_filters` is determined\naccording to the `filter_paths_expr` parameter\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n * `dt` (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n**Returns:**\n\n * Tuple\\[Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\], Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\],\n    Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\], Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\],\n    Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\], Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]\\]:\n    A set of buffers for normal forces with shape (max\\_contact\\_count, 1), points with shape (max\\_contact\\_count, 3), normals with shape (max\\_contact\\_count, 3),\n    and distances with shape (max\\_contact\\_count, 1), as well as two tensors with shape (M, self.num\\_filters)\n    to indicate the starting index and the number of contact data points per pair in the aforementioned buffers.\n\n---\n**Example:**\n\n```python\n>>> # get detailed contact force data between the prims and the filter prims (the cube in the middle)\n>>> data = prims.get_contact_force_data()\n>>> data[0]  # normal forces\n[[-168.53815]\n [ -89.57392]\n [-156.10307]\n [ -75.17234]\n [  98.0681 ]\n [  52.56319]\n [ 108.26558]\n [  67.62025]\n [   0.     ]\n [   0.     ]]\n>>> data[1]  # points\n[[ 0.4948182  -0.49902824  1.5001888 ]\n [ 0.4950411   0.49933064  1.5001996 ]\n [-0.5024581   0.49930018  1.5001924 ]\n [-0.5024276  -0.49880558  1.5001817 ]\n [-0.5023767   0.497138    2.5001519 ]\n [-0.502735   -0.49877006  2.5001822 ]\n [ 0.4947694  -0.4989927   2.500226  ]\n [ 0.4949917   0.49677914  2.5001955 ]\n [ 0.          0.          0.        ]\n [ 0.          0.          0.        ]]\n>>> data[2]  # normals\n[[-4.3812128e-05  3.0501858e-05  1.0000000e+00]\n [-4.3812128e-05  3.0501858e-05  1.0000000e+00]\n [-4.3812128e-05  3.0501858e-05  1.0000000e+00]\n [-4.3812128e-05  3.0501858e-05  1.0000000e+00]\n [ 2.1408198e-06 -7.0731985e-05  1.0000000e+00]\n [ 2.1408198e-06 -7.0731985e-05  1.0000000e+00]\n [ 2.1408198e-06 -7.0731985e-05  1.0000000e+00]\n [ 2.1408198e-06 -7.0731985e-05  1.0000000e+00]\n [ 0.0000000e+00  0.0000000e+00  0.0000000e+00]\n [ 0.0000000e+00  0.0000000e+00  0.0000000e+00]]\n>>> data[3]  # distances\n[[ 3.7143487e-05]\n [-4.0254322e-06]\n [-4.0531158e-05]\n [ 6.0737699e-07]\n [ 1.9307560e-04]\n [ 9.2272363e-05]\n [ 4.6372414e-05]\n [ 1.4718286e-04]\n [ 0.0000000e+00]\n [ 0.0000000e+00]]\n>>> data[4]  # pair contacts count\n[[0]\n [4]\n [0]\n [4]\n [0]]\n>>> data[5]  # start indices of pair contacts\n[[0]\n [0]\n [4]\n [4]\n [8]]\n```\n",
"snippet":"contact_force_data = rigid_contact_view.get_contact_force_data()\n",
"category":"method"
},
{
"title":"get_contact_force_matrix",
"description":"Get the contact forces between the prims in the view and the filter prims.\n\nE.g., a matrix of dimension `(num_shapes, num_filters, 3)` where `num_filters` is\ndetermined according to the `filter_paths_expr` parameter\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n * `dt` (float): time step multiplier to convert the underlying impulses to forces. The function returns contact impulses if the default dt is used\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: Net contact forces between the view prim and the filter prims with shape (M, self.num\\_filters, 3).\n\n---\n**Example:**\n\n```python\n>>> # get the contact forces between the prims and the filter prims (the cube in the middle)\n>>> prims.get_contact_force_matrix()\n[[[ 0.0000000e+00  0.0000000e+00  0.0000000e+00]]\n [[ 2.2649009e-02 -1.3710857e-02 -4.9047806e+02]]\n [[ 0.0000000e+00  0.0000000e+00  0.0000000e+00]]\n [[-3.3276828e-03 -2.3870371e-02  3.2733777e+02]]\n [[ 0.0000000e+00  0.0000000e+00  0.0000000e+00]]]\n```\n",
"snippet":"contact_force_matrix = rigid_contact_view.get_contact_force_matrix()\n",
"category":"method"
},
{
"title":"get_net_contact_forces",
"description":"Get the overall net contact forces on the prims in the view with respect to the world's frame.\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n * `dt` (float): time step multiplier to convert the underlying impulses to forces. The function returns contact impulses if the default dt is used\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: Net contact forces of the prims with shape (M,3).\n\n---\n**Example:**\n\n```python\n>>> # get the net contact force on all rigid bodies. Returned shape is (5, 3).\n>>> prims.get_net_contact_forces()\n[[ 1.8731881e-03  5.4876995e-03  1.6408131e+02]\n [ 1.9060407e-02 -2.2513291e-02  1.6358723e+02]\n [-2.1011427e-02  3.5647806e-02  1.6371542e+02]\n [ 9.4006478e-05 -9.3258200e-03  1.6348369e+02]\n [ 9.3709816e-05 -9.2963902e-03  1.6296776e+02]]\n>>>\n>>> # get the net contact force on the rigid bodies for the first, middle and last of the 5 envs\n>>> prims.get_net_contact_forces(indices=np.array([0, 2, 4]))\n[[ 1.8731881e-03  5.4876995e-03  1.6408131e+02]\n [-2.1011427e-02  3.5647806e-02  1.6371542e+02]\n [ 9.3709816e-05 -9.2963902e-03  1.6296776e+02]]\n```\n",
"snippet":"net_contact_forces = rigid_contact_view.get_net_contact_forces()\n",
"category":"method"
},
{
"title":"initialize",
"description":"Create a physics simulation view if not passed and set other properties using the PhysX tensor API\n\n*Note:*\nIf the rigid prim view has been added to the world scene (e.g., `world.scene.add(prims)`),\nit will be automatically initialized when the world is reset (e.g., `world.reset()`).\n\n*Warning:*\nThis method needs to be called after each hard reset (e.g., Stop + Play on the timeline)\nbefore interacting with any other class method.\n\n**Args:**\n\n * `physics_sim_view` (omni.physics.tensors.SimulationView, optional): current physics simulation view. Defaults to None.\n\n---\n**Example:**\n\n```python\n>>> prims.initialize()\n```\n",
"snippet":"rigid_contact_view.initialize()\n",
"category":"method"
},
{
"title":"is_physics_handle_valid",
"description":"Check if rigid prim view's physics handler is initialized\n\n*Warning:*\nIf the physics handler is not valid many of the methods that requires PhysX will return None.\n\n**Returns:**\n\n * bool: True if the physics handle of the view is valid (i.e physics is initialized for the view). Otherwise False.\n\n---\n**Example:**\n\n```python\n>>> prims.is_physics_handle_valid()\nTrue\n```\n",
"snippet":"value = rigid_contact_view.is_physics_handle_valid()\n",
"category":"method"
},
{
"title":"num_filters",
"description":"**Returns:**\n\n * int: number of filters bodies that report their contact with the rigid prims.\n\n---\n**Example:**\n\n```python\n>>> prims.num_filters\n1\n```\n",
"snippet":"num_filters = rigid_contact_view.num_filters\n",
"category":"property"
},
{
"title":"num_shapes",
"description":"**Returns:**\n\n * int: number of rigid shapes for the prims in the view.\n\n---\n**Example:**\n\n```python\n>>> prims.num_shapes\n5\n```\n",
"snippet":"num_shapes = rigid_contact_view.num_shapes\n",
"category":"property"
}
]
},
{
"title":"RigidPrim",
"snippets":[
{
"title":"import ...",
"description":"Import class",
"snippet":"from omni.isaac.core.prims import RigidPrim\n",
"category":"import"
},
{
"title":"RigidPrim",
"description":"High level wrapper to deal with a rigid body prim (only one rigid body prim) and its attributes/properties.\n\n*Warning:*\nThe rigid body object must be initialized in order to be able to operate on it.\nSee the `initialize` method for more details.\n\n*Note:*\nIf the prim does not already have the Rigid Body API applied to it before init, it will apply it.\n\n**Args:**\n\n * `prim_path` (str): prim path of the Prim to encapsulate or create.\n * `name` (str, optional): shortname to be used as a key by Scene class. Note: needs to be unique if the object is added to the Scene. Defaults to \"rigid\\_prim\".\n * `position` (Optional\\[Sequence\\[float\\]\\], optional): position in the world frame of the prim. shape is (3, ). Defaults to None, which means left unchanged.\n * `translation` (Optional\\[Sequence\\[float\\]\\], optional): translation in the local frame of the prim (with respect to its parent prim). shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the world/ local frame of the prim (depends if translation or position is specified). quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n * `scale` (Optional\\[Sequence\\[float\\]\\], optional): local scale to be applied to the prim's dimensions. shape is (3, ). Defaults to None, which means left unchanged.\n * `visible` (bool, optional): set to false for an invisible prim in the stage while rendering. Defaults to True.\n * `mass` (Optional\\[float\\], optional): mass in kg. Defaults to None.\n * `density` (Optional\\[float\\], optional): density. Defaults to None.\n * `linear_velocity` (Optional\\[np.ndarray\\], optional): linear velocity in the world frame. Defaults to None.\n * `angular_velocity` (Optional\\[np.ndarray\\], optional): angular velocity in the world frame. Defaults to None.\n\n---\n**Example:**\n\n```python\n>>> import omni.isaac.core.utils.stage as stage_utils\n>>> from omni.isaac.core.prims import RigidPrim\n>>>\n>>> # create a Cube at the given path\n>>> stage_utils.get_current_stage().DefinePrim(\"/World/Xform\", \"Xform\")\n>>> stage_utils.get_current_stage().DefinePrim(\"/World/Xform/Cube\", \"Cube\")\n>>>\n>>> # wrap the prim as rigid prim\n>>> prim = RigidPrim(\"/World/Xform\")\n>>> prim\n<omni.isaac.core.prims.rigid_prim.RigidPrim object at 0x7fc4a7f56e90>\n```\n",
"snippet":"rigid_prim = RigidPrim(prim_path=prim_path)\n",
"category":"class"
},
{
"title":"apply_visual_material",
"description":"Apply visual material to the held prim and optionally its descendants.\n\n**Args:**\n\n * `visual_material` (VisualMaterial): visual material to be applied to the held prim. Currently supports PreviewSurface, OmniPBR and OmniGlass.\n * `weaker_than_descendants` (bool, optional): True if the material shouldn't override the descendants materials, otherwise False. Defaults to False.\n\n---\n**Example:**\n\n```python\n>>> from omni.isaac.core.materials import OmniGlass\n>>>\n>>> # create a dark-red glass visual material\n>>> material = OmniGlass(\n...     prim_path=\"/World/material/glass\",  # path to the material prim to create\n...     ior=1.25,\n...     depth=0.001,\n...     thin_walled=False,\n...     color=np.array([0.5, 0.0, 0.0])\n... )\n>>> prim.apply_visual_material(material)\n```\n",
"snippet":"rigid_prim.apply_visual_material(visual_material=visual_material)\n",
"category":"method"
},
{
"title":"disable_rigid_body_physics",
"description":"Disable the rigid body physics\n\nWhen disabled, the object will not be moved by external forces such as gravity and collisions\n\n---\n**Example:**\n\n```python\n>>> prim.disable_rigid_body_physics()\n```\n",
"snippet":"rigid_prim.disable_rigid_body_physics()\n",
"category":"method"
},
{
"title":"enable_rigid_body_physics",
"description":"Enable the rigid body physics\n\nWhen enabled, the object will be moved by external forces such as gravity and collisions\n\n---\n**Example:**\n\n```python\n>>> prim.enable_rigid_body_physics()\n```\n",
"snippet":"rigid_prim.enable_rigid_body_physics()\n",
"category":"method"
},
{
"title":"get_angular_velocity",
"description":"Get the angular velocity of the rigid body\n\n**Returns:**\n\n * np.ndarray: current angular velocity of the the rigid prim. Shape (3,).\n\n---\n**Example:**\n\n```python\n>>> prim.get_angular_velocity()]\n[-0.01727393  0.00827609 -0.00040014]\n```\n",
"snippet":"rigid_prim.get_angular_velocity()\n",
"category":"method"
},
{
"title":"get_applied_visual_material",
"description":"Return the current applied visual material in case it was applied using apply\\_visual\\_material\nor it's one of the following materials that was already applied before: PreviewSurface, OmniPBR and OmniGlass.\n\n**Returns:**\n\n * VisualMaterial: the current applied visual material if its type is currently supported.\n\n---\n**Example:**\n\n```python\n>>> # given a visual material applied\n>>> prim.get_applied_visual_material()\n<omni.isaac.core.materials.omni_glass.OmniGlass object at 0x7f36263106a0>\n```\n",
"snippet":"applied_visual_material = rigid_prim.get_applied_visual_material()\n",
"category":"method"
},
{
"title":"get_current_dynamic_state",
"description":"Get the current rigid body state (position, orientation and linear and angular velocities)\n\n**Returns:**\n\n * DynamicState: the dynamic state of the rigid body prim\n\n---\n**Example:**\n\n```python\n>>> # for the example the rigid body is in free fall\n>>> state = prim.get_current_dynamic_state()\n>>> state\n<omni.isaac.core.utils.types.DynamicState object at 0x7f740b36f670>\n>>> state.position\n[  0.99999857   2.0000017  -74.2862    ]\n>>> state.orientation\n[ 1.0000000e+00 -2.3961178e-07 -4.9891562e-09  4.9388258e-09]\n>>> state.linear_velocity\n[  0.        0.      -38.09554]\n>>> state.angular_velocity\n[0. 0. 0.]\n```\n",
"snippet":"current_dynamic_state = rigid_prim.get_current_dynamic_state()\n",
"category":"method"
},
{
"title":"get_default_state",
"description":"Get the default rigid body state (position, orientation and linear and angular velocities)\n\n**Returns:**\n\n * DynamicState: returns the default state of the prim that is used after each reset\n\n---\n**Example:**\n\n```python\n>>> state = prim.get_default_state()\n>>> state\n<omni.isaac.core.utils.types.DynamicState object at 0x7f7411fcbe20>\n>>> state.position\n[-7.8622378e-07  1.4450421e-06  1.6135601e-07]\n>>> state.orientation\n[ 9.9999994e-01 -2.7194994e-07  2.9607077e-07  2.7016510e-08]\n>>> state.linear_velocity\n[0. 0. 0.]\n>>> state.angular_velocity\n[0. 0. 0.]\n```\n",
"snippet":"default_state = rigid_prim.get_default_state()\n",
"category":"method"
},
{
"title":"get_default_state",
"description":"Get the default prim states (spatial position and orientation).\n\n**Returns:**\n\n * XFormPrimState: an object that contains the default state of the prim (position and orientation)\n\n---\n**Example:**\n\n```python\n>>> state = prim.get_default_state()\n>>> state\n<omni.isaac.core.utils.types.XFormPrimState object at 0x7f33addda650>\n>>>\n>>> state.position\n[-4.5299529e-08 -1.8347054e-09 -2.8610229e-08]\n>>> state.orientation\n[1. 0. 0. 0.]\n```\n",
"snippet":"default_state = rigid_prim.get_default_state()\n",
"category":"method"
},
{
"title":"get_density",
"description":"Get the density of the rigid body\n\n**Returns:**\n\n * float: density of the rigid body.\n\n---\n**Example:**\n\n```python\n>>> prim.get_density()\n0\n```\n",
"snippet":"density = rigid_prim.get_density()\n",
"category":"method"
},
{
"title":"get_linear_velocity",
"description":"Get the linear velocity of the rigid body\n\n**Returns:**\n\n * np.ndarray: current linear velocity of the the rigid prim. Shape (3,).\n\n---\n**Example:**\n\n```python\n>>> prim.get_linear_velocity()\n[ 1.0812164e-04  6.1415871e-05 -2.1341663e-04]\n```\n",
"snippet":"linear_velocity = rigid_prim.get_linear_velocity()\n",
"category":"method"
},
{
"title":"get_local_pose",
"description":"Get prim's pose with respect to the local frame (the prim's parent frame)\n\n**Returns:**\n\n * Tuple\\[np.ndarray, np.ndarray\\]: first index is the position in the local frame (with shape (3, )).\n    Second index is quaternion orientation (with shape (4, )) in the local frame\n\n---\n**Example:**\n\n```python\n>>> # if the prim is in position (1.0, 0.5, 0.0) with respect to the world frame\n>>> position, orientation = prim.get_local_pose()\n>>> position\n[0. 0. 0.]\n>>> orientation\n[0. 0. 0.]\n```\n",
"snippet":"local_pose = rigid_prim.get_local_pose()\n",
"category":"method"
},
{
"title":"get_local_scale",
"description":"Get prim's scale with respect to the local frame (the parent's frame)\n\n**Returns:**\n\n * np.ndarray: scale applied to the prim's dimensions in the local frame. shape is (3, ).\n\n---\n**Example:**\n\n```python\n>>> prim.get_local_scale()\n[1. 1. 1.]\n```\n",
"snippet":"local_scale = rigid_prim.get_local_scale()\n",
"category":"method"
},
{
"title":"get_mass",
"description":"Get the mass of the rigid body\n\n**Returns:**\n\n * float: mass of the rigid body in kg.\n\n---\n**Example:**\n\n```python\n>>> prim.get_mass()\n0\n```\n",
"snippet":"mass = rigid_prim.get_mass()\n",
"category":"method"
},
{
"title":"get_sleep_threshold",
"description":"Get the threshold for the rigid body to enter a sleep state\n\nSearch for *Rigid Body Dynamics* \\> *Sleeping* in for more details\n\n**Returns:**\n\n * float: Mass-normalized kinetic energy threshold below which an actor may go to sleep. Range: \\[0, inf) Defaults: 0.00005 \\* tolerancesSpeed\\* tolerancesSpeed Units: distance\\^2 / second\\^2.\n\n---\n**Example:**\n\n```python\n>>> prim.get_sleep_threshold()\n5e-05\n```\n",
"snippet":"sleep_threshold = rigid_prim.get_sleep_threshold()\n",
"category":"method"
},
{
"title":"get_visibility",
"description":"**Returns:**\n\n * bool: true if the prim is visible in stage. false otherwise.\n\n---\n**Example:**\n\n```python\n>>> # get the visible state of an visible prim on the stage\n>>> prim.get_visibility()\nTrue\n```\n",
"snippet":"visibility = rigid_prim.get_visibility()\n",
"category":"method"
},
{
"title":"get_world_pose",
"description":"Get prim's pose with respect to the world's frame\n\n**Returns:**\n\n * Tuple\\[np.ndarray, np.ndarray\\]: first index is the position in the world frame (with shape (3, )).\n    Second index is quaternion orientation (with shape (4, )) in the world frame\n\n---\n**Example:**\n\n```python\n>>> # if the prim is in position (1.0, 0.5, 0.0) with respect to the world frame\n>>> position, orientation = prim.get_world_pose()\n>>> position\n[1.  0.5 0. ]\n>>> orientation\n[1. 0. 0. 0.]\n```\n",
"snippet":"world_pose = rigid_prim.get_world_pose()\n",
"category":"method"
},
{
"title":"get_world_scale",
"description":"Get prim's scale with respect to the world's frame\n\n**Returns:**\n\n * np.ndarray: scale applied to the prim's dimensions in the world frame. shape is (3, ).\n\n---\n**Example:**\n\n```python\n>>> prim.get_world_scale()\n[1. 1. 1.]\n```\n",
"snippet":"world_scale = rigid_prim.get_world_scale()\n",
"category":"method"
},
{
"title":"initialize",
"description":"Create a physics simulation view if not passed and using PhysX tensor API\n\n*Note:*\nIf the prim has been added to the world scene (e.g., `world.scene.add(prim)`),\nit will be automatically initialized when the world is reset (e.g., `world.reset()`).\n\n**Args:**\n\n * `physics_sim_view` (omni.physics.tensors.SimulationView, optional): current physics simulation view. Defaults to None.\n\n---\n**Example:**\n\n```python\n>>> prim.initialize()\n```\n",
"snippet":"rigid_prim.initialize()\n",
"category":"method"
},
{
"title":"is_valid",
"description":"Check if the prim path has a valid USD Prim at it\n\n**Returns:**\n\n * bool: True is the current prim path corresponds to a valid prim in stage. False otherwise.\n\n---\n**Example:**\n\n```python\n>>> # given an existing and valid prim\n>>> prims.is_valid()\nTrue\n```\n",
"snippet":"value = rigid_prim.is_valid()\n",
"category":"method"
},
{
"title":"is_visual_material_applied",
"description":"Check if there is a visual material applied\n\n**Returns:**\n\n * bool: True if there is a visual material applied. False otherwise.\n\n---\n**Example:**\n\n```python\n>>> # given a visual material applied\n>>> prim.is_visual_material_applied()\nTrue\n```\n",
"snippet":"value = rigid_prim.is_visual_material_applied()\n",
"category":"method"
},
{
"title":"post_reset",
"description":"Reset the prim to its default state (position and orientation).\n\n*Note:*\nFor an articulation, in addition to configuring the root prim's default position and spatial orientation\n(defined via the `set_default_state` method), the joint's positions, velocities, and efforts\n(defined via the `set_joints_default_state` method) are imposed\n\n---\n**Example:**\n\n```python\n>>> prim.post_reset()\n```\n",
"snippet":"rigid_prim.post_reset()\n",
"category":"method"
},
{
"title":"set_angular_velocity",
"description":"Set the angular velocity of the rigid body in stage\n\n*Warning:*\nThis method will immediately set the articulation state\n\n**Args:**\n\n * `velocity` (np.ndarray): angular velocity to set the rigid prim to. Shape (3,).\n\n*Hint:*\nThis method belongs to the methods used to set the rigid prim kinematic state:\n\n> `set_linear_velocity`, `set_angular_velocity`\n\n---\n**Example:**\n\n```python\n>>> prim.set_angular_velocity(np.array([0.0, 0.0, 10.0]))\n```\n",
"snippet":"rigid_prim.set_angular_velocity(velocity=velocity)\n",
"category":"method"
},
{
"title":"set_default_state",
"description":"Set the default state of the prim (position, orientation and linear and angular velocities),\nthat will be used after each reset\n\n*Note:*\nThe default states will be set during post-reset (e.g., calling `.post_reset()` or `world.reset()` methods)\n\n**Args:**\n\n * `position` (Optional\\[Sequence\\[float\\]\\], optional): position in the world frame of the prim. shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the world frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n * `linear_velocity` (np.ndarray): linear velocity to set the rigid prim to. Shape (3,).\n * `angular_velocity` (np.ndarray): angular velocity to set the rigid prim to. Shape (3,).\n\n---\n**Example:**\n\n```python\n>>> prim.set_default_state(\n...     position=np.array([1.0, 2.0, 3.0]),\n...     orientation=np.array([1.0, 0.0, 0.0, 0.0]),\n...     linear_velocity=np.array([0.0, 0.0, 0.0]),\n...     angular_velocity=np.array([0.0, 0.0, 0.0])\n... )\n>>>\n>>> prim.post_reset()\n```\n",
"snippet":"rigid_prim.set_default_state()\n",
"category":"method"
},
{
"title":"set_default_state",
"description":"Set the default state of the prim (position and orientation), that will be used after each reset.\n\n**Args:**\n\n * `position` (Optional\\[Sequence\\[float\\]\\], optional): position in the world frame of the prim. shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the world frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n\n---\n**Example:**\n\n```python\n>>> # configure default state\n>>> prim.set_default_state(position=np.array([1.0, 0.5, 0.0]), orientation=np.array([1, 0, 0, 0]))\n>>>\n>>> # set default states during post-reset\n>>> prim.post_reset()\n```\n",
"snippet":"rigid_prim.set_default_state()\n",
"category":"method"
},
{
"title":"set_density",
"description":"Set the density of the rigid body\n\n**Args:**\n\n * `mass` (float): density of the rigid body.\n\n---\n**Example:**\n\n```python\n>>> prim.set_density(0.9)\n```\n",
"snippet":"rigid_prim.set_density(density=density)\n",
"category":"method"
},
{
"title":"set_linear_velocity",
"description":"Set the linear velocity of the rigid body in stage\n\n*Warning:*\nThis method will immediately set the rigid prim state\n\n**Args:**\n\n * `velocity` (np.ndarray): linear velocity to set the rigid prim to. Shape (3,).\n\n*Hint:*\nThis method belongs to the methods used to set the rigid prim kinematic state:\n\n> `set_linear_velocity`, `set_angular_velocity`\n\n---\n**Example:**\n\n```python\n>>> prim.set_linear_velocity(np.array([5.0, 0.0, 0.0]))\n```\n",
"snippet":"rigid_prim.set_linear_velocity(velocity=velocity)\n",
"category":"method"
},
{
"title":"set_local_pose",
"description":"Set prim's pose with respect to the local frame (the prim's parent frame).\n\n*Warning:*\nThis method will change (teleport) the prim pose immediately to the indicated value\n\n**Args:**\n\n * `translation` (Optional\\[Sequence\\[float\\]\\], optional): translation in the local frame of the prim (with respect to its parent prim). shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the local frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n\n*Hint:*\nThis method belongs to the methods used to set the prim state\n\n---\n**Example:**\n\n```python\n>>> prim.set_local_pose(translation=np.array([1.0, 0.5, 0.0]), orientation=np.array([1., 0., 0., 0.]))\n```\n",
"snippet":"rigid_prim.set_local_pose()\n",
"category":"method"
},
{
"title":"set_local_scale",
"description":"Set prim's scale with respect to the local frame (the prim's parent frame).\n\n**Args:**\n\n * `scale` (Optional\\[Sequence\\[float\\]\\]): scale to be applied to the prim's dimensions. shape is (3, ). Defaults to None, which means left unchanged.\n\n---\n**Example:**\n\n```python\n>>> # scale prim 10 times smaller\n>>> prim.set_local_scale(np.array([0.1, 0.1, 0.1]))\n```\n",
"snippet":"rigid_prim.set_local_scale(scale=scale)\n",
"category":"method"
},
{
"title":"set_mass",
"description":"Set the mass of the rigid body\n\n**Args:**\n\n * `mass` (float): mass of the rigid body in kg.\n\n---\n**Example:**\n\n```python\n>>> prim.set_mass(1.0)\n```\n",
"snippet":"rigid_prim.set_mass(mass=mass)\n",
"category":"method"
},
{
"title":"set_sleep_threshold",
"description":"Set the threshold for the rigid body to enter a sleep state\n\nSearch for *Rigid Body Dynamics* \\> *Sleeping* in for more details\n\n**Args:**\n\n * `threshold` (float): Mass-normalized kinetic energy threshold below which an actor may go to sleep. Range: \\[0, inf) Defaults: 0.00005 \\* tolerancesSpeed\\* tolerancesSpeed Units: distance\\^2 / second\\^2.\n\n---\n**Example:**\n\n```python\n>>> prim.set_sleep_threshold(1e-5)\n```\n",
"snippet":"rigid_prim.set_sleep_threshold(threshold=threshold)\n",
"category":"method"
},
{
"title":"set_visibility",
"description":"Set the visibility of the prim in stage\n\n**Args:**\n\n * `visible` (bool): flag to set the visibility of the usd prim in stage.\n\n---\n**Example:**\n\n```python\n>>> # make prim not visible in the stage\n>>> prim.set_visibility(visible=False)\n```\n",
"snippet":"rigid_prim.set_visibility(visible=visible)\n",
"category":"method"
},
{
"title":"set_world_pose",
"description":"Ses prim's pose with respect to the world's frame\n\n*Warning:*\nThis method will change (teleport) the prim pose immediately to the indicated value\n\n**Args:**\n\n * `position` (Optional\\[Sequence\\[float\\]\\], optional): position in the world frame of the prim. shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the world frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n\n*Hint:*\nThis method belongs to the methods used to set the prim state\n\n---\n**Example:**\n\n```python\n>>> prim.set_world_pose(position=np.array([1.0, 0.5, 0.0]), orientation=np.array([1., 0., 0., 0.]))\n```\n",
"snippet":"rigid_prim.set_world_pose()\n",
"category":"method"
}
]
},
{
"title":"RigidPrimView",
"snippets":[
{
"title":"import ...",
"description":"Import class",
"snippet":"from omni.isaac.core.prims import RigidPrimView\n",
"category":"import"
},
{
"title":"RigidPrimView",
"description":"Provides high level functions to deal with prims (one or many) that have Rigid Body API applied to them\nas well as their attributes/properties.\n\nThis class wraps all matching rigid prims found at the regex provided at the `prim_paths_expr` argument\n\n*Note:*\nEach prim will have `xformOp:orient`, `xformOp:translate` and `xformOp:scale` only post-init,\nunless it is a non-root articulation link.\n\n> If the prims do not already have the Rigid Body API applied to them before init, it will apply it.\n\n*Warning:*\nThe rigid prim view object must be initialized in order to be able to operate on it.\nSee the `initialize` method for more details.\n\n**Args:**\n\n * `prim_paths_expr` (str): prim paths regex to encapsulate all prims that match it. example: \"/World/Env\\[1-5\\]/Cube\" will match /World/Env1/Cube, /World/Env2/Cube..etc. (a non regex prim path can also be used to encapsulate one rigid prim).\n\n * `name` (str, optional): shortname to be used as a key by Scene class. Note: needs to be unique if the object is added to the Scene. Defaults to \"rigid\\_prim\\_view\".\n\n * `positions` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): default positions in the world frame of the prims. shape is (N, 3). Defaults to None, which means left unchanged.\n\n * `translations` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): default translations in the local frame of the prims (with respect to its parent prims). shape is (N, 3). Defaults to None, which means left unchanged.\n\n * `orientations` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): default quaternion orientations in the world/ local frame of the prims (depends if translation or position is specified). quaternion is scalar-first (w, x, y, z). shape is (N, 4). Defaults to None, which means left unchanged.\n\n * `scales` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): local scales to be applied to the prim's dimensions in the view. shape is (N, 3). Defaults to None, which means left unchanged.\n\n * `visibilities` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): set to false for an invisible prim in the stage while rendering. shape is (N,). Defaults to None.\n\n * `reset_xform_properties` (bool, optional): True if the prims don't have the right set of xform properties (i.e: translate, orient and scale) ONLY and in that order. Set this parameter to False if the object were cloned using using the cloner api in omni.isaac.cloner. Defaults to True.\n\n * `masses` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): mass in kg specified for each prim in the view. shape is (N,). Defaults to None.\n\n * `densities` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): density in kg/m\\^3 specified for each prim in the view. shape is (N,). Defaults to None.\n\n * `linear_velocities` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): default linear velocity of each prim in the view (to be applied in the first frame and on resets). Shape is (N, 3). Defaults to None.\n\n * \n\n        `angular_velocities` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): default angular velocity of each prim in the view (to be applied in the first frame and on resets). Shape is (N, 3). Defaults to None.\n\n        :   track\\_contact\\_forces (bool, Optional) : if enabled, the view will track the net contact forces on each rigid prim in the view\n\n * `prepare_contact_sensors` (bool, Optional): if rigid prims in the view are not cloned from a prim in a prepared state, (although slow for large number of prims) this ensures that appropriate physics settings are applied on all the prim in the view.\n\n * `disable_stablization` (bool, optional): disables the contact stabilization parameter in the physics context\n\n * `contact_filter_prim_paths_expr` (Optional\\[List\\[str\\]\\], Optional): a list of filter expressions which allows for tracking contact forces between prims and this subset through get\\_contact\\_force\\_matrix().\n\n * `max_contact_count` (int, optional): maximum number of contact data to report when detailed contact information is needed\n\n---\n**Example:**\n\n```python\n>>> import omni.isaac.core.utils.stage as stage_utils\n>>> from omni.isaac.cloner import GridCloner\n>>> from omni.isaac.core.prims import RigidPrimView\n>>> from pxr import UsdGeom\n>>>\n>>> env_zero_path = \"/World/envs/env_0\"\n>>> num_envs = 5\n>>>\n>>> # clone the environment (num_envs)\n>>> cloner = GridCloner(spacing=1.5)\n>>> cloner.define_base_env(env_zero_path)\n>>> UsdGeom.Xform.Define(stage_utils.get_current_stage(), env_zero_path)\n>>> stage_utils.get_current_stage().DefinePrim(f\"{env_zero_path}/Xform\", \"Xform\")\n>>> stage_utils.get_current_stage().DefinePrim(f\"{env_zero_path}/Xform/Cube\", \"Cube\")\n>>> env_pos = cloner.clone(\n...     source_prim_path=env_zero_path,\n...     prim_paths=cloner.generate_paths(\"/World/envs/env\", num_envs),\n...     copy_from_source=True\n... )\n>>>\n>>> # wrap the prims\n>>> prims = RigidPrimView(prim_paths_expr=\"/World/envs/env.*/Xform\", name=\"rigid_prim_view\")\n>>> prims\n<omni.isaac.core.prims.rigid_prim_view.RigidPrimView object at 0x7f9a23b8bb80>\n```\n",
"snippet":"rigid_prim_view = RigidPrimView(prim_paths_expr=prim_paths_expr)\n",
"category":"class"
},
{
"title":"apply_forces",
"description":"Applies forces to prims in the view.\n\n**Args:**\n\n * `forces` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\]): forces to be applied to the prims.\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `is_global` (bool, optional): True if forces are in the global frame. Otherwise False. Defaults to True.\n\n---\n**Example:**\n\n```python\n>>> # apply an external force to all the rigid bodies to the indicated values.\n>>> # Since there are 5 envs, the inertias are repeated 5 times\n>>> forces = np.tile(np.array([2e5, 1e5, 0.0]), (num_envs, 1))\n>>> prims.apply_forces(forces)\n>>>\n>>> # apply an external force to the rigid bodies for the first, middle and last of the 5 envs\n>>> forces = np.tile(np.array([2e5, 1e5, 0.0]), (3, 1))\n>>> prims.apply_forces(forces, indices=np.array([0, 2, 4]))\n```\n",
"snippet":"rigid_prim_view.apply_forces(forces=forces)\n",
"category":"method"
},
{
"title":"apply_forces_and_torques_at_pos",
"description":"Applies forces and torques to prims in the view. The forces and/or torques can be in local or global coordinates.\nThe forces can applied at a location given by positions variable.\n\n**Args:**\n\n * `forces` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\]): forces to be applied to the prims. If not specified, no force will be applied. Defaults to None (i.e: no forces will be applied).\n * `torques` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\]): torques to be applied to the prims. If not specified, no torque will be applied. Defaults to None (i.e: no torques will be applied).\n * `positions` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\]): position of the forces with respect to the body frame. If not specified, the forces are applied at the origin of the body frame. Defaults to None (i.e: applied forces will be at the origin of the body frame).\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `is_global` (bool, optional): True if forces, torques, and positions are in the global frame. False if forces, torques, and positions are in the local frame. Defaults to True.\n\n---\n**Example:**\n\n```python\n>>> # apply an external force and torque to all the rigid bodies to the indicated values.\n>>> # Since there are 5 envs, the inertias are repeated 5 times\n>>> forces = np.tile(np.array([2e5, 1e5, 0.0]), (num_envs, 1))\n>>> torques = np.tile(np.array([2e5, 1e5, 0.0]), (num_envs, 1))\n>>> prims.apply_forces_and_torques_at_pos(forces, torques)\n>>>\n>>> # apply an external force and torque to the rigid bodies for the first, middle and last of the 5 envs\n>>> forces = np.tile(np.array([2e5, 1e5, 0.0]), (3, 1))\n>>> torques = np.tile(np.array([2e5, 1e5, 0.0]), (3, 1))\n>>> prims.apply_forces_and_torques_at_pos(forces, torques, indices=np.array([0, 2, 4]))\n```\n",
"snippet":"rigid_prim_view.apply_forces_and_torques_at_pos()\n",
"category":"method"
},
{
"title":"apply_visual_materials",
"description":"Apply visual material to the prims and optionally their prim descendants.\n\n**Args:**\n\n * `visual_materials` (Union\\[VisualMaterial, List\\[VisualMaterial\\]\\]): visual materials to be applied to the prims. Currently supports PreviewSurface, OmniPBR and OmniGlass. If a list is provided then its size has to be equal the view's size or indices size. If one material is provided it will be applied to all prims in the view.\n * `weaker_than_descendants` (Optional\\[Union\\[bool, List\\[bool\\]\\]\\], optional): True if the material shouldn't override the descendants materials, otherwise False. Defaults to False. If a list of visual materials is provided then a list has to be provided with the same size for this arg as well.\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Raises:**\n\n * Exception: length of visual materials != length of prims indexed\n    Exception: length of visual materials != length of weaker descendants bools arg\n\n---\n**Example:**\n\n```python\n>>> from omni.isaac.core.materials import OmniGlass\n>>>\n>>> # create a dark-red glass visual material\n>>> material = OmniGlass(\n...     prim_path=\"/World/material/glass\",  # path to the material prim to create\n...     ior=1.25,\n...     depth=0.001,\n...     thin_walled=False,\n...     color=np.array([0.5, 0.0, 0.0])\n... )\n>>> prims.apply_visual_materials(material)\n```\n",
"snippet":"rigid_prim_view.apply_visual_materials(visual_materials=visual_materials)\n",
"category":"method"
},
{
"title":"disable_gravities",
"description":"Disable gravity on rigid bodies (enabled by default).\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n---\n**Example:**\n\n```python\n>>> # disable the gravity for all rigid bodies\n>>> prims.disable_gravities()\n>>>\n>>> # disable the rigid body gravity for the first, middle and last of the 5 envs\n>>> prims.disable_gravities(indices=np.array([0, 2, 4]))\n```\n",
"snippet":"rigid_prim_view.disable_gravities()\n",
"category":"method"
},
{
"title":"disable_rigid_body_physics",
"description":"Disable rigid body physics (enabled by default)\n\nWhen disabled, the objects will not be moved by external forces such as gravity and collisions\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n---\n**Example:**\n\n```python\n>>> # enable the rigid body dynamics for all rigid bodies\n>>> prims.disable_rigid_body_physics()\n>>>\n>>> # enable the rigid body dynamics for the first, middle and last of the 5 envs\n>>> prims.disable_rigid_body_physics(indices=np.array([0, 2, 4]))\n```\n",
"snippet":"rigid_prim_view.disable_rigid_body_physics()\n",
"category":"method"
},
{
"title":"enable_gravities",
"description":"Enable gravity on rigid bodies (enabled by default).\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n---\n**Example:**\n\n```python\n>>> # enable the gravity for all rigid bodies\n>>> prims.enable_gravities()\n>>>\n>>> # enable the rigid body gravity for the first, middle and last of the 5 envs\n>>> prims.enable_gravities(indices=np.array([0, 2, 4]))\n```\n",
"snippet":"rigid_prim_view.enable_gravities()\n",
"category":"method"
},
{
"title":"enable_rigid_body_physics",
"description":"Enable rigid body physics (enabled by default)\n\nWhen enabled, the objects will be moved by external forces such as gravity and collisions\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n---\n**Example:**\n\n```python\n>>> # enable the rigid body dynamics for all rigid bodies\n>>> prims.enable_rigid_body_physics()\n>>>\n>>> # enable the rigid body dynamics for the first, middle and last of the 5 envs\n>>> prims.enable_rigid_body_physics(indices=np.array([0, 2, 4]))\n```\n",
"snippet":"rigid_prim_view.enable_rigid_body_physics()\n",
"category":"method"
},
{
"title":"get_angular_velocities",
"description":"Get the angular velocities of prims in the view.\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view)\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: angular velocities of the prims in the view. shape is (M, 3).\n\n---\n**Example:**\n\n```python\n>>> # get all rigid prim angular velocities. Returned shape is (5, 3) for the example: 5 envs, angular (3)\n>>> prims.get_angular_velocities()\n[[0. 0. 0.]\n [0. 0. 0.]\n [0. 0. 0.]\n [0. 0. 0.]\n [0. 0. 0.]]\n>>>\n>>> # get only the rigid prim angular velocities for the first, middle and last of the 5 envs\n>>> # Returned shape is (5, 3) for the example: 3 envs selected, angular (3)\n>>> prims.get_angular_velocities(indices=np.array([0, 2, 4]))\n[[0. 0. 0.]\n [0. 0. 0.]\n [0. 0. 0.]]\n```\n",
"snippet":"angular_velocities = rigid_prim_view.get_angular_velocities()\n",
"category":"method"
},
{
"title":"get_applied_visual_materials",
"description":"Get the current applied visual materials\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Returns:**\n\n * List\\[VisualMaterial\\]: a list of the current applied visual materials to the prims if its type is currently supported.\n\n---\n**Example:**\n\n```python\n>>> # get all applied visual materials. Returned size is 5 for the example: 5 envs\n>>> prims.get_applied_visual_materials()\n[<omni.isaac.core.materials.omni_glass.OmniGlass object at 0x7f829c165de0>,\n <omni.isaac.core.materials.omni_glass.OmniGlass object at 0x7f829c165de0>,\n <omni.isaac.core.materials.omni_glass.OmniGlass object at 0x7f829c165de0>,\n <omni.isaac.core.materials.omni_glass.OmniGlass object at 0x7f829c165de0>,\n <omni.isaac.core.materials.omni_glass.OmniGlass object at 0x7f829c165de0>]\n>>>\n>>> # get the applied visual materials for the first, middle and last of the 5 envs. Returned size is 3\n>>> prims.get_applied_visual_materials(indices=np.array([0, 2, 4]))\n[<omni.isaac.core.materials.omni_glass.OmniGlass object at 0x7f829c165de0>,\n <omni.isaac.core.materials.omni_glass.OmniGlass object at 0x7f829c165de0>,\n <omni.isaac.core.materials.omni_glass.OmniGlass object at 0x7f829c165de0>]\n```\n",
"snippet":"applied_visual_materials = rigid_prim_view.get_applied_visual_materials()\n",
"category":"method"
},
{
"title":"get_coms",
"description":"Get rigid body center of mass (COM) of bodies in the view.\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: rigid body center of mass positions and orientations of prims in the view.\n    position shape is (M, 1, 3), orientation shape is (M, 1, 4).\n\n---\n**Example:**\n\n```python\n>>> # get all rigid body center of mass.\n>>> # Returned shape is (5, 1, 3) for positions and (5, 1, 4) for orientations for the example: 5 envs\n>>> positions, orientations = prims.get_coms()\n>>> positions\n[[[0. 0. 0.]]\n [[0. 0. 0.]]\n [[0. 0. 0.]]\n [[0. 0. 0.]]\n [[0. 0. 0.]]]\n>>> orientations\n[[[1. 0. 0. 0.]]\n [[1. 0. 0. 0.]]\n [[1. 0. 0. 0.]]\n [[1. 0. 0. 0.]]\n [[1. 0. 0. 0.]]]\n>>>\n>>> # get rigid body center of mass for the first, middle and last of the 5 envs.\n>>> # Returned shape is (3, 1, 3) for positions and (3, 1, 4) for orientations\n>>> positions, orientations = prims.get_coms(indices=np.array([0, 2, 4]))\n>>> positions\n[[[0. 0. 0.]]\n [[0. 0. 0.]]\n [[0. 0. 0.]]]\n>>> orientations\n[[[1. 0. 0. 0.]]\n [[1. 0. 0. 0.]]\n [[1. 0. 0. 0.]]]\n```\n",
"snippet":"coms = rigid_prim_view.get_coms()\n",
"category":"method"
},
{
"title":"get_contact_force_data",
"description":"Get more detailed contact information between the prims in the view and the filter prims.\n\nSpecifically, this method provides individual contact normals, contact points, contact separations as well as\ncontact forces for each pair (the sum of which equals the forces that the `get_contact_force_matrix`\nmethod provides as the force aggregate of a pair)\n\nGiven to the dynamic nature of collision between bodies, this method will provide buffers of contact data which\nare arranged sequentially for each pair. The starting index and the number of contact data points for each pair\nin this stream can be realized from pair\\_contacts\\_start\\_indices, and pair\\_contacts\\_count tensors.\nThey both have a dimension of `(num_shapes, _contact_view.num_filters)` where `_contact_view.num_filters`\nis determined according to the `contact_filter_prim_paths_expr` parameter\n\n*Note:*\nThis method requires that the contact forces of the prims in the view be tracked by defining\nthe `contact_filter_prim_paths_expr` argument to a list of the prim paths from which to generate\nthe information and the `max_contact_count` argument be greater than 0 during view creation\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n * `dt` (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n**Returns:**\n\n * Tuple\\[Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\], Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\],\n    Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\], Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\],\n    Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\], Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]\\]:\n    A set of buffers for normal forces with shape (max\\_contact\\_count, 1), points with shape (max\\_contact\\_count, 3), normals with shape (max\\_contact\\_count, 3),\n    and distances with shape (max\\_contact\\_count, 1), as well as two tensors with shape (M, self.num\\_filters)\n    to indicate the starting index and the number of contact data points per pair in the aforementioned buffers.\n\n---\n**Example:**\n\n```python\n>>> # for the example, the cubes are on top of each other. The view was instantiated with the following\n>>> # extra parameters: contact_filter_prim_paths_expr=[\"/World/envs/env_2/Xform\"], max_contact_count=10\n>>> # This indicates that only contacts with the middle cube will be reported\n>>> data = prims.get_contact_force_data()\n>>> data[0]  # normal forces\n[[-156.449   ]\n [ -81.736336]\n [-169.73076 ]\n [ -82.397804]\n [ 110.11985 ]\n [  59.646057]\n [  98.660545]\n [  58.43006 ]\n [   0.      ]\n [   0.      ]]\n>>> data[1]  # points\n[[-0.50145745  0.49872556  0.7056795 ]\n [-0.50184476 -0.5010655   0.7057198 ]\n [ 0.49793154 -0.50147027  0.70576656]\n [ 0.4983363   0.49833822  0.70572615]\n [ 0.49818155 -0.5016888   1.7058725 ]\n [ 0.49856627  0.4913648   1.7058672 ]\n [-0.49732465  0.4915302   1.705814  ]\n [-0.49748957 -0.501303    1.7058194 ]\n [ 0.          0.          0.        ]\n [ 0.          0.          0.        ]]\n>>> data[2]  # normals\n[[ 1.6479074e-05 -1.6995813e-05  1.0000000e+00]\n [ 1.6479074e-05 -1.6995813e-05  1.0000000e+00]\n [ 1.6479074e-05 -1.6995813e-05  1.0000000e+00]\n [ 1.6479074e-05 -1.6995813e-05  1.0000000e+00]\n [ 1.6479074e-05 -1.6995813e-05  1.0000000e+00]\n [ 1.6479074e-05 -1.6995813e-05  1.0000000e+00]\n [ 1.6479074e-05 -1.6995813e-05  1.0000000e+00]\n [ 1.6479074e-05 -1.6995813e-05  1.0000000e+00]\n [ 0.0000000e+00  0.0000000e+00  0.0000000e+00]\n [ 0.0000000e+00  0.0000000e+00  0.0000000e+00]]\n>>> data[3]  # distances\n[[ 6.3175990e-05]\n [ 5.8271162e-06]\n [-5.7399273e-05]\n [-1.0989098e-08]\n [ 1.6338757e-04]\n [ 1.4112510e-04]\n [ 7.1585178e-05]\n [ 9.3835908e-05]\n [ 0.0000000e+00]\n [ 0.0000000e+00]]\n>>> data[4]  # pair contacts count\n[[0]\n [4]\n [0]\n [4]\n [0]]\n>>> data[5]  # start indices of pair contacts\n[[0]\n [0]\n [4]\n [4]\n [8]]\n```\n",
"snippet":"contact_force_data = rigid_prim_view.get_contact_force_data()\n",
"category":"method"
},
{
"title":"get_contact_force_matrix",
"description":"Return the contact forces between the prims in the view and the filter prims\n\nE.g., a matrix of dimension `(self.count, _contact_view.num_filters, 3)` where `_contact_view.num_filters`\nis determined according to the `contact_filter_prim_paths_expr` parameter\n\n*Note:*\nThis method requires that the contact forces of the prims in the view be tracked by defining\nthe `contact_filter_prim_paths_expr` argument to a list of the prim paths from which to generate\nthe information and the `max_contact_count` argument be greater than 0 during view creation\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n * `dt` (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: Net contact forces of the prims with shape (M, self.\\_contact\\_view.num\\_filters, 3).\n\n---\n**Example:**\n\n```python\n>>> # for the example, the cubes are on top of each other. The view was instantiated with the following\n>>> # extra parameters: contact_filter_prim_paths_expr=[\"/World/envs/env_2/Xform\"], max_contact_count=10\n>>> # This indicates that only contacts with the middle cube will be reported\n>>> prims.get_contact_force_matrix()\n[[[ 0.0000000e+00  0.0000000e+00  0.0000000e+00]]\n [[-7.8665102e-03  8.3034458e-03 -4.9063504e+02]]\n [[ 0.0000000e+00  0.0000000e+00  0.0000000e+00]]\n [[ 5.2445102e-03 -5.5358098e-03  3.2710065e+02]]\n [[ 0.0000000e+00  0.0000000e+00  0.0000000e+00]]]\n```\n",
"snippet":"contact_force_matrix = rigid_prim_view.get_contact_force_matrix()\n",
"category":"method"
},
{
"title":"get_current_dynamic_state",
"description":"Get the current rigid body states (position, orientation and linear and angular velocities)\n\n**Returns:**\n\n * DynamicState: the dynamic state of the rigid bodies\n\n---\n**Example:**\n\n```python\n>>> # for the example the rigid bodies are in free fall\n>>> state = prims.get_default_state()\n<omni.isaac.core.utils.types.DynamicsViewState object at 0x7f182bd72590>\n>>> state\n>>> state.positions\n[[   1.5       -0.75    -207.76808]\n [   1.5        0.75    -207.76808]\n [   0.        -0.75    -207.76808]\n [   0.         0.75    -207.76808]\n [  -1.5       -0.75    -207.76808]]\n>>> state.orientations\n[[1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]]\n>>> state.linear_velocities\n[[  0.         0.       -63.765312]\n [  0.         0.       -63.765312]\n [  0.         0.       -63.765312]\n [  0.         0.       -63.765312]\n [  0.         0.       -63.765312]]\n>>> state.angular_velocities\n[[0. 0. 0.]\n [0. 0. 0.]\n [0. 0. 0.]\n [0. 0. 0.]\n [0. 0. 0.]]\n```\n",
"snippet":"current_dynamic_state = rigid_prim_view.get_current_dynamic_state()\n",
"category":"method"
},
{
"title":"get_default_state",
"description":"Get the default state (position, orientation and linear and angular velocities) of prims in the view,\nthat will be used after each reset.\n\n**Returns:**\n\n * DynamicsViewState: returns the default state of the prims that is used after each reset.\n\n---\n**Example:**\n\n```python\n>>> state = prims.get_default_state()\n<omni.isaac.core.utils.types.DynamicsViewState object at 0x7f184e555480>\n>>> state\n>>> state.positions\n[[ 1.4999989e+00 -7.4999851e-01 -1.5118626e-07]\n [ 1.4999989e+00  7.5000149e-01 -2.5988294e-07]\n [-1.0017333e-06 -7.4999845e-01  7.6070329e-08]\n [-9.5906785e-07  7.5000149e-01  1.0593490e-07]\n [-1.5000011e+00 -7.4999851e-01  1.9655154e-07]]\n>>> state.orientations\n[[ 9.9999994e-01 -8.8168377e-07 -4.1946004e-07 -1.5067183e-08]\n [ 9.9999994e-01 -8.8691013e-07 -4.2665880e-07 -2.7188951e-09]\n [ 1.0000000e+00 -9.5171310e-07 -2.2615541e-07  5.5922797e-08]\n [ 1.0000000e+00 -8.9923367e-07 -1.4408238e-07  1.3476099e-08]\n [ 1.0000000e+00 -7.9806580e-07 -1.3064776e-07  5.3154917e-08]]\n>>> state.linear_velocities\n[[0. 0. 0.]\n [0. 0. 0.]\n [0. 0. 0.]\n [0. 0. 0.]\n [0. 0. 0.]]\n>>> state.angular_velocities\n[[0. 0. 0.]\n [0. 0. 0.]\n [0. 0. 0.]\n [0. 0. 0.]\n [0. 0. 0.]]\n```\n",
"snippet":"default_state = rigid_prim_view.get_default_state()\n",
"category":"method"
},
{
"title":"get_default_state",
"description":"Get the default states (positions and orientations) defined with the `set_default_state` method\n\n**Returns:**\n\n * XFormPrimViewState: returns the default state of the prims that is used after each reset.\n\n---\n**Example:**\n\n```python\n>>> state = prims.get_default_state()\n>>> state\n<omni.isaac.core.utils.types.XFormPrimViewState object at 0x7f82f73e3070>\n>>> state.positions\n[[ 1.5  -0.75  0.  ]\n [ 1.5   0.75  0.  ]\n [ 0.   -0.75  0.  ]\n [ 0.    0.75  0.  ]\n [-1.5  -0.75  0.  ]]\n>>> state.orientations\n[[1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]]\n```\n",
"snippet":"default_state = rigid_prim_view.get_default_state()\n",
"category":"method"
},
{
"title":"get_densities",
"description":"Get densities of prims in the view.\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view)\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: densities of prims in the view in kg/m\\^3. shape (M,).\n\n---\n**Example:**\n\n```python\n>>> # get all rigid body densities. Returned shape is (5,) for the example: 5 envs\n>>> prims.get_densities()\n[0. 0. 0. 0. 0.]\n>>>\n>>> # get rigid body densities for the first, middle and last of the 5 envs. Returned shape is (3,)\n>>> prims.get_densities(indices=np.array([0, 2, 4]))\n[0. 0. 0.]\n```\n",
"snippet":"densities = rigid_prim_view.get_densities()\n",
"category":"method"
},
{
"title":"get_inertias",
"description":"Get rigid body inertias of prims in the view.\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: rigid body inertias of prims in the view. Shape is (M, 9).\n\n---\n**Example:**\n\n```python\n>>> # get all rigid body inertias. Returned shape is (5, 9) for the example: 5 envs\n>>> prims.get_inertias()\n[[166.66667  0.  0.  0.  166.66667  0.  0.  0.  166.66667]\n [166.66667  0.  0.  0.  166.66667  0.  0.  0.  166.66667]\n [166.66667  0.  0.  0.  166.66667  0.  0.  0.  166.66667]\n [166.66667  0.  0.  0.  166.66667  0.  0.  0.  166.66667]\n [166.66667  0.  0.  0.  166.66667  0.  0.  0.  166.66667]]\n>>>\n>>> # get rigid body inertias for the first, middle and last of the 5 envs. Returned shape is (3, 9)\n>>> prims.get_inertias(indices=np.array([0, 2, 4]))\n[[166.66667  0.  0.  0.  166.66667  0.  0.  0.  166.66667]\n [166.66667  0.  0.  0.  166.66667  0.  0.  0.  166.66667]\n [166.66667  0.  0.  0.  166.66667  0.  0.  0.  166.66667]]\n```\n",
"snippet":"inertias = rigid_prim_view.get_inertias()\n",
"category":"method"
},
{
"title":"get_inv_inertias",
"description":"Get rigid body inverse inertias of prims in the view.\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: rigid body inverse inertias of prims in the view. Shape is (M, 9).\n\n---\n**Example:**\n\n```python\n>>> # get all rigid body inverse inertias. Returned shape is (5, 9) for the example: 5 envs\n>>> prims.get_inv_inertias()\n[[0.006 0.    0.    0.    0.006 0.    0.    0.    0.006]\n [0.006 0.    0.    0.    0.006 0.    0.    0.    0.006]\n [0.006 0.    0.    0.    0.006 0.    0.    0.    0.006]\n [0.006 0.    0.    0.    0.006 0.    0.    0.    0.006]\n [0.006 0.    0.    0.    0.006 0.    0.    0.    0.006]]\n>>>\n>>> # get rigid body inverse inertias for the first, middle and last of the 5 envs. Returned shape is (3, 9)\n>>> prims.get_inv_inertias(indices=np.array([0, 2, 4]))\n[[0.006 0.    0.    0.    0.006 0.    0.    0.    0.006]\n [0.006 0.    0.    0.    0.006 0.    0.    0.    0.006]\n [0.006 0.    0.    0.    0.006 0.    0.    0.    0.006]]\n```\n",
"snippet":"inv_inertias = rigid_prim_view.get_inv_inertias()\n",
"category":"method"
},
{
"title":"get_inv_masses",
"description":"Get rigid body inverse masses of prims in the view.\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: rigid body inverse masses of prims in the view. Shape is (M,).\n\n---\n**Example:**\n\n```python\n>>> # get all rigid body inverse masses. Returned shape is (5, 1) for the example: 5 envs\n>>> prims.get_inv_masses()\n[[0.001]\n [0.001]\n [0.001]\n [0.001]\n [0.001]]\n>>>\n>>> # get rigid body inverse masses for the first, middle and last of the 5 envs. Returned shape is (3, 1)\n>>> prims.get_inv_masses(indices=np.array([0, 2, 4]))\n[[0.001]\n [0.001]\n [0.001]]\n```\n",
"snippet":"inv_masses = rigid_prim_view.get_inv_masses()\n",
"category":"method"
},
{
"title":"get_linear_velocities",
"description":"Get the linear velocities of prims in the view.\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view)\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: linear velocities of the prims in the view. shape is (M, 3).\n\n---\n**Example:**\n\n```python\n>>> # get all rigid prim linear velocities. Returned shape is (5, 3) for the example: 5 envs, linear (3)\n>>> prims.get_linear_velocities()\n[[0. 0. 0.]\n [0. 0. 0.]\n [0. 0. 0.]\n [0. 0. 0.]\n [0. 0. 0.]]\n>>>\n>>> # get only the rigid prim linear velocities for the first, middle and last of the 5 envs.\n>>> # Returned shape is (3, 3) for the example: 3 envs selected, linear (3)\n>>> prims.get_linear_velocities(indices=np.array([0, 2, 4]))\n[[0. 0. 0.]\n [0. 0. 0.]\n [0. 0. 0.]]\n```\n",
"snippet":"linear_velocities = rigid_prim_view.get_linear_velocities()\n",
"category":"method"
},
{
"title":"get_local_poses",
"description":"Get prim poses in the view with respect to the local frame (the prim's parent frame).\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view)\n\n**Returns:**\n\n * Union\\[Tuple\\[np.ndarray, np.ndarray\\], Tuple\\[torch.Tensor, torch.Tensor\\], Tuple\\[wp.indexedarray, wp.indexedarray\\]\\]:\n    first index is positions in the local frame of the prims. shape is (M, 3).\n    second index is quaternion orientations in the local frame of the prims.\n    quaternion is scalar-first (w, x, y, z). shape is (M, 4).\n\n---\n**Example:**\n\n```python\n>>> # get all rigid prim poses with respect to the local frame.\n>>> # Returned shape is position (5, 3) and orientation (5, 4) for the example: 5 envs\n>>> positions, orientations = prims.get_local_poses()\n>>> positions\n[[-1.0728836e-06  1.4901161e-06 -1.5118626e-07]\n [-1.0728836e-06  1.4901161e-06 -2.5988294e-07]\n [-1.0017333e-06  1.5497208e-06  7.6070329e-08]\n [-9.5906785e-07  1.4901161e-06  1.0593490e-07]\n [-1.0728836e-06  1.4901161e-06  1.9655154e-07]]\n>>> orientations\n[[ 1.0000000e+00 -8.8174920e-07 -4.1949116e-07 -1.5068302e-08]\n [ 1.0000000e+00 -8.8696777e-07 -4.2668654e-07 -2.7190719e-09]\n [ 1.0000000e+00 -9.5164734e-07 -2.2613979e-07  5.5918935e-08]\n [ 1.0000000e+00 -8.9923157e-07 -1.4408204e-07  1.3476067e-08]\n [ 1.0000000e+00 -7.9806864e-07 -1.3064822e-07  5.3155105e-08]]\n>>>\n>>> # get only the rigid prim poses with respect to the local frame for the first, middle and last of the 5 envs.\n>>> # Returned shape is position (3, 3) and orientation (3, 4) for the example: 3 envs selected\n>>> positions, orientations = prims.get_local_poses(indices=np.array([0, 2, 4]))\n>>> positions\n[[-1.0728836e-06  1.4901161e-06 -1.5118626e-07]\n [-1.0017333e-06  1.5497208e-06  7.6070329e-08]\n [-1.0728836e-06  1.4901161e-06  1.9655154e-07]]\n>>> orientations\n[[ 1.0000000e+00 -8.8174920e-07 -4.1949116e-07 -1.5068302e-08]\n [ 1.0000000e+00 -9.5164734e-07 -2.2613979e-07  5.5918935e-08]\n [ 1.0000000e+00 -7.9806864e-07 -1.3064822e-07  5.3155105e-08]]\n```\n",
"snippet":"local_poses = rigid_prim_view.get_local_poses()\n",
"category":"method"
},
{
"title":"get_local_poses",
"description":"Get prim poses in the view with respect to the local frame (the prim's parent frame)\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Returns:**\n\n * Union\\[Tuple\\[np.ndarray, np.ndarray\\], Tuple\\[torch.Tensor, torch.Tensor\\], Tuple\\[wp.indexedarray, wp.indexedarray\\]\\]: first index is translations in the local frame of the prims. shape is (M, 3). second index is quaternion orientations in the local frame of the prims. quaternion is scalar-first (w, x, y, z). shape is (M, 4).\n\n---\n**Example:**\n\n```python\n>>> # get all prims poses with respect to the local frame.\n>>> # Returned shape is position (5, 3) and orientation (5, 4) for the example: 5 envs\n>>> positions, orientations = prims.get_local_poses()\n>>> positions\n[[ 1.5  -0.75  0.  ]\n [ 1.5   0.75  0.  ]\n [ 0.   -0.75  0.  ]\n [ 0.    0.75  0.  ]\n [-1.5  -0.75  0.  ]]\n>>> orientations\n[[1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]]\n>>>\n>>> # get only the prims poses with respect to the local frame for the first, middle and last of the 5 envs.\n>>> # Returned shape is position (3, 3) and orientation (3, 4) for the example: 3 envs selected\n>>> positions, orientations = prims.get_local_poses(indices=np.array([0, 2, 4]))\n>>> positions\n[[ 1.5  -0.75  0.  ]\n [ 0.   -0.75  0.  ]\n [-1.5  -0.75  0.  ]]\n>>> orientations\n[[1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]]\n```\n",
"snippet":"local_poses = rigid_prim_view.get_local_poses()\n",
"category":"method"
},
{
"title":"get_local_scales",
"description":"Get prim scales in the view with respect to the local frame (the parent's frame).\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: scales applied to the prim's dimensions in the local frame. shape is (M, 3).\n\n---\n**Example:**\n\n```python\n>>> # get all prims scales with respect to the local frame.\n>>> # Returned shape is (5, 3) for the example: 5 envs\n>>> prims.get_local_scales()\n[[1. 1. 1.]\n [1. 1. 1.]\n [1. 1. 1.]\n [1. 1. 1.]\n [1. 1. 1.]]\n>>>\n>>> # get only the prims scales with respect to the local frame for the first, middle and last of the 5 envs.\n>>> # Returned shape is (3, 3) for the example: 3 envs selected\n>>> prims.get_local_scales(indices=np.array([0, 2, 4]))\n[[1. 1. 1.]\n [1. 1. 1.]\n [1. 1. 1.]]\n```\n",
"snippet":"local_scales = rigid_prim_view.get_local_scales()\n",
"category":"method"
},
{
"title":"get_masses",
"description":"Get rigid body masses of prims in the view.\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: masses of in kg of prims in the view. shape is (M,).\n\n---\n**Example:**\n\n```python\n>>> # get all rigid body masses. Returned shape is (5,) for the example: 5 envs\n>>> prims.get_masses()\n[999.99994 999.99994 999.99994 999.99994 999.99994]\n>>>\n>>> # get rigid body masses for the first, middle and last of the 5 envs. Returned shape is (3,)\n>>> prims.get_masses(indices=np.array([0, 2, 4]))\n[999.99994 999.99994 999.99994]\n```\n",
"snippet":"masses = rigid_prim_view.get_masses()\n",
"category":"method"
},
{
"title":"get_net_contact_forces",
"description":"Return the net contact forces on prims\n\n*Note:*\nThis method requires that the contact forces of the prims in the view be tracked by defining\nthe `track_contact_forces` argument to True (default to False) during view creation\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n * `dt` (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: Net contact forces of the prims with shape (M,3).\n\n---\n**Example:**\n\n```python\n>>> # get the net contact force on all rigid bodies. Returned shape is (5, 3).\n>>> # For the example the view was instantiated with the extra parameter: track_contact_forces=True\n>>> prims.get_net_contact_forces()\n[[2.1967362e-05 0.0000000e+00 1.6349771e+02]\n [2.1967124e-05 0.0000000e+00 1.6349591e+02]\n [2.1967891e-05 0.0000000e+00 1.6350165e+02]\n [2.1967257e-05 0.0000000e+00 1.6349693e+02]\n [2.1966895e-05 0.0000000e+00 1.6349425e+02]]\n>>>\n>>> # get the net contact force on the rigid bodies for the first, middle and last of the 5 envs\n>>> prims.get_net_contact_forces(indices=np.array([0, 2, 4]))\n[[2.1967362e-05 0.0000000e+00 1.6349771e+02]\n [2.1967891e-05 0.0000000e+00 1.6350165e+02]\n [2.1966895e-05 0.0000000e+00 1.6349425e+02]]\n```\n",
"snippet":"net_contact_forces = rigid_prim_view.get_net_contact_forces()\n",
"category":"method"
},
{
"title":"get_sleep_thresholds",
"description":"Get sleep thresholds of prims in the view.\n\nSearch for *Rigid Body Dynamics* \\> *Sleeping* in for more details\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view)\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: Mass-normalized kinetic energy threshold below which\n    an actor may go to sleep. Range: \\[0, inf). Defaults: 0.00005 \\* tolerancesSpeed\\* tolerancesSpeed\n    Units: distance\\^2 / second\\^2. shape (M,).\n\n---\n**Example:**\n\n```python\n>>> # get all sleep threshold. Returned shape is (5,) for the example: 5 envs\n>>> prims.get_sleep_thresholds()\n[5.e-05 5.e-05 5.e-05 5.e-05 5.e-05]\n>>>\n>>> # get sleep threshold for the first, middle and last of the 5 envs. Returned shape is (3,)\n>>> prims.get_sleep_thresholds(indices=np.array([0, 2, 4]))\n[5.e-05 5.e-05 5.e-05]\n```\n",
"snippet":"sleep_thresholds = rigid_prim_view.get_sleep_thresholds()\n",
"category":"method"
},
{
"title":"get_velocities",
"description":"Get the linear and angular velocities of prims in the view.\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view)\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: linear and angular velocities of the prims in the view concatenated. shape is (M, 6).\n\n---\n**Example:**\n\n```python\n>>> # get all rigid prim velocities. Returned shape is (5, 6) for the example: 5 envs, linear (3) and angular (3)\n>>> prims.get_velocities()\n[[0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0.]]\n>>>\n>>> # get only the rigid prim velocities for the first, middle and last of the 5 envs.\n>>> # Returned shape is (3, 6) for the example: 3 envs selected, linear (3) and angular (3)\n>>> prims.get_velocities(indices=np.array([0, 2, 4]))\n[[0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0.]]\n```\n",
"snippet":"velocities = rigid_prim_view.get_velocities()\n",
"category":"method"
},
{
"title":"get_visibilities",
"description":"Returns the current visibilities of the prims in stage.\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: Shape (M,) with type bool, where each item holds True if the prim is visible in stage. False otherwise.\n\n---\n**Example:**\n\n```python\n>>> # get all visibilities. Returned shape is (5,) for the example: 5 envs\n>>> prims.get_visibilities()\n[ True  True  True  True  True]\n>>>\n>>> # get the visibilities for the first, middle and last of the 5 envs. Returned shape is (3,)\n>>> prims.get_visibilities(indices=np.array([0, 2, 4]))\n[ True  True  True]\n```\n",
"snippet":"visibilities = rigid_prim_view.get_visibilities()\n",
"category":"method"
},
{
"title":"get_world_poses",
"description":"Get the poses of the prims in the view with respect to the world's frame.\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[Tuple\\[np.ndarray, np.ndarray\\], Tuple\\[torch.Tensor, torch.Tensor\\], Tuple\\[wp.indexedarray, wp.indexedarray\\]\\]:\n    first index is positions in the world frame of the prims. shape is (M, 3).\n    second index is quaternion orientations in the world frame of the prims.\n    quaternion is scalar-first (w, x, y, z). shape is (M, 4).\n\n---\n**Example:**\n\n```python\n>>> # get all rigid prim poses with respect to the world's frame.\n>>> # Returned shape is position (5, 3) and orientation (5, 4) for the example: 5 envs\n>>> positions, orientations = prims.get_world_poses()\n>>> positions\n[[ 1.4999989e+00 -7.4999851e-01 -1.5118626e-07]\n [ 1.4999989e+00  7.5000149e-01 -2.5988294e-07]\n [-1.0017333e-06 -7.4999845e-01  7.6070329e-08]\n [-9.5906785e-07  7.5000149e-01  1.0593490e-07]\n [-1.5000011e+00 -7.4999851e-01  1.9655154e-07]]\n>>> orientations\n[[ 9.9999994e-01 -8.8168377e-07 -4.1946004e-07 -1.5067183e-08]\n [ 9.9999994e-01 -8.8691013e-07 -4.2665880e-07 -2.7188951e-09]\n [ 1.0000000e+00 -9.5171310e-07 -2.2615541e-07  5.5922797e-08]\n [ 1.0000000e+00 -8.9923367e-07 -1.4408238e-07  1.3476099e-08]\n [ 1.0000000e+00 -7.9806580e-07 -1.3064776e-07  5.3154917e-08]]\n>>>\n>>> # get only the rigid prim poses with respect to the world's frame for the first, middle and last of the 5 envs.\n>>> # Returned shape is position (3, 3) and orientation (3, 4) for the example: 3 envs selected\n>>> positions, orientations = prims.get_world_poses(indices=np.array([0, 2, 4]))\n>>> positions\n[[ 1.4999989e+00 -7.4999851e-01 -1.5118626e-07]\n [-1.0017333e-06 -7.4999845e-01  7.6070329e-08]\n [-1.5000011e+00 -7.4999851e-01  1.9655154e-07]]\n>>> orientations\n[[ 9.9999994e-01 -8.8168377e-07 -4.1946004e-07 -1.5067183e-08]\n [ 1.0000000e+00 -9.5171310e-07 -2.2615541e-07  5.5922797e-08]\n [ 1.0000000e+00 -7.9806580e-07 -1.3064776e-07  5.3154917e-08]]\n```\n",
"snippet":"world_poses = rigid_prim_view.get_world_poses()\n",
"category":"method"
},
{
"title":"get_world_poses",
"description":"Get the poses of the prims in the view with respect to the world's frame\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Returns:**\n\n * Union\\[Tuple\\[np.ndarray, np.ndarray\\], Tuple\\[torch.Tensor, torch.Tensor\\], Tuple\\[wp.indexedarray, wp.indexedarray\\]\\]: first index is positions in the world frame of the prims. shape is (M, 3). second index is quaternion orientations in the world frame of the prims. quaternion is scalar-first (w, x, y, z). shape is (M, 4).\n\n---\n**Example:**\n\n```python\n>>> # get all prims poses with respect to the world's frame.\n>>> # Returned shape is position (5, 3) and orientation (5, 4) for the example: 5 envs\n>>> positions, orientations = prims.get_world_poses()\n>>> positions\n[[ 1.5  -0.75  0.  ]\n [ 1.5   0.75  0.  ]\n [ 0.   -0.75  0.  ]\n [ 0.    0.75  0.  ]\n [-1.5  -0.75  0.  ]]\n>>> orientations\n[[1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]]\n>>>\n>>> # get only the prims poses with respect to the world's frame for the first, middle and last of the 5 envs.\n>>> # Returned shape is position (3, 3) and orientation (3, 4) for the example: 3 envs selected\n>>> positions, orientations = prims.get_world_poses(indices=np.array([0, 2, 4]))\n>>> positions\n[[ 1.5  -0.75  0.  ]\n [ 0.   -0.75  0.  ]\n [-1.5  -0.75  0.  ]]\n>>> orientations\n[[1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]]\n```\n",
"snippet":"world_poses = rigid_prim_view.get_world_poses()\n",
"category":"method"
},
{
"title":"get_world_scales",
"description":"Get prim scales in the view with respect to the world's frame\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: scales applied to the prim's dimensions in the world frame. shape is (M, 3).\n\n---\n**Example:**\n\n```python\n>>> # get all prims scales with respect to the world's frame.\n>>> # Returned shape is (5, 3) for the example: 5 envs\n>>> prims.get_world_scales()\n[[1. 1. 1.]\n [1. 1. 1.]\n [1. 1. 1.]\n [1. 1. 1.]\n [1. 1. 1.]]\n>>>\n>>> # get only the prims scales with respect to the world's frame for the first, middle and last of the 5 envs.\n>>> # Returned shape is (3, 3) for the example: 3 envs selected\n>>> prims.get_world_scales(indices=np.array([0, 2, 4]))\n[[1. 1. 1.]\n [1. 1. 1.]\n [1. 1. 1.]]\n```\n",
"snippet":"world_scales = rigid_prim_view.get_world_scales()\n",
"category":"method"
},
{
"title":"initialize",
"description":"Create a physics simulation view if not passed and set other properties using the PhysX tensor API\n\n*Note:*\nIf the rigid prim view has been added to the world scene (e.g., `world.scene.add(prims)`),\nit will be automatically initialized when the world is reset (e.g., `world.reset()`).\n\n*Warning:*\nThis method needs to be called after each hard reset (e.g., Stop + Play on the timeline)\nbefore interacting with any other class method.\n\n**Args:**\n\n * `physics_sim_view` (omni.physics.tensors.SimulationView, optional): current physics simulation view. Defaults to None.\n\n---\n**Example:**\n\n```python\n>>> prims.initialize()\n```\n",
"snippet":"rigid_prim_view.initialize()\n",
"category":"method"
},
{
"title":"initialize",
"description":"Create a physics simulation view if not passed and set other properties using the PhysX tensor API\n\n*Note:*\nFor this particular class, calling this method will do nothing\n\n**Args:**\n\n * `physics_sim_view` (omni.physics.tensors.SimulationView, optional): current physics simulation view. Defaults to None.\n\n---\n**Example:**\n\n```python\n>>> prims.initialize()\n```\n",
"snippet":"rigid_prim_view.initialize()\n",
"category":"method"
},
{
"title":"is_physics_handle_valid",
"description":"Check if rigid prim view's physics handler is initialized\n\n*Warning:*\nIf the physics handler is not valid many of the methods that requires PhysX will return None.\n\n**Returns:**\n\n * bool: True if the physics handle of the view is valid (i.e physics is initialized for the view). Otherwise False.\n\n---\n**Example:**\n\n```python\n>>> prims.is_physics_handle_valid()\nTrue\n```\n",
"snippet":"value = rigid_prim_view.is_physics_handle_valid()\n",
"category":"method"
},
{
"title":"is_valid",
"description":"Check that all prims have a valid USD Prim\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Returns:**\n\n * bool: True if all prim paths specified in the view correspond to a valid prim in stage. False otherwise.\n\n---\n**Example:**\n\n```python\n>>> prims.is_valid()\nTrue\n```\n",
"snippet":"value = rigid_prim_view.is_valid()\n",
"category":"method"
},
{
"title":"is_visual_material_applied",
"description":"Check if there is a visual material applied\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Returns:**\n\n * List\\[bool\\]: True if there is a visual material applied is applied to the corresponding prim in the view. False otherwise.\n\n---\n**Example:**\n\n```python\n>>> # given a visual material that is applied only to the first and the last environment\n>>> prims.is_visual_material_applied()\n[True, False, False, False, True]\n>>>\n>>> # check for the first, middle and last of the 5 envs\n>>> prims.is_visual_material_applied(indices=np.array([0, 2, 4]))\n[True, False, True]\n```\n",
"snippet":"value = rigid_prim_view.is_visual_material_applied()\n",
"category":"method"
},
{
"title":"num_shapes",
"description":"**Returns:**\n\n * int: number of rigid shapes for the prims in the view.\n\n---\n**Example:**\n\n```python\n>>> prims.num_shapes\n1\n```\n",
"snippet":"num_shapes = rigid_prim_view.num_shapes\n",
"category":"property"
},
{
"title":"post_reset",
"description":"Reset the rigid prims to their default states (positions, orientations and linear and angular velocities)\n\n---\n**Example:**\n\n```python\n>>> prims.post_reset()\n```\n",
"snippet":"rigid_prim_view.post_reset()\n",
"category":"method"
},
{
"title":"post_reset",
"description":"Reset the prims to its default state (positions and orientations)\n\n---\n**Example:**\n\n```python\n>>> prims.post_reset()\n```\n",
"snippet":"rigid_prim_view.post_reset()\n",
"category":"method"
},
{
"title":"set_angular_velocities",
"description":"Set the angular velocities of the prims in the view\n\nThe method does this through the physx API only. It has to be called after initialization.\nNote: This method is not supported for the gpu pipeline. `set_velocities` method should be used instead.\n\n*Warning:*\nThis method will immediately set the rigid prim state\n\n**Args:**\n\n * `velocities` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\]): angular velocities to set the rigid prims to. shape is (M, 3).\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n*Hint:*\nThis method belongs to the methods used to set the rigid prim kinematic state:\n\n> `set_velocities` (`set_linear_velocities`, `set_angular_velocities`)\n\n---\n**Example:**\n\n```python\n>>> # set each rigid prim linear velocity to (5.0, 5.0, 5.0)\n>>> velocities = np.full((num_envs, 3), fill_value=5.0)\n>>> prims.set_angular_velocities(velocities)\n>>>\n>>> # set only the rigid prim linear velocities for the first, middle and last of the 5 envs\n>>> velocities = np.full((3, 3), fill_value=5.0)\n>>> prims.set_angular_velocities(velocities, indices=np.array([0, 2, 4]))\n```\n",
"snippet":"rigid_prim_view.set_angular_velocities(velocities=velocities)\n",
"category":"method"
},
{
"title":"set_coms",
"description":"Set body center of mass (COM) positions and orientations for bodies in the view.\n\n**Args:**\n\n * `positions` (Union\\[np.ndarray, torch.Tensor, wp.array\\]): body center of mass positions for bodies in the view. shape (M, 1, 3).\n * `orientations` (Union\\[np.ndarray, torch.Tensor, wp.array\\]): body center of mass orientations for bodies in the view. shape (M, 1, 4).\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n---\n**Example:**\n\n```python\n>>> # set the center of mass for all the rigid bodies to the specified values.\n>>> # Since there are 5 envs, the inertias are repeated 5 times\n>>> positions = np.tile(np.array([0.01, 0.02, 0.03]), (num_envs, 1, 1))\n>>> orientations = np.tile(np.array([1.0, 0.0, 0.0, 0.0]), (num_envs, 1, 1))\n>>> prims.set_coms(positions, orientations)\n>>>\n>>> # set the rigid bodies center of mass for the first, middle and last of the 5 envs\n>>> positions = np.tile(np.array([0.01, 0.02, 0.03]), (3, 1, 1))\n>>> orientations = np.tile(np.array([1.0, 0.0, 0.0, 0.0]), (3, 1, 1))\n>>> prims.set_coms(positions, orientations, indices=np.array([0, 2, 4]))\n```\n",
"snippet":"rigid_prim_view.set_coms()\n",
"category":"method"
},
{
"title":"set_default_state",
"description":"Set the default state (position, orientation and linear and angular velocities) of prims in the view,\nthat will be used after each reset.\n\n*Note:*\nThe default states will be set during post-reset (e.g., calling `.post_reset()` or `world.reset()` methods)\n\n**Args:**\n\n * `positions` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): default positions in the world frame of the prim. shape is (M, 3).\n * `orientations` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): default quaternion orientations in the world frame of the prims. quaternion is scalar-first (w, x, y, z). shape is (M, 4).\n * `linear_velocities` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): default linear velocities of each prim in the view (to be applied in the first frame and on resets). Shape is (M, 3). Defaults to None.\n * `angular_velocities` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): default angular velocities of each prim in the view (to be applied in the first frame and on resets). Shape is (M, 3). Defaults to None.\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n---\n**Example:**\n\n```python\n>>> # configure default states for all prims\n>>> positions = np.zeros((num_envs, 3))\n>>> positions[:, 0] = np.arange(num_envs)\n>>> orientations = np.tile(np.array([1.0, 0.0, 0.0, 0.0]), (num_envs, 1))\n>>> linear_velocities = np.zeros((num_envs, 3))\n>>> angular_velocities = np.zeros((num_envs, 3))\n>>> prims.set_default_state(\n...     positions=positions,\n...     orientations=orientations,\n...     linear_velocities=linear_velocities,\n...     angular_velocities=angular_velocities\n... )\n>>>\n>>> # set default states during post-reset\n>>> prims.post_reset()\n```\n",
"snippet":"rigid_prim_view.set_default_state()\n",
"category":"method"
},
{
"title":"set_default_state",
"description":"Set the default state of the prims (positions and orientations), that will be used after each reset.\n\n*Note:*\nThe default states will be set during post-reset (e.g., calling `.post_reset()` or `world.reset()` methods)\n\n**Args:**\n\n * `positions` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): positions in the world frame of the prim. shape is (M, 3). Defaults to None, which means left unchanged.\n * `orientations` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): quaternion orientations in the world frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (M, 4). Defaults to None, which means left unchanged.\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n---\n**Example:**\n\n```python\n>>> # configure default states for all prims\n>>> positions = np.zeros((num_envs, 3))\n>>> positions[:, 0] = np.arange(num_envs)\n>>> orientations = np.tile(np.array([1.0, 0.0, 0.0, 0.0]), (num_envs, 1))\n>>> prims.set_default_state(positions=positions, orientations=orientations)\n>>>\n>>> # set default states during post-reset\n>>> prims.post_reset()\n```\n",
"snippet":"rigid_prim_view.set_default_state()\n",
"category":"method"
},
{
"title":"set_densities",
"description":"Set densities of prims in the view.\n\n**Args:**\n\n * `densities` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\]): density in kg/m\\^3 specified for each prim in the view. shape is (M,). Defaults to None.\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n---\n**Example:**\n\n```python\n>>> # set all rigid body densities to the specified values\n>>> prims.set_densities(np.full(num_envs, 0.9))\n>>>\n>>> # set rigid body densities for the first, middle and last of the 5 envs\n>>> prims.set_densities(np.full(3, 0.9), indices=np.array([0, 2, 4]))\n```\n",
"snippet":"rigid_prim_view.set_densities(densities=densities)\n",
"category":"method"
},
{
"title":"set_inertias",
"description":"Set rigid body inertias for prims in the view.\n\n**Args:**\n\n * `values` (Union\\[np.ndarray, torch.Tensor, wp.array\\]): body inertias for prims in the view. shape (M, 1, 9).\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n---\n**Example:**\n\n```python\n>>> # set the rigid body inertias for all the rigid bodies to the specified values.\n>>> # Since there are 5 envs, the inertias are repeated 5 times\n>>> inertias = np.tile(np.array([0.1, 0.0, 0.0, 0.0, 0.1, 0.0, 0.0, 0.0, 0.1]), (num_envs, 1))\n>>> prims.set_inertias(inertias)\n>>>\n>>> # set the rigid body inertias for the first, middle and last of the 5 envs\n>>> inertias = np.tile(np.array([0.1, 0.0, 0.0, 0.0, 0.1, 0.0, 0.0, 0.0, 0.1]), (3, 1))\n>>> prims.set_inertias(inertias, indices=np.array([0, 2, 4]))\n```\n",
"snippet":"rigid_prim_view.set_inertias(values=values)\n",
"category":"method"
},
{
"title":"set_linear_velocities",
"description":"Set the linear velocities of the prims in the view\n\nThe method does this through the PhysX API only. It has to be called after initialization.\nNote: This method is not supported for the gpu pipeline. `set_velocities` method should be used instead.\n\n*Warning:*\nThis method will immediately set the rigid prim state\n\n**Args:**\n\n * `velocities` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\]): linear velocities to set the rigid prims to. shape is (M, 3).\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n*Hint:*\nThis method belongs to the methods used to set the rigid prim kinematic state:\n\n> `set_velocities` (`set_linear_velocities`, `set_angular_velocities`)\n\n---\n**Example:**\n\n```python\n>>> # set each rigid prim linear velocity to (1.0, 1.0, 1.0)\n>>> velocities = np.ones((num_envs, 3))\n>>> prims.set_linear_velocities(velocities)\n>>>\n>>> # set only the rigid prim linear velocities for the first, middle and last of the 5 envs\n>>> velocities = np.ones((3, 3))\n>>> prims.set_linear_velocities(velocities, indices=np.array([0, 2, 4]))\n```\n",
"snippet":"rigid_prim_view.set_linear_velocities(velocities=velocities)\n",
"category":"method"
},
{
"title":"set_local_poses",
"description":"Set prim poses in the view with respect to the local frame (the prim's parent frame).\n\n**Args:**\n\n * `translations` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): translations in the local frame of the prims (with respect to its parent prim). shape is (M, 3). Defaults to None, which means left unchanged.\n * `orientations` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): quaternion orientations in the local frame of the prims. quaternion is scalar-first (w, x, y, z). shape is (M, 4). Defaults to None, which means left unchanged.\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n---\n**Example:**\n\n```python\n>>> # reposition all rigid prims\n>>> positions = np.zeros((num_envs, 3))\n>>> positions[:,0] = np.arange(num_envs)\n>>> orientations = np.tile(np.array([1.0, 0.0, 0.0, 0.0]), (num_envs, 1))\n>>> prims.set_local_poses(positions, orientations)\n>>>\n>>> # reposition only the rigid prims for the first, middle and last of the 5 envs\n>>> positions = np.zeros((3, 3))\n>>> positions[:,1] = np.arange(3)\n>>> orientations = np.tile(np.array([1.0, 0.0, 0.0, 0.0]), (3, 1))\n>>> prims.set_local_poses(positions, orientations, indices=np.array([0, 2, 4]))\n```\n",
"snippet":"rigid_prim_view.set_local_poses()\n",
"category":"method"
},
{
"title":"set_local_poses",
"description":"Set prim poses in the view with respect to the local frame (the prim's parent frame)\n\n*Warning:*\nThis method will change (teleport) the prim poses immediately to the indicated value\n\n**Args:**\n\n * `translations` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): translations in the local frame of the prims (with respect to its parent prim). shape is (M, 3). Defaults to None, which means left unchanged.\n * `orientations` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): quaternion orientations in the local frame of the prims. quaternion is scalar-first (w, x, y, z). shape is (M, 4). Defaults to None, which means left unchanged.\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n*Hint:*\nThis method belongs to the methods used to set the prim state\n\n---\n**Example:**\n\n```python\n>>> # reposition all prims\n>>> positions = np.zeros((num_envs, 3))\n>>> positions[:,0] = np.arange(num_envs)\n>>> orientations = np.tile(np.array([1.0, 0.0, 0.0, 0.0]), (num_envs, 1))\n>>> prims.set_local_poses(positions, orientations)\n>>>\n>>> # reposition only the prims for the first, middle and last of the 5 envs\n>>> positions = np.zeros((3, 3))\n>>> positions[:,1] = np.arange(3)\n>>> orientations = np.tile(np.array([1.0, 0.0, 0.0, 0.0]), (3, 1))\n>>> prims.set_local_poses(positions, orientations, indices=np.array([0, 2, 4]))\n```\n",
"snippet":"rigid_prim_view.set_local_poses()\n",
"category":"method"
},
{
"title":"set_local_scales",
"description":"Set prim scales in the view with respect to the local frame (the prim's parent frame)\n\n**Args:**\n\n * `scales` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\]): scales to be applied to the prim's dimensions in the view. shape is (M, 3).\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n---\n**Example:**\n\n```python\n>>> # set the scale for all prims. Since there are 5 envs, the scale is repeated 5 times\n>>> scales = np.tile(np.array([1.0, 0.75, 0.5]), (num_envs, 1))\n>>> prims.set_local_scales(scales)\n>>>\n>>> # set the scale for the first, middle and last of the 5 envs\n>>> scales = np.tile(np.array([1.0, 0.75, 0.5]), (3, 1))\n>>> prims.set_local_scales(scales, indices=np.array([0, 2, 4]))\n```\n",
"snippet":"rigid_prim_view.set_local_scales(scales=scales)\n",
"category":"method"
},
{
"title":"set_masses",
"description":"Set body masses for prims in the view.\n\n**Args:**\n\n * `masses` (Union\\[np.ndarray, torch.Tensor, wp.array\\]): body masses for prims in kg. shape (M,).\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n---\n**Example:**\n\n```python\n>>> # set the rigid body masses for all the rigid bodies to the indicated values.\n>>> prims.set_masses(np.full(num_envs, 10.0))\n>>>\n>>> # set the rigid body masses for the first, middle and last of the 5 envs\n>>> prims.set_masses(np.full(3, 10.0), indices=np.array([0, 2, 4]))\n```\n",
"snippet":"rigid_prim_view.set_masses(masses=masses)\n",
"category":"method"
},
{
"title":"set_sleep_thresholds",
"description":"Set sleep thresholds of prims in the view.\n\nSearch for *Rigid Body Dynamics* \\> *Sleeping* in for more details\n\nArgs:\n\n * `thresholds` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\]): Mass-normalized kinetic energy threshold below which an actor may go to sleep. Range: \\[0, inf) Defaults: 0.00005 \\* tolerancesSpeed\\* tolerancesSpeed Units: distance\\^2 / second\\^2. shape (M,).\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n---\n**Example:**\n\n```python\n>>> # set all rigid body densities to the specified values\n>>> prims.set_sleep_thresholds(np.full(num_envs, 1e-5))\n>>>\n>>> # set rigid body densities for the first, middle and last of the 5 envs\n>>> prims.set_sleep_thresholds(np.full(3, 1e-5), indices=np.array([0, 2, 4]))\n```\n",
"snippet":"rigid_prim_view.set_sleep_thresholds(thresholds=thresholds)\n",
"category":"method"
},
{
"title":"set_velocities",
"description":"Set the linear and angular velocities of the prims in the view at once.\n\nThe method does this through the PhysX API only. It has to be called after initialization\n\n*Warning:*\nThis method will immediately set the rigid prim state\n\n**Args:**\n\n * `velocities` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\]): linear and angular velocities respectively to set the rigid prims to. shape is (M, 6).\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n*Hint:*\nThis method belongs to the methods used to set the rigid prim kinematic state:\n\n> `set_velocities` (`set_linear_velocities`, `set_angular_velocities`)\n\n---\n**Example:**\n\n```python\n>>> # set each rigid prim linear velocity to (1., 1., 1.) and angular velocity to (5., 5., 5.)\n>>> velocities = np.ones((num_envs, 6))\n>>> velocities[:,3:] = 5.0\n>>> prims.set_velocities(velocities)\n>>>\n>>> # set only the rigid prim velocities for the first, middle and last of the 5 envs\n>>> velocities = np.ones((3, 6))\n>>> velocities[:,3:] = 5.0\n>>> prims.set_velocities(velocities, indices=np.array([0, 2, 4]))\n```\n",
"snippet":"rigid_prim_view.set_velocities(velocities=velocities)\n",
"category":"method"
},
{
"title":"set_visibilities",
"description":"Set the visibilities of the prims in stage\n\n**Args:**\n\n * `visibilities` (Union\\[np.ndarray, torch.Tensor, wp.array\\]): flag to set the visibilities of the usd prims in stage. Shape (M,). Where M \\<= size of the encapsulated prims in the view.\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Defaults to None (i.e: all prims in the view).\n\n---\n**Example:**\n\n```python\n>>> # make all prims not visible in the stage\n>>> prims.set_visibilities(visibilities=[False] * num_envs)\n```\n",
"snippet":"rigid_prim_view.set_visibilities(visibilities=visibilities)\n",
"category":"method"
},
{
"title":"set_world_poses",
"description":"Set poses of prims in the view with respect to the world's frame.\n\n*Warning:*\nThis method will change (teleport) the prim poses immediately to the specified value\n\n**Args:**\n\n * `positions` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): positions in the world frame of the prim. shape is (M, 3). Defaults to None, which means left unchanged.\n * `orientations` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): quaternion orientations in the world frame of the prims. quaternion is scalar-first (w, x, y, z). shape is (M, 4). Defaults to None, which means left unchanged.\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n*Hint:*\nThis method belongs to the methods used to set the prim state\n\n---\n**Example:**\n\n```python\n>>> # reposition all rigid prims in row (x-axis)\n>>> positions = np.zeros((num_envs, 3))\n>>> positions[:,0] = np.arange(num_envs)\n>>> orientations = np.tile(np.array([1.0, 0.0, 0.0, 0.0]), (num_envs, 1))\n>>> prims.set_world_poses(positions, orientations)\n>>>\n>>> # reposition only the rigid prims for the first, middle and last of the 5 envs in column (y-axis)\n>>> positions = np.zeros((3, 3))\n>>> positions[:,1] = np.arange(3)\n>>> orientations = np.tile(np.array([1.0, 0.0, 0.0, 0.0]), (3, 1))\n>>> prims.set_world_poses(positions, orientations, indices=np.array([0, 2, 4]))\n```\n",
"snippet":"rigid_prim_view.set_world_poses()\n",
"category":"method"
},
{
"title":"set_world_poses",
"description":"Set prim poses in the view with respect to the world's frame\n\n*Warning:*\nThis method will change (teleport) the prim poses immediately to the indicated value\n\n**Args:**\n\n * `positions` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): positions in the world frame of the prims. shape is (M, 3). Defaults to None, which means left unchanged.\n * `orientations` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): quaternion orientations in the world frame of the prims. quaternion is scalar-first (w, x, y, z). shape is (M, 4). Defaults to None, which means left unchanged.\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n*Hint:*\nThis method belongs to the methods used to set the prim state\n\n---\n**Example:**\n\n```python\n>>> # reposition all prims in row (x-axis)\n>>> positions = np.zeros((num_envs, 3))\n>>> positions[:,0] = np.arange(num_envs)\n>>> orientations = np.tile(np.array([1.0, 0.0, 0.0, 0.0]), (num_envs, 1))\n>>> prims.set_world_poses(positions, orientations)\n>>>\n>>> # reposition only the prims for the first, middle and last of the 5 envs in column (y-axis)\n>>> positions = np.zeros((3, 3))\n>>> positions[:,1] = np.arange(3)\n>>> orientations = np.tile(np.array([1.0, 0.0, 0.0, 0.0]), (3, 1))\n>>> prims.set_world_poses(positions, orientations, indices=np.array([0, 2, 4]))\n```\n",
"snippet":"rigid_prim_view.set_world_poses()\n",
"category":"method"
}
]
},
{
"title":"XFormPrim",
"snippets":[
{
"title":"import ...",
"description":"Import class",
"snippet":"from omni.isaac.core.prims import XFormPrim\n",
"category":"import"
},
{
"title":"XFormPrim",
"description":"Provides high level functions to deal with an Xform prim (only one Xform prim) and its attributes/properties\n\nIf there is an Xform prim present at the path, it will use it. Otherwise, a new XForm prim at\nthe specified prim path will be created\n\n*Note:*\nThe prim will have `xformOp:orient`, `xformOp:translate` and `xformOp:scale` only post-init,\nunless it is a non-root articulation link.\n\n**Args:**\n\n * `prim_path` (str): prim path of the Prim to encapsulate or create.\n * `name` (str, optional): shortname to be used as a key by Scene class. Note: needs to be unique if the object is added to the Scene. Defaults to \"xform\\_prim\".\n * `position` (Optional\\[Sequence\\[float\\]\\], optional): position in the world frame of the prim. shape is (3, ). Defaults to None, which means left unchanged.\n * `translation` (Optional\\[Sequence\\[float\\]\\], optional): translation in the local frame of the prim (with respect to its parent prim). shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the world/ local frame of the prim (depends if translation or position is specified). quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n * `scale` (Optional\\[Sequence\\[float\\]\\], optional): local scale to be applied to the prim's dimensions. shape is (3, ). Defaults to None, which means left unchanged.\n * `visible` (bool, optional): set to false for an invisible prim in the stage while rendering. Defaults to True.\n\n**Raises:**\n\n * Exception: if translation and position defined at the same time\n\n---\n**Example:**\n\n```python\n>>> from omni.isaac.core.prims import XFormPrim\n>>>\n>>> # given the stage: /World. Get the Xform prim at /World\n>>> prim = XFormPrim(\"/World\")\n>>> prim\n<omni.isaac.core.prims.xform_prim.XFormPrim object at 0x7f52381547c0>\n>>>\n>>> # create a new Xform prim at path: /World/Objects\n>>> prim = XFormPrim(\"/World/Objects\", name=\"objects\")\n>>> prim\n<omni.isaac.core.prims.xform_prim.XFormPrim object at 0x7f525c11d420>\n```\n",
"snippet":"xform_prim = XFormPrim(prim_path=prim_path)\n",
"category":"class"
},
{
"title":"apply_visual_material",
"description":"Apply visual material to the held prim and optionally its descendants.\n\n**Args:**\n\n * `visual_material` (VisualMaterial): visual material to be applied to the held prim. Currently supports PreviewSurface, OmniPBR and OmniGlass.\n * `weaker_than_descendants` (bool, optional): True if the material shouldn't override the descendants materials, otherwise False. Defaults to False.\n\n---\n**Example:**\n\n```python\n>>> from omni.isaac.core.materials import OmniGlass\n>>>\n>>> # create a dark-red glass visual material\n>>> material = OmniGlass(\n...     prim_path=\"/World/material/glass\",  # path to the material prim to create\n...     ior=1.25,\n...     depth=0.001,\n...     thin_walled=False,\n...     color=np.array([0.5, 0.0, 0.0])\n... )\n>>> prim.apply_visual_material(material)\n```\n",
"snippet":"xform_prim.apply_visual_material(visual_material=visual_material)\n",
"category":"method"
},
{
"title":"get_applied_visual_material",
"description":"Return the current applied visual material in case it was applied using apply\\_visual\\_material\nor it's one of the following materials that was already applied before: PreviewSurface, OmniPBR and OmniGlass.\n\n**Returns:**\n\n * VisualMaterial: the current applied visual material if its type is currently supported.\n\n---\n**Example:**\n\n```python\n>>> # given a visual material applied\n>>> prim.get_applied_visual_material()\n<omni.isaac.core.materials.omni_glass.OmniGlass object at 0x7f36263106a0>\n```\n",
"snippet":"applied_visual_material = xform_prim.get_applied_visual_material()\n",
"category":"method"
},
{
"title":"get_default_state",
"description":"Get the default prim states (spatial position and orientation).\n\n**Returns:**\n\n * XFormPrimState: an object that contains the default state of the prim (position and orientation)\n\n---\n**Example:**\n\n```python\n>>> state = prim.get_default_state()\n>>> state\n<omni.isaac.core.utils.types.XFormPrimState object at 0x7f33addda650>\n>>>\n>>> state.position\n[-4.5299529e-08 -1.8347054e-09 -2.8610229e-08]\n>>> state.orientation\n[1. 0. 0. 0.]\n```\n",
"snippet":"default_state = xform_prim.get_default_state()\n",
"category":"method"
},
{
"title":"get_local_pose",
"description":"Get prim's pose with respect to the local frame (the prim's parent frame)\n\n**Returns:**\n\n * Tuple\\[np.ndarray, np.ndarray\\]: first index is the position in the local frame (with shape (3, )).\n    Second index is quaternion orientation (with shape (4, )) in the local frame\n\n---\n**Example:**\n\n```python\n>>> # if the prim is in position (1.0, 0.5, 0.0) with respect to the world frame\n>>> position, orientation = prim.get_local_pose()\n>>> position\n[0. 0. 0.]\n>>> orientation\n[0. 0. 0.]\n```\n",
"snippet":"local_pose = xform_prim.get_local_pose()\n",
"category":"method"
},
{
"title":"get_local_scale",
"description":"Get prim's scale with respect to the local frame (the parent's frame)\n\n**Returns:**\n\n * np.ndarray: scale applied to the prim's dimensions in the local frame. shape is (3, ).\n\n---\n**Example:**\n\n```python\n>>> prim.get_local_scale()\n[1. 1. 1.]\n```\n",
"snippet":"local_scale = xform_prim.get_local_scale()\n",
"category":"method"
},
{
"title":"get_visibility",
"description":"**Returns:**\n\n * bool: true if the prim is visible in stage. false otherwise.\n\n---\n**Example:**\n\n```python\n>>> # get the visible state of an visible prim on the stage\n>>> prim.get_visibility()\nTrue\n```\n",
"snippet":"visibility = xform_prim.get_visibility()\n",
"category":"method"
},
{
"title":"get_world_pose",
"description":"Get prim's pose with respect to the world's frame\n\n**Returns:**\n\n * Tuple\\[np.ndarray, np.ndarray\\]: first index is the position in the world frame (with shape (3, )).\n    Second index is quaternion orientation (with shape (4, )) in the world frame\n\n---\n**Example:**\n\n```python\n>>> # if the prim is in position (1.0, 0.5, 0.0) with respect to the world frame\n>>> position, orientation = prim.get_world_pose()\n>>> position\n[1.  0.5 0. ]\n>>> orientation\n[1. 0. 0. 0.]\n```\n",
"snippet":"world_pose = xform_prim.get_world_pose()\n",
"category":"method"
},
{
"title":"get_world_scale",
"description":"Get prim's scale with respect to the world's frame\n\n**Returns:**\n\n * np.ndarray: scale applied to the prim's dimensions in the world frame. shape is (3, ).\n\n---\n**Example:**\n\n```python\n>>> prim.get_world_scale()\n[1. 1. 1.]\n```\n",
"snippet":"world_scale = xform_prim.get_world_scale()\n",
"category":"method"
},
{
"title":"initialize",
"description":"Create a physics simulation view if not passed and using PhysX tensor API\n\n*Note:*\nIf the prim has been added to the world scene (e.g., `world.scene.add(prim)`),\nit will be automatically initialized when the world is reset (e.g., `world.reset()`).\n\n**Args:**\n\n * `physics_sim_view` (omni.physics.tensors.SimulationView, optional): current physics simulation view. Defaults to None.\n\n---\n**Example:**\n\n```python\n>>> prim.initialize()\n```\n",
"snippet":"xform_prim.initialize()\n",
"category":"method"
},
{
"title":"is_valid",
"description":"Check if the prim path has a valid USD Prim at it\n\n**Returns:**\n\n * bool: True is the current prim path corresponds to a valid prim in stage. False otherwise.\n\n---\n**Example:**\n\n```python\n>>> # given an existing and valid prim\n>>> prims.is_valid()\nTrue\n```\n",
"snippet":"value = xform_prim.is_valid()\n",
"category":"method"
},
{
"title":"is_visual_material_applied",
"description":"Check if there is a visual material applied\n\n**Returns:**\n\n * bool: True if there is a visual material applied. False otherwise.\n\n---\n**Example:**\n\n```python\n>>> # given a visual material applied\n>>> prim.is_visual_material_applied()\nTrue\n```\n",
"snippet":"value = xform_prim.is_visual_material_applied()\n",
"category":"method"
},
{
"title":"post_reset",
"description":"Reset the prim to its default state (position and orientation).\n\n*Note:*\nFor an articulation, in addition to configuring the root prim's default position and spatial orientation\n(defined via the `set_default_state` method), the joint's positions, velocities, and efforts\n(defined via the `set_joints_default_state` method) are imposed\n\n---\n**Example:**\n\n```python\n>>> prim.post_reset()\n```\n",
"snippet":"xform_prim.post_reset()\n",
"category":"method"
},
{
"title":"set_default_state",
"description":"Set the default state of the prim (position and orientation), that will be used after each reset.\n\n**Args:**\n\n * `position` (Optional\\[Sequence\\[float\\]\\], optional): position in the world frame of the prim. shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the world frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n\n---\n**Example:**\n\n```python\n>>> # configure default state\n>>> prim.set_default_state(position=np.array([1.0, 0.5, 0.0]), orientation=np.array([1, 0, 0, 0]))\n>>>\n>>> # set default states during post-reset\n>>> prim.post_reset()\n```\n",
"snippet":"xform_prim.set_default_state()\n",
"category":"method"
},
{
"title":"set_local_pose",
"description":"Set prim's pose with respect to the local frame (the prim's parent frame).\n\n*Warning:*\nThis method will change (teleport) the prim pose immediately to the indicated value\n\n**Args:**\n\n * `translation` (Optional\\[Sequence\\[float\\]\\], optional): translation in the local frame of the prim (with respect to its parent prim). shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the local frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n\n*Hint:*\nThis method belongs to the methods used to set the prim state\n\n---\n**Example:**\n\n```python\n>>> prim.set_local_pose(translation=np.array([1.0, 0.5, 0.0]), orientation=np.array([1., 0., 0., 0.]))\n```\n",
"snippet":"xform_prim.set_local_pose()\n",
"category":"method"
},
{
"title":"set_local_scale",
"description":"Set prim's scale with respect to the local frame (the prim's parent frame).\n\n**Args:**\n\n * `scale` (Optional\\[Sequence\\[float\\]\\]): scale to be applied to the prim's dimensions. shape is (3, ). Defaults to None, which means left unchanged.\n\n---\n**Example:**\n\n```python\n>>> # scale prim 10 times smaller\n>>> prim.set_local_scale(np.array([0.1, 0.1, 0.1]))\n```\n",
"snippet":"xform_prim.set_local_scale(scale=scale)\n",
"category":"method"
},
{
"title":"set_visibility",
"description":"Set the visibility of the prim in stage\n\n**Args:**\n\n * `visible` (bool): flag to set the visibility of the usd prim in stage.\n\n---\n**Example:**\n\n```python\n>>> # make prim not visible in the stage\n>>> prim.set_visibility(visible=False)\n```\n",
"snippet":"xform_prim.set_visibility(visible=visible)\n",
"category":"method"
},
{
"title":"set_world_pose",
"description":"Ses prim's pose with respect to the world's frame\n\n*Warning:*\nThis method will change (teleport) the prim pose immediately to the indicated value\n\n**Args:**\n\n * `position` (Optional\\[Sequence\\[float\\]\\], optional): position in the world frame of the prim. shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the world frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n\n*Hint:*\nThis method belongs to the methods used to set the prim state\n\n---\n**Example:**\n\n```python\n>>> prim.set_world_pose(position=np.array([1.0, 0.5, 0.0]), orientation=np.array([1., 0., 0., 0.]))\n```\n",
"snippet":"xform_prim.set_world_pose()\n",
"category":"method"
}
]
},
{
"title":"XFormPrimView",
"snippets":[
{
"title":"import ...",
"description":"Import class",
"snippet":"from omni.isaac.core.prims import XFormPrimView\n",
"category":"import"
},
{
"title":"XFormPrimView",
"description":"Provides high level functions to deal with a Xform prim view (one or many) and its descendants\nas well as its attributes/properties.\n\nThis class wraps all matching Xforms found at the regex provided at the `prim_paths_expr` argument\n\n*Note:*\nEach prim will have `xformOp:orient`, `xformOp:translate` and `xformOp:scale` only post-init,\nunless it is a non-root articulation link.\n\n**Args:**\n\n * `prim_paths_expr` (str): prim paths regex to encapsulate all prims that match it. example: \"/World/Env\\[1-5\\]/Franka\" will match /World/Env1/Franka, /World/Env2/Franka..etc. (a non regex prim path can also be used to encapsulate one Xform).\n * `name` (str, optional): shortname to be used as a key by Scene class. Note: needs to be unique if the object is added to the Scene. Defaults to \"xform\\_prim\\_view\".\n * `positions` (Optional\\[Union\\[np.ndarray, torch.Tensor\\]\\], optional): default positions in the world frame of the prim. shape is (N, 3). Defaults to None, which means left unchanged.\n * `translations` (Optional\\[Union\\[np.ndarray, torch.Tensor\\]\\], optional): default translations in the local frame of the prims (with respect to its parent prims). shape is (N, 3). Defaults to None, which means left unchanged.\n * `orientations` (Optional\\[Union\\[np.ndarray, torch.Tensor\\]\\], optional): default quaternion orientations in the world/ local frame of the prim (depends if translation or position is specified). quaternion is scalar-first (w, x, y, z). shape is (N, 4). Defaults to None, which means left unchanged.\n * `scales` (Optional\\[Union\\[np.ndarray, torch.Tensor\\]\\], optional): local scales to be applied to the prim's dimensions. shape is (N, 3). Defaults to None, which means left unchanged.\n * `visibilities` (Optional\\[Union\\[np.ndarray, torch.Tensor\\]\\], optional): set to false for an invisible prim in the stage while rendering. shape is (N,). Defaults to None.\n * `reset_xform_properties` (bool, optional): True if the prims don't have the right set of xform properties (i.e: translate, orient and scale) ONLY and in that order. Set this parameter to False if the object were cloned using using the cloner api in omni.isaac.cloner. Defaults to True.\n\n**Raises:**\n\n * Exception: if translations and positions defined at the same time.\n    Exception: No prim was matched using the prim\\_paths\\_expr provided.\n\n---\n**Example:**\n\n```python\n>>> import omni.isaac.core.utils.stage as stage_utils\n>>> from omni.isaac.cloner import GridCloner\n>>> from omni.isaac.core.prims import XFormPrimView\n>>> from pxr import UsdGeom\n>>>\n>>> env_zero_path = \"/World/envs/env_0\"\n>>> num_envs = 5\n>>>\n>>> # load the Franka Panda robot USD file\n>>> stage_utils.add_reference_to_stage(usd_path, prim_path=f\"{env_zero_path}/panda\")  # /World/envs/env_0/panda\n>>>\n>>> # clone the environment (num_envs)\n>>> cloner = GridCloner(spacing=1.5)\n>>> cloner.define_base_env(env_zero_path)\n>>> UsdGeom.Xform.Define(stage_utils.get_current_stage(), env_zero_path)\n>>> env_pos = cloner.clone(\n...     source_prim_path=env_zero_path,\n...     prim_paths=cloner.generate_paths(\"/World/envs/env\", num_envs),\n...     copy_from_source=True\n... )\n>>>\n>>> # wrap all Xforms\n>>> prims = XFormPrimView(prim_paths_expr=\"/World/envs/env.*\", name=\"xform_view\")\n>>> prims\n<omni.isaac.core.prims.xform_prim_view.XFormPrimView object at 0x7f8ffd22ebc0>\n```\n",
"snippet":"xform_prim_view = XFormPrimView(prim_paths_expr=prim_paths_expr)\n",
"category":"class"
},
{
"title":"apply_visual_materials",
"description":"Apply visual material to the prims and optionally their prim descendants.\n\n**Args:**\n\n * `visual_materials` (Union\\[VisualMaterial, List\\[VisualMaterial\\]\\]): visual materials to be applied to the prims. Currently supports PreviewSurface, OmniPBR and OmniGlass. If a list is provided then its size has to be equal the view's size or indices size. If one material is provided it will be applied to all prims in the view.\n * `weaker_than_descendants` (Optional\\[Union\\[bool, List\\[bool\\]\\]\\], optional): True if the material shouldn't override the descendants materials, otherwise False. Defaults to False. If a list of visual materials is provided then a list has to be provided with the same size for this arg as well.\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Raises:**\n\n * Exception: length of visual materials != length of prims indexed\n    Exception: length of visual materials != length of weaker descendants bools arg\n\n---\n**Example:**\n\n```python\n>>> from omni.isaac.core.materials import OmniGlass\n>>>\n>>> # create a dark-red glass visual material\n>>> material = OmniGlass(\n...     prim_path=\"/World/material/glass\",  # path to the material prim to create\n...     ior=1.25,\n...     depth=0.001,\n...     thin_walled=False,\n...     color=np.array([0.5, 0.0, 0.0])\n... )\n>>> prims.apply_visual_materials(material)\n```\n",
"snippet":"xform_prim_view.apply_visual_materials(visual_materials=visual_materials)\n",
"category":"method"
},
{
"title":"count",
"description":"**Returns:**\n\n * int: Number of prims encapsulated in this view.\n\n---\n**Example:**\n\n```python\n>>> prims.count\n5\n```\n",
"snippet":"count = xform_prim_view.count\n",
"category":"property"
},
{
"title":"get_applied_visual_materials",
"description":"Get the current applied visual materials\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Returns:**\n\n * List\\[VisualMaterial\\]: a list of the current applied visual materials to the prims if its type is currently supported.\n\n---\n**Example:**\n\n```python\n>>> # get all applied visual materials. Returned size is 5 for the example: 5 envs\n>>> prims.get_applied_visual_materials()\n[<omni.isaac.core.materials.omni_glass.OmniGlass object at 0x7f829c165de0>,\n <omni.isaac.core.materials.omni_glass.OmniGlass object at 0x7f829c165de0>,\n <omni.isaac.core.materials.omni_glass.OmniGlass object at 0x7f829c165de0>,\n <omni.isaac.core.materials.omni_glass.OmniGlass object at 0x7f829c165de0>,\n <omni.isaac.core.materials.omni_glass.OmniGlass object at 0x7f829c165de0>]\n>>>\n>>> # get the applied visual materials for the first, middle and last of the 5 envs. Returned size is 3\n>>> prims.get_applied_visual_materials(indices=np.array([0, 2, 4]))\n[<omni.isaac.core.materials.omni_glass.OmniGlass object at 0x7f829c165de0>,\n <omni.isaac.core.materials.omni_glass.OmniGlass object at 0x7f829c165de0>,\n <omni.isaac.core.materials.omni_glass.OmniGlass object at 0x7f829c165de0>]\n```\n",
"snippet":"applied_visual_materials = xform_prim_view.get_applied_visual_materials()\n",
"category":"method"
},
{
"title":"get_default_state",
"description":"Get the default states (positions and orientations) defined with the `set_default_state` method\n\n**Returns:**\n\n * XFormPrimViewState: returns the default state of the prims that is used after each reset.\n\n---\n**Example:**\n\n```python\n>>> state = prims.get_default_state()\n>>> state\n<omni.isaac.core.utils.types.XFormPrimViewState object at 0x7f82f73e3070>\n>>> state.positions\n[[ 1.5  -0.75  0.  ]\n [ 1.5   0.75  0.  ]\n [ 0.   -0.75  0.  ]\n [ 0.    0.75  0.  ]\n [-1.5  -0.75  0.  ]]\n>>> state.orientations\n[[1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]]\n```\n",
"snippet":"default_state = xform_prim_view.get_default_state()\n",
"category":"method"
},
{
"title":"get_local_poses",
"description":"Get prim poses in the view with respect to the local frame (the prim's parent frame)\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Returns:**\n\n * Union\\[Tuple\\[np.ndarray, np.ndarray\\], Tuple\\[torch.Tensor, torch.Tensor\\], Tuple\\[wp.indexedarray, wp.indexedarray\\]\\]: first index is translations in the local frame of the prims. shape is (M, 3). second index is quaternion orientations in the local frame of the prims. quaternion is scalar-first (w, x, y, z). shape is (M, 4).\n\n---\n**Example:**\n\n```python\n>>> # get all prims poses with respect to the local frame.\n>>> # Returned shape is position (5, 3) and orientation (5, 4) for the example: 5 envs\n>>> positions, orientations = prims.get_local_poses()\n>>> positions\n[[ 1.5  -0.75  0.  ]\n [ 1.5   0.75  0.  ]\n [ 0.   -0.75  0.  ]\n [ 0.    0.75  0.  ]\n [-1.5  -0.75  0.  ]]\n>>> orientations\n[[1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]]\n>>>\n>>> # get only the prims poses with respect to the local frame for the first, middle and last of the 5 envs.\n>>> # Returned shape is position (3, 3) and orientation (3, 4) for the example: 3 envs selected\n>>> positions, orientations = prims.get_local_poses(indices=np.array([0, 2, 4]))\n>>> positions\n[[ 1.5  -0.75  0.  ]\n [ 0.   -0.75  0.  ]\n [-1.5  -0.75  0.  ]]\n>>> orientations\n[[1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]]\n```\n",
"snippet":"local_poses = xform_prim_view.get_local_poses()\n",
"category":"method"
},
{
"title":"get_local_scales",
"description":"Get prim scales in the view with respect to the local frame (the parent's frame).\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: scales applied to the prim's dimensions in the local frame. shape is (M, 3).\n\n---\n**Example:**\n\n```python\n>>> # get all prims scales with respect to the local frame.\n>>> # Returned shape is (5, 3) for the example: 5 envs\n>>> prims.get_local_scales()\n[[1. 1. 1.]\n [1. 1. 1.]\n [1. 1. 1.]\n [1. 1. 1.]\n [1. 1. 1.]]\n>>>\n>>> # get only the prims scales with respect to the local frame for the first, middle and last of the 5 envs.\n>>> # Returned shape is (3, 3) for the example: 3 envs selected\n>>> prims.get_local_scales(indices=np.array([0, 2, 4]))\n[[1. 1. 1.]\n [1. 1. 1.]\n [1. 1. 1.]]\n```\n",
"snippet":"local_scales = xform_prim_view.get_local_scales()\n",
"category":"method"
},
{
"title":"get_visibilities",
"description":"Returns the current visibilities of the prims in stage.\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: Shape (M,) with type bool, where each item holds True if the prim is visible in stage. False otherwise.\n\n---\n**Example:**\n\n```python\n>>> # get all visibilities. Returned shape is (5,) for the example: 5 envs\n>>> prims.get_visibilities()\n[ True  True  True  True  True]\n>>>\n>>> # get the visibilities for the first, middle and last of the 5 envs. Returned shape is (3,)\n>>> prims.get_visibilities(indices=np.array([0, 2, 4]))\n[ True  True  True]\n```\n",
"snippet":"visibilities = xform_prim_view.get_visibilities()\n",
"category":"method"
},
{
"title":"get_world_poses",
"description":"Get the poses of the prims in the view with respect to the world's frame\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Returns:**\n\n * Union\\[Tuple\\[np.ndarray, np.ndarray\\], Tuple\\[torch.Tensor, torch.Tensor\\], Tuple\\[wp.indexedarray, wp.indexedarray\\]\\]: first index is positions in the world frame of the prims. shape is (M, 3). second index is quaternion orientations in the world frame of the prims. quaternion is scalar-first (w, x, y, z). shape is (M, 4).\n\n---\n**Example:**\n\n```python\n>>> # get all prims poses with respect to the world's frame.\n>>> # Returned shape is position (5, 3) and orientation (5, 4) for the example: 5 envs\n>>> positions, orientations = prims.get_world_poses()\n>>> positions\n[[ 1.5  -0.75  0.  ]\n [ 1.5   0.75  0.  ]\n [ 0.   -0.75  0.  ]\n [ 0.    0.75  0.  ]\n [-1.5  -0.75  0.  ]]\n>>> orientations\n[[1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]]\n>>>\n>>> # get only the prims poses with respect to the world's frame for the first, middle and last of the 5 envs.\n>>> # Returned shape is position (3, 3) and orientation (3, 4) for the example: 3 envs selected\n>>> positions, orientations = prims.get_world_poses(indices=np.array([0, 2, 4]))\n>>> positions\n[[ 1.5  -0.75  0.  ]\n [ 0.   -0.75  0.  ]\n [-1.5  -0.75  0.  ]]\n>>> orientations\n[[1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]]\n```\n",
"snippet":"world_poses = xform_prim_view.get_world_poses()\n",
"category":"method"
},
{
"title":"get_world_scales",
"description":"Get prim scales in the view with respect to the world's frame\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: scales applied to the prim's dimensions in the world frame. shape is (M, 3).\n\n---\n**Example:**\n\n```python\n>>> # get all prims scales with respect to the world's frame.\n>>> # Returned shape is (5, 3) for the example: 5 envs\n>>> prims.get_world_scales()\n[[1. 1. 1.]\n [1. 1. 1.]\n [1. 1. 1.]\n [1. 1. 1.]\n [1. 1. 1.]]\n>>>\n>>> # get only the prims scales with respect to the world's frame for the first, middle and last of the 5 envs.\n>>> # Returned shape is (3, 3) for the example: 3 envs selected\n>>> prims.get_world_scales(indices=np.array([0, 2, 4]))\n[[1. 1. 1.]\n [1. 1. 1.]\n [1. 1. 1.]]\n```\n",
"snippet":"world_scales = xform_prim_view.get_world_scales()\n",
"category":"method"
},
{
"title":"initialize",
"description":"Create a physics simulation view if not passed and set other properties using the PhysX tensor API\n\n*Note:*\nFor this particular class, calling this method will do nothing\n\n**Args:**\n\n * `physics_sim_view` (omni.physics.tensors.SimulationView, optional): current physics simulation view. Defaults to None.\n\n---\n**Example:**\n\n```python\n>>> prims.initialize()\n```\n",
"snippet":"xform_prim_view.initialize()\n",
"category":"method"
},
{
"title":"is_non_root_articulation_link",
"description":"**Returns:**\n\n * bool: True if the prim corresponds to a non root link in an articulation. Otherwise False.\n",
"snippet":"is_non_root_articulation_link = xform_prim_view.is_non_root_articulation_link\n",
"category":"property"
},
{
"title":"is_valid",
"description":"Check that all prims have a valid USD Prim\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Returns:**\n\n * bool: True if all prim paths specified in the view correspond to a valid prim in stage. False otherwise.\n\n---\n**Example:**\n\n```python\n>>> prims.is_valid()\nTrue\n```\n",
"snippet":"value = xform_prim_view.is_valid()\n",
"category":"method"
},
{
"title":"is_visual_material_applied",
"description":"Check if there is a visual material applied\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Returns:**\n\n * List\\[bool\\]: True if there is a visual material applied is applied to the corresponding prim in the view. False otherwise.\n\n---\n**Example:**\n\n```python\n>>> # given a visual material that is applied only to the first and the last environment\n>>> prims.is_visual_material_applied()\n[True, False, False, False, True]\n>>>\n>>> # check for the first, middle and last of the 5 envs\n>>> prims.is_visual_material_applied(indices=np.array([0, 2, 4]))\n[True, False, True]\n```\n",
"snippet":"value = xform_prim_view.is_visual_material_applied()\n",
"category":"method"
},
{
"title":"name",
"description":"**Returns:**\n\n * str: name given to the prims view when instantiating it.\n",
"snippet":"name = xform_prim_view.name\n",
"category":"property"
},
{
"title":"post_reset",
"description":"Reset the prims to its default state (positions and orientations)\n\n---\n**Example:**\n\n```python\n>>> prims.post_reset()\n```\n",
"snippet":"xform_prim_view.post_reset()\n",
"category":"method"
},
{
"title":"prim_paths",
"description":"**Returns:**\n\n * List\\[str\\]: list of prim paths in the stage encapsulated in this view.\n\n---\n**Example:**\n\n```python\n>>> prims.prim_paths\n['/World/envs/env_0', '/World/envs/env_1', '/World/envs/env_2', '/World/envs/env_3', '/World/envs/env_4']\n```\n",
"snippet":"prim_paths = xform_prim_view.prim_paths\n",
"category":"property"
},
{
"title":"prims",
"description":"**Returns:**\n\n * List\\[Usd.Prim\\]: List of USD Prim objects encapsulated in this view.\n\n---\n**Example:**\n\n```python\n>>> prims.prims\n[Usd.Prim(</World/envs/env_0>), Usd.Prim(</World/envs/env_1>), Usd.Prim(</World/envs/env_2>),\n Usd.Prim(</World/envs/env_3>), Usd.Prim(</World/envs/env_4>)]\n```\n",
"snippet":"prims = xform_prim_view.prims\n",
"category":"property"
},
{
"title":"set_default_state",
"description":"Set the default state of the prims (positions and orientations), that will be used after each reset.\n\n*Note:*\nThe default states will be set during post-reset (e.g., calling `.post_reset()` or `world.reset()` methods)\n\n**Args:**\n\n * `positions` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): positions in the world frame of the prim. shape is (M, 3). Defaults to None, which means left unchanged.\n * `orientations` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): quaternion orientations in the world frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (M, 4). Defaults to None, which means left unchanged.\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n---\n**Example:**\n\n```python\n>>> # configure default states for all prims\n>>> positions = np.zeros((num_envs, 3))\n>>> positions[:, 0] = np.arange(num_envs)\n>>> orientations = np.tile(np.array([1.0, 0.0, 0.0, 0.0]), (num_envs, 1))\n>>> prims.set_default_state(positions=positions, orientations=orientations)\n>>>\n>>> # set default states during post-reset\n>>> prims.post_reset()\n```\n",
"snippet":"xform_prim_view.set_default_state()\n",
"category":"method"
},
{
"title":"set_local_poses",
"description":"Set prim poses in the view with respect to the local frame (the prim's parent frame)\n\n*Warning:*\nThis method will change (teleport) the prim poses immediately to the indicated value\n\n**Args:**\n\n * `translations` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): translations in the local frame of the prims (with respect to its parent prim). shape is (M, 3). Defaults to None, which means left unchanged.\n * `orientations` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): quaternion orientations in the local frame of the prims. quaternion is scalar-first (w, x, y, z). shape is (M, 4). Defaults to None, which means left unchanged.\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n*Hint:*\nThis method belongs to the methods used to set the prim state\n\n---\n**Example:**\n\n```python\n>>> # reposition all prims\n>>> positions = np.zeros((num_envs, 3))\n>>> positions[:,0] = np.arange(num_envs)\n>>> orientations = np.tile(np.array([1.0, 0.0, 0.0, 0.0]), (num_envs, 1))\n>>> prims.set_local_poses(positions, orientations)\n>>>\n>>> # reposition only the prims for the first, middle and last of the 5 envs\n>>> positions = np.zeros((3, 3))\n>>> positions[:,1] = np.arange(3)\n>>> orientations = np.tile(np.array([1.0, 0.0, 0.0, 0.0]), (3, 1))\n>>> prims.set_local_poses(positions, orientations, indices=np.array([0, 2, 4]))\n```\n",
"snippet":"xform_prim_view.set_local_poses()\n",
"category":"method"
},
{
"title":"set_local_scales",
"description":"Set prim scales in the view with respect to the local frame (the prim's parent frame)\n\n**Args:**\n\n * `scales` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\]): scales to be applied to the prim's dimensions in the view. shape is (M, 3).\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n---\n**Example:**\n\n```python\n>>> # set the scale for all prims. Since there are 5 envs, the scale is repeated 5 times\n>>> scales = np.tile(np.array([1.0, 0.75, 0.5]), (num_envs, 1))\n>>> prims.set_local_scales(scales)\n>>>\n>>> # set the scale for the first, middle and last of the 5 envs\n>>> scales = np.tile(np.array([1.0, 0.75, 0.5]), (3, 1))\n>>> prims.set_local_scales(scales, indices=np.array([0, 2, 4]))\n```\n",
"snippet":"xform_prim_view.set_local_scales(scales=scales)\n",
"category":"method"
},
{
"title":"set_visibilities",
"description":"Set the visibilities of the prims in stage\n\n**Args:**\n\n * `visibilities` (Union\\[np.ndarray, torch.Tensor, wp.array\\]): flag to set the visibilities of the usd prims in stage. Shape (M,). Where M \\<= size of the encapsulated prims in the view.\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Defaults to None (i.e: all prims in the view).\n\n---\n**Example:**\n\n```python\n>>> # make all prims not visible in the stage\n>>> prims.set_visibilities(visibilities=[False] * num_envs)\n```\n",
"snippet":"xform_prim_view.set_visibilities(visibilities=visibilities)\n",
"category":"method"
},
{
"title":"set_world_poses",
"description":"Set prim poses in the view with respect to the world's frame\n\n*Warning:*\nThis method will change (teleport) the prim poses immediately to the indicated value\n\n**Args:**\n\n * `positions` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): positions in the world frame of the prims. shape is (M, 3). Defaults to None, which means left unchanged.\n * `orientations` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): quaternion orientations in the world frame of the prims. quaternion is scalar-first (w, x, y, z). shape is (M, 4). Defaults to None, which means left unchanged.\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n*Hint:*\nThis method belongs to the methods used to set the prim state\n\n---\n**Example:**\n\n```python\n>>> # reposition all prims in row (x-axis)\n>>> positions = np.zeros((num_envs, 3))\n>>> positions[:,0] = np.arange(num_envs)\n>>> orientations = np.tile(np.array([1.0, 0.0, 0.0, 0.0]), (num_envs, 1))\n>>> prims.set_world_poses(positions, orientations)\n>>>\n>>> # reposition only the prims for the first, middle and last of the 5 envs in column (y-axis)\n>>> positions = np.zeros((3, 3))\n>>> positions[:,1] = np.arange(3)\n>>> orientations = np.tile(np.array([1.0, 0.0, 0.0, 0.0]), (3, 1))\n>>> prims.set_world_poses(positions, orientations, indices=np.array([0, 2, 4]))\n```\n",
"snippet":"xform_prim_view.set_world_poses()\n",
"category":"method"
}
]
}
]
},
{
"title":"Robots",
"snippets":[
{
"title":"Robot",
"snippets":[
{
"title":"import ...",
"description":"Import class",
"snippet":"from omni.isaac.core.robots import Robot\n",
"category":"import"
},
{
"title":"Robot",
"description":"Implementation (on `Articulation` class) to deal with an articulation prim as a robot\n\n*Warning:*\nThe robot (articulation) object must be initialized in order to be able to operate on it.\nSee the `initialize` method for more details.\n\n**Args:**\n\n * `prim_path` (str): prim path of the Prim to encapsulate or create.\n * `name` (str, optional): shortname to be used as a key by Scene class. Note: needs to be unique if the object is added to the Scene. Defaults to \"robot\".\n * `position` (Optional\\[Sequence\\[float\\]\\], optional): position in the world frame of the prim. shape is (3, ). Defaults to None, which means left unchanged.\n * `translation` (Optional\\[Sequence\\[float\\]\\], optional): translation in the local frame of the prim (with respect to its parent prim). shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the world/ local frame of the prim (depends if translation or position is specified). quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n * `scale` (Optional\\[Sequence\\[float\\]\\], optional): local scale to be applied to the prim's dimensions. shape is (3, ). Defaults to None, which means left unchanged.\n * `visible` (bool, optional): set to false for an invisible prim in the stage while rendering. Defaults to True.\n * `articulation_controller` (Optional\\[ArticulationController\\], optional): a custom ArticulationController which inherits from it. Defaults to creating the basic ArticulationController.\n\n---\n**Example:**\n\n```python\n>>> import omni.isaac.core.utils.stage as stage_utils\n>>> from omni.isaac.core.robots import Robot\n>>>\n>>> usd_path = \"/home/<user>/Documents/Assets/Robots/Franka/franka_alt_fingers.usd\"\n>>> prim_path = \"/World/envs/env_0/panda\"\n>>>\n>>> # load the Franka Panda robot USD file\n>>> stage_utils.add_reference_to_stage(usd_path, prim_path)\n>>>\n>>> # wrap the prim as a robot (articulation)\n>>> prim = Robot(prim_path=prim_path, name=\"franka_panda\")\n>>> print(prim)\n<omni.isaac.core.robots.robot.Robot object at 0x7fdd4875a1d0>\n```\n",
"snippet":"robot = Robot(prim_path=prim_path)\n",
"category":"class"
},
{
"title":"apply_action",
"description":"Apply joint positions, velocities and/or efforts to control an articulation\n\n**Args:**\n\n * `control_actions` (ArticulationAction): actions to be applied for next physics step.\n * `indices` (Optional\\[Union\\[list, np.ndarray\\]\\], optional): degree of freedom indices to apply actions to. Defaults to all degrees of freedom.\n\n*Hint:*\nHigh stiffness makes the joints snap faster and harder to the desired target,\nand higher damping smoothes but also slows down the joint's movement to target\n\n * For position control, set relatively high stiffness and low damping (to reduce vibrations)\n * For velocity control, stiffness must be set to zero with a non-zero damping\n * For effort control, stiffness and damping must be set to zero\n\n---\n**Example:**\n\n```python\n>>> from omni.isaac.core.utils.types import ArticulationAction\n>>>\n>>> # move all the robot joints to the indicated position\n>>> action = ArticulationAction(joint_positions=np.array([0.0, -1.0, 0.0, -2.2, 0.0, 2.4, 0.8, 0.04, 0.04]))\n>>> prim.apply_action(action)\n>>>\n>>> # close the robot fingers: panda_finger_joint1 (7) and panda_finger_joint2 (8) to 0.0\n>>> action = ArticulationAction(joint_positions=np.array([0.0, 0.0]), joint_indices=np.array([7, 8]))\n>>> prim.apply_action(action)\n```\n",
"snippet":"robot.apply_action(control_actions=control_actions)\n",
"category":"method"
},
{
"title":"apply_visual_material",
"description":"Apply visual material to the held prim and optionally its descendants.\n\n**Args:**\n\n * `visual_material` (VisualMaterial): visual material to be applied to the held prim. Currently supports PreviewSurface, OmniPBR and OmniGlass.\n * `weaker_than_descendants` (bool, optional): True if the material shouldn't override the descendants materials, otherwise False. Defaults to False.\n\n---\n**Example:**\n\n```python\n>>> from omni.isaac.core.materials import OmniGlass\n>>>\n>>> # create a dark-red glass visual material\n>>> material = OmniGlass(\n...     prim_path=\"/World/material/glass\",  # path to the material prim to create\n...     ior=1.25,\n...     depth=0.001,\n...     thin_walled=False,\n...     color=np.array([0.5, 0.0, 0.0])\n... )\n>>> prim.apply_visual_material(material)\n```\n",
"snippet":"robot.apply_visual_material(visual_material=visual_material)\n",
"category":"method"
},
{
"title":"disable_gravity",
"description":"Keep gravity from affecting the robot\n\n---\n**Example:**\n\n```python\n>>> prim.disable_gravity()\n```\n",
"snippet":"robot.disable_gravity()\n",
"category":"method"
},
{
"title":"enable_gravity",
"description":"Gravity will affect the robot\n\n---\n**Example:**\n\n```python\n>>> prim.enable_gravity()\n```\n",
"snippet":"robot.enable_gravity()\n",
"category":"method"
},
{
"title":"get_angular_velocity",
"description":"Get the angular velocity of the root articulation prim\n\n**Returns:**\n\n * np.ndarray: 3D angular velocity vector. Shape (3,)\n\n---\n**Example:**\n\n```python\n>>> prim.get_angular_velocity()\n[0. 0. 0.]\n```\n",
"snippet":"angular_velocity = robot.get_angular_velocity()\n",
"category":"method"
},
{
"title":"get_applied_action",
"description":"Get the last applied action\n\n**Returns:**\n\n * ArticulationAction: last applied action. Note: a dictionary is used as the object's string representation\n\n---\n**Example:**\n\n```python\n>>> # last applied action: joint_positions -> [0.0, -1.0, 0.0, -2.2, 0.0, 2.4, 0.8, 0.04, 0.04]\n>>> prim.get_applied_action()\n{'joint_positions': [0.0, -1.0, 0.0, -2.200000047683716, 0.0, 2.4000000953674316, 0.800000011920929, 0.03999999910593033, 0.03999999910593033],\n 'joint_velocities': [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n 'joint_efforts': [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]}\n```\n",
"snippet":"applied_action = robot.get_applied_action()\n",
"category":"method"
},
{
"title":"get_applied_joint_efforts",
"description":"Get the efforts applied to the joints set by the `set_joint_efforts` method\n\n**Args:**\n\n * `joint_indices` (Optional\\[Union\\[List, np.ndarray\\]\\], optional): indices to specify which joints to read. Defaults to None (all joints)\n\n**Raises:**\n\n * Exception: If the handlers are not initialized\n\n**Returns:**\n\n * np.ndarray: all or selected articulation joint applied efforts\n\n---\n**Example:**\n\n```python\n>>> # get all applied joint efforts\n>>> prim.get_applied_joint_efforts()\n[ 0.  0.  0.  0.  0.  0.  0.  0.  0.]\n>>>\n>>> # get finger applied efforts: panda_finger_joint1 (7) and panda_finger_joint2 (8)\n>>> prim.get_applied_joint_efforts(joint_indices=np.array([7, 8]))\n[0.  0.]\n```\n",
"snippet":"applied_joint_efforts = robot.get_applied_joint_efforts()\n",
"category":"method"
},
{
"title":"get_applied_visual_material",
"description":"Return the current applied visual material in case it was applied using apply\\_visual\\_material\nor it's one of the following materials that was already applied before: PreviewSurface, OmniPBR and OmniGlass.\n\n**Returns:**\n\n * VisualMaterial: the current applied visual material if its type is currently supported.\n\n---\n**Example:**\n\n```python\n>>> # given a visual material applied\n>>> prim.get_applied_visual_material()\n<omni.isaac.core.materials.omni_glass.OmniGlass object at 0x7f36263106a0>\n```\n",
"snippet":"applied_visual_material = robot.get_applied_visual_material()\n",
"category":"method"
},
{
"title":"get_articulation_body_count",
"description":"Get the number of bodies (links) that make up the articulation\n\n**Returns:**\n\n * int: amount of bodies\n\n---\n**Example:**\n\n```python\n>>> prim.get_articulation_body_count()\n12\n```\n",
"snippet":"articulation_body_count = robot.get_articulation_body_count()\n",
"category":"method"
},
{
"title":"get_articulation_controller",
"description":"Get the articulation controller\n\n*Note:*\nIf no `articulation_controller` was passed during class instantiation, a default controller\nof type `ArticulationController` (a Proportional-Derivative controller that can apply position targets,\nvelocity targets and efforts) will be used\n\n**Returns:**\n\n * ArticulationController: articulation controller\n\n---\n**Example:**\n\n```python\n>>> prim.get_articulation_controller()\n<omni.isaac.core.controllers.articulation_controller.ArticulationController object at 0x7f04a0060190>\n```\n",
"snippet":"articulation_controller = robot.get_articulation_controller()\n",
"category":"method"
},
{
"title":"get_default_state",
"description":"Get the default prim states (spatial position and orientation).\n\n**Returns:**\n\n * XFormPrimState: an object that contains the default state of the prim (position and orientation)\n\n---\n**Example:**\n\n```python\n>>> state = prim.get_default_state()\n>>> state\n<omni.isaac.core.utils.types.XFormPrimState object at 0x7f33addda650>\n>>>\n>>> state.position\n[-4.5299529e-08 -1.8347054e-09 -2.8610229e-08]\n>>> state.orientation\n[1. 0. 0. 0.]\n```\n",
"snippet":"default_state = robot.get_default_state()\n",
"category":"method"
},
{
"title":"get_dof_index",
"description":"Get a DOF index given its name\n\n**Args:**\n\n * `dof_name` (str): name of the DOF\n\n**Returns:**\n\n * int: DOF index\n\n---\n**Example:**\n\n```python\n>>> prim.get_dof_index(\"panda_finger_joint2\")\n8\n```\n",
"snippet":"dof_index = robot.get_dof_index(dof_name=dof_name)\n",
"category":"method"
},
{
"title":"get_enabled_self_collisions",
"description":"Get the enable self collisions flag (`physxArticulation:enabledSelfCollisions`)\n\n**Returns:**\n\n * int: self collisions flag (boolean interpreted as int)\n\n---\n**Example:**\n\n```python\n>>> prim.get_enabled_self_collisions()\n0\n```\n",
"snippet":"enabled_self_collisions = robot.get_enabled_self_collisions()\n",
"category":"method"
},
{
"title":"get_joint_positions",
"description":"Get the articulation joint positions\n\n**Args:**\n\n * `joint_indices` (Optional\\[Union\\[List, np.ndarray\\]\\], optional): indices to specify which joints to read. Defaults to None (all joints)\n\n**Returns:**\n\n * np.ndarray: all or selected articulation joint positions\n\n---\n**Example:**\n\n```python\n>>> # get all joint positions\n>>> prim.get_joint_positions()\n[ 1.1999920e-02 -5.6962633e-01  1.3480479e-08 -2.8105433e+00  6.8284894e-06\n  3.0301569e+00  7.3234749e-01  3.9912373e-02  3.9999999e-02]\n>>>\n>>> # get finger positions: panda_finger_joint1 (7) and panda_finger_joint2 (8)\n>>> prim.get_joint_positions(joint_indices=np.array([7, 8]))\n[0.03991237  3.9999999e-02]\n```\n",
"snippet":"joint_positions = robot.get_joint_positions()\n",
"category":"method"
},
{
"title":"get_joint_velocities",
"description":"Get the articulation joint velocities\n\n**Args:**\n\n * `joint_indices` (Optional\\[Union\\[List, np.ndarray\\]\\], optional): indices to specify which joints to read. Defaults to None (all joints)\n\n**Returns:**\n\n * np.ndarray: all or selected articulation joint velocities\n\n---\n**Example:**\n\n```python\n>>> # get all joint velocities\n>>> prim.get_joint_velocities()\n[ 1.91603772e-06 -7.67638255e-03 -2.19138826e-07  1.10636465e-02 -4.63412944e-05\n  3.48245539e-02  8.84692147e-02  5.40335372e-04 1.02849208e-05]\n>>>\n>>> # get finger velocities: panda_finger_joint1 (7) and panda_finger_joint2 (8)\n>>> prim.get_joint_velocities(joint_indices=np.array([7, 8]))\n[5.4033537e-04 1.0284921e-05]\n```\n",
"snippet":"joint_velocities = robot.get_joint_velocities()\n",
"category":"method"
},
{
"title":"get_joints_default_state",
"description":"Get the default joint states (positions and velocities).\n\n**Returns:**\n\n * JointsState: an object that contains the default joint positions and velocities\n\n---\n**Example:**\n\n```python\n>>> state = prim.get_joints_default_state()\n>>> state\n<omni.isaac.core.utils.types.JointsState object at 0x7f04a0061240>\n>>>\n>>> state.positions\n[ 0.012  -0.57000005  0.  -2.81  0.  3.037  0.785398  0.04  0.04 ]\n>>> state.velocities\n[0. 0. 0. 0. 0. 0. 0. 0. 0.]\n```\n",
"snippet":"joints_default_state = robot.get_joints_default_state()\n",
"category":"method"
},
{
"title":"get_joints_state",
"description":"Get the current joint states (positions and velocities)\n\n**Returns:**\n\n * JointsState: an object that contains the current joint positions and velocities\n\n---\n**Example:**\n\n```python\n>>> state = prim.get_joints_state()\n>>> state\n<omni.isaac.core.utils.types.JointsState object at 0x7f02f6df57b0>\n>>>\n>>> state.positions\n[ 1.1999920e-02 -5.6962633e-01  1.3480479e-08 -2.8105433e+00 6.8284894e-06\n  3.0301569e+00  7.3234749e-01  3.9912373e-02  3.9999999e-02]\n>>> state.velocities\n[ 1.91603772e-06 -7.67638255e-03 -2.19138826e-07  1.10636465e-02 -4.63412944e-05\n  245539e-02  8.84692147e-02  5.40335372e-04  1.02849208e-05]\n```\n",
"snippet":"joints_state = robot.get_joints_state()\n",
"category":"method"
},
{
"title":"get_linear_velocity",
"description":"Get the linear velocity of the root articulation prim\n\n**Returns:**\n\n * np.ndarray: 3D linear velocity vector. Shape (3,)\n\n---\n**Example:**\n\n```python\n>>> prim.get_linear_velocity()\n[0. 0. 0.]\n```\n",
"snippet":"linear_velocity = robot.get_linear_velocity()\n",
"category":"method"
},
{
"title":"get_local_pose",
"description":"Get prim's pose with respect to the local frame (the prim's parent frame)\n\n**Returns:**\n\n * Tuple\\[np.ndarray, np.ndarray\\]: first index is the position in the local frame (with shape (3, )).\n    Second index is quaternion orientation (with shape (4, )) in the local frame\n\n---\n**Example:**\n\n```python\n>>> # if the prim is in position (1.0, 0.5, 0.0) with respect to the world frame\n>>> position, orientation = prim.get_local_pose()\n>>> position\n[0. 0. 0.]\n>>> orientation\n[0. 0. 0.]\n```\n",
"snippet":"local_pose = robot.get_local_pose()\n",
"category":"method"
},
{
"title":"get_local_scale",
"description":"Get prim's scale with respect to the local frame (the parent's frame)\n\n**Returns:**\n\n * np.ndarray: scale applied to the prim's dimensions in the local frame. shape is (3, ).\n\n---\n**Example:**\n\n```python\n>>> prim.get_local_scale()\n[1. 1. 1.]\n```\n",
"snippet":"local_scale = robot.get_local_scale()\n",
"category":"method"
},
{
"title":"get_measured_joint_efforts",
"description":"Returns the efforts computed/measured by the physics solver of the joint forces in the DOF motion direction\n\n**Args:**\n\n * `joint_indices` (Optional\\[Union\\[List, np.ndarray\\]\\], optional): indices to specify which joints to read. Defaults to None (all joints)\n\n**Raises:**\n\n * Exception: If the handlers are not initialized\n\n**Returns:**\n\n * np.ndarray: all or selected articulation joint measured efforts\n\n---\n**Example:**\n\n```python\n>>> # get all joint efforts\n>>> prim.get_measured_joint_efforts()\n[ 2.7897308e-06 -6.9083519e+00 -3.6398471e-06  1.9158335e+01 -4.3552645e-06\n  1.1866090e+00 -4.7079347e-06  3.2339853e-04 -3.2044132e-04]\n>>>\n>>> # get finger efforts: panda_finger_joint1 (7) and panda_finger_joint2 (8)\n>>> prim.get_measured_joint_efforts(joint_indices=np.array([7, 8]))\n[ 0.0003234  -0.00032044]\n```\n",
"snippet":"measured_joint_efforts = robot.get_measured_joint_efforts()\n",
"category":"method"
},
{
"title":"get_measured_joint_forces",
"description":"Get the measured joint reaction forces and torques (link incoming joint forces and torques) to external loads\n\n*Note:*\nSince the *name-\\>index* map for joints has not been exposed yet,\nit is possible to access the joint names and their indices through the articulation metadata.\n\n> ```python\n> ```\n>\n> prim.\\_articulation\\_view.\\_metadata.joint\\_names \\# list of names prim.\\_articulation\\_view.\\_metadata.joint\\_indices \\# dict of name: index\n>\n> To retrieve a specific row for the link incoming joint force/torque use `joint_index + 1`\n\n**Args:**\n\n * `joint_indices` (Optional\\[Union\\[List, np.ndarray\\]\\], optional): indices to specify which joints to read. Defaults to None (all joints)\n\n**Raises:**\n\n * Exception: If the handlers are not initialized\n\n**Returns:**\n\n * np.ndarray: measured joint forces and torques. Shape is (num\\_joint + 1, 6). Row index 0 is the incoming\n    joint of the base link. For the last dimension the first 3 values are for forces and the last 3 for torques\n\n---\n**Example:**\n\n```python\n>>> # get all measured joint forces and torques\n>>> prim.get_measured_joint_forces()\n[[ 0.0000000e+00  0.0000000e+00  0.0000000e+00  0.0000000e+00  0.0000000e+00  0.0000000e+00]\n [ 1.4995076e+02  4.2574748e-06  5.6364370e-04  4.8701895e-05 -6.9072924e+00  3.1881387e-05]\n [-2.8971717e-05 -1.0677823e+02 -6.8384506e+01 -6.9072924e+00 -5.4927128e-05  6.1222494e-07]\n [ 8.7120995e+01 -4.3871860e-05 -5.5795174e+01  5.3687054e-05 -2.4538563e+01  1.3333466e-05]\n [ 5.3519474e-05 -4.8109909e+01  6.0709282e+01  1.9157074e+01 -5.9258469e-05  8.2744418e-07]\n [-3.1691040e+01  2.3313689e-04  3.9990173e+01 -5.8968733e-05 -1.1863431e+00  2.2335558e-05]\n [-1.0809851e-04  1.5340537e+01 -1.5458489e+01  1.1863426e+00  6.1094368e-05 -1.5940281e-05]\n [-7.5418940e+00 -5.0814648e+00 -5.6512990e+00 -5.6385466e-05  3.8859999e-01 -3.4943256e-01]\n [ 4.7421460e+00 -3.1945827e+00  3.5528181e+00  5.5852943e-05  8.4794536e-03  7.6405057e-03]\n [ 4.0760727e+00  2.1640673e-01 -4.0513167e+00 -5.9565349e-04  1.1407082e-02  2.1432268e-06]\n [ 5.1680198e-03 -9.7754575e-02 -9.7093947e-02 -8.4155556e-12 -1.2910691e-12 -1.9347857e-11]\n [-5.1910793e-03  9.7588278e-02 -9.7106412e-02  8.4155573e-12  1.2910637e-12 -1.9347855e-11]]\n>>>\n>>> # get measured joint force and torque for the fingers\n>>> metadata = prim._articulation_view._metadata\n>>> joint_indices = 1 + np.array([\n...     metadata.joint_indices[\"panda_finger_joint1\"],\n...     metadata.joint_indices[\"panda_finger_joint2\"],\n... ])\n>>> joint_indices\n[10 11]\n>>> prim.get_measured_joint_forces(joint_indices)\n[[ 5.1680198e-03 -9.7754575e-02 -9.7093947e-02 -8.4155556e-12 -1.2910691e-12 -1.9347857e-11]\n [-5.1910793e-03  9.7588278e-02 -9.7106412e-02  8.4155573e-12  1.2910637e-12 -1.9347855e-11]]\n```\n",
"snippet":"measured_joint_forces = robot.get_measured_joint_forces()\n",
"category":"method"
},
{
"title":"get_sleep_threshold",
"description":"Get the threshold for articulations to enter a sleep state\n\nSearch for *Articulations and Sleeping* in for more details\n\n**Returns:**\n\n * float: sleep threshold\n\n---\n**Example:**\n\n```python\n>>> prim.get_sleep_threshold()\n0.005\n```\n",
"snippet":"sleep_threshold = robot.get_sleep_threshold()\n",
"category":"method"
},
{
"title":"get_solver_position_iteration_count",
"description":"Get the solver (position) iteration count for the articulation\n\nThe solver iteration count determines how accurately contacts, drives, and limits are resolved.\nSearch for *Solver Iteration Count* in for more details.\n\n**Returns:**\n\n * int: position iteration count\n\n---\n**Example:**\n\n```python\n>>> prim.get_solver_position_iteration_count()\n32\n```\n",
"snippet":"solver_position_iteration_count = robot.get_solver_position_iteration_count()\n",
"category":"method"
},
{
"title":"get_solver_velocity_iteration_count",
"description":"Get the solver (velocity) iteration count for the articulation\n\nThe solver iteration count determines how accurately contacts, drives, and limits are resolved.\nSearch for *Solver Iteration Count* in for more details.\n\n**Returns:**\n\n * int: velocity iteration count\n\n---\n**Example:**\n\n```python\n>>> prim.get_solver_velocity_iteration_count()\n32\n```\n",
"snippet":"solver_velocity_iteration_count = robot.get_solver_velocity_iteration_count()\n",
"category":"method"
},
{
"title":"get_stabilization_threshold",
"description":"Get the mass-normalized kinetic energy below which the articulation may participate in stabilization\n\nSearch for *Stabilization Threshold* in for more details\n\n**Returns:**\n\n * float: stabilization threshold\n\n---\n**Example:**\n\n```python\n>>> prim.get_stabilization_threshold()\n0.0009999999\n```\n",
"snippet":"stabilization_threshold = robot.get_stabilization_threshold()\n",
"category":"method"
},
{
"title":"get_visibility",
"description":"**Returns:**\n\n * bool: true if the prim is visible in stage. false otherwise.\n\n---\n**Example:**\n\n```python\n>>> # get the visible state of an visible prim on the stage\n>>> prim.get_visibility()\nTrue\n```\n",
"snippet":"visibility = robot.get_visibility()\n",
"category":"method"
},
{
"title":"get_world_pose",
"description":"Get prim's pose with respect to the world's frame\n\n**Returns:**\n\n * Tuple\\[np.ndarray, np.ndarray\\]: first index is the position in the world frame (with shape (3, )).\n    Second index is quaternion orientation (with shape (4, )) in the world frame\n\n---\n**Example:**\n\n```python\n>>> # if the prim is in position (1.0, 0.5, 0.0) with respect to the world frame\n>>> position, orientation = prim.get_world_pose()\n>>> position\n[1.  0.5 0. ]\n>>> orientation\n[1. 0. 0. 0.]\n```\n",
"snippet":"world_pose = robot.get_world_pose()\n",
"category":"method"
},
{
"title":"get_world_scale",
"description":"Get prim's scale with respect to the world's frame\n\n**Returns:**\n\n * np.ndarray: scale applied to the prim's dimensions in the world frame. shape is (3, ).\n\n---\n**Example:**\n\n```python\n>>> prim.get_world_scale()\n[1. 1. 1.]\n```\n",
"snippet":"world_scale = robot.get_world_scale()\n",
"category":"method"
},
{
"title":"initialize",
"description":"Create a physics simulation view if not passed and an articulation view using PhysX tensor API\n\n*Note:*\nIf the articulation has been added to the world scene (e.g., `world.scene.add(prim)`),\nit will be automatically initialized when the world is reset (e.g., `world.reset()`).\n\n*Warning:*\nThis method needs to be called after each hard reset (e.g., Stop + Play on the timeline)\nbefore interacting with any other class method.\n\n**Args:**\n\n * `physics_sim_view` (omni.physics.tensors.SimulationView, optional): current physics simulation view. Defaults to None.\n\n---\n**Example:**\n\n```python\n>>> prim.initialize()\n```\n",
"snippet":"robot.initialize()\n",
"category":"method"
},
{
"title":"initialize",
"description":"Create a physics simulation view if not passed and using PhysX tensor API\n\n*Note:*\nIf the prim has been added to the world scene (e.g., `world.scene.add(prim)`),\nit will be automatically initialized when the world is reset (e.g., `world.reset()`).\n\n**Args:**\n\n * `physics_sim_view` (omni.physics.tensors.SimulationView, optional): current physics simulation view. Defaults to None.\n\n---\n**Example:**\n\n```python\n>>> prim.initialize()\n```\n",
"snippet":"robot.initialize()\n",
"category":"method"
},
{
"title":"is_valid",
"description":"Check if the prim path has a valid USD Prim at it\n\n**Returns:**\n\n * bool: True is the current prim path corresponds to a valid prim in stage. False otherwise.\n\n---\n**Example:**\n\n```python\n>>> # given an existing and valid prim\n>>> prims.is_valid()\nTrue\n```\n",
"snippet":"value = robot.is_valid()\n",
"category":"method"
},
{
"title":"is_visual_material_applied",
"description":"Check if there is a visual material applied\n\n**Returns:**\n\n * bool: True if there is a visual material applied. False otherwise.\n\n---\n**Example:**\n\n```python\n>>> # given a visual material applied\n>>> prim.is_visual_material_applied()\nTrue\n```\n",
"snippet":"value = robot.is_visual_material_applied()\n",
"category":"method"
},
{
"title":"post_reset",
"description":"Reset the robot to its default state\n\n*Note:*\nFor a robot, in addition to configuring the root prim's default position and spatial orientation\n(defined via the `set_default_state` method), the joint's positions, velocities, and efforts\n(defined via the `set_joints_default_state` method) are imposed\n\n---\n**Example:**\n\n```python\n>>> prim.post_reset()\n```\n",
"snippet":"robot.post_reset()\n",
"category":"method"
},
{
"title":"post_reset",
"description":"Reset the prim to its default state (position and orientation).\n\n*Note:*\nFor an articulation, in addition to configuring the root prim's default position and spatial orientation\n(defined via the `set_default_state` method), the joint's positions, velocities, and efforts\n(defined via the `set_joints_default_state` method) are imposed\n\n---\n**Example:**\n\n```python\n>>> prim.post_reset()\n```\n",
"snippet":"robot.post_reset()\n",
"category":"method"
},
{
"title":"set_angular_velocity",
"description":"Set the angular velocity of the root articulation prim\n\n*Warning:*\nThis method will immediately set the articulation state\n\n**Args:**\n\n * `velocity` (np.ndarray): 3D angular velocity vector. Shape (3,)\n\n*Hint:*\nThis method belongs to the methods used to set the articulation kinematic state:\n\n> `set_linear_velocity`, `set_angular_velocity`, `set_joint_positions`,\n> `set_joint_velocities`, `set_joint_efforts`\n\n---\n**Example:**\n\n```python\n>>> prim.set_angular_velocity(np.array([0.1, 0.0, 0.0]))\n```\n",
"snippet":"robot.set_angular_velocity(velocity=velocity)\n",
"category":"method"
},
{
"title":"set_default_state",
"description":"Set the default state of the prim (position and orientation), that will be used after each reset.\n\n**Args:**\n\n * `position` (Optional\\[Sequence\\[float\\]\\], optional): position in the world frame of the prim. shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the world frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n\n---\n**Example:**\n\n```python\n>>> # configure default state\n>>> prim.set_default_state(position=np.array([1.0, 0.5, 0.0]), orientation=np.array([1, 0, 0, 0]))\n>>>\n>>> # set default states during post-reset\n>>> prim.post_reset()\n```\n",
"snippet":"robot.set_default_state()\n",
"category":"method"
},
{
"title":"set_enabled_self_collisions",
"description":"Set the enable self collisions flag (`physxArticulation:enabledSelfCollisions`)\n\n**Args:**\n\n * `flag` (bool): whether to enable self collisions\n\n---\n**Example:**\n\n```python\n>>> prim.set_enabled_self_collisions(True)\n```\n",
"snippet":"robot.set_enabled_self_collisions(flag=flag)\n",
"category":"method"
},
{
"title":"set_joint_efforts",
"description":"Set the articulation joint efforts\n\n*Note:*\nThis method can be used for effort control. For this purpose, there must be no joint drive\nor the stiffness and damping must be set to zero.\n\n**Args:**\n\n * `efforts` (np.ndarray): articulation joint efforts\n * `joint_indices` (Optional\\[Union\\[list, np.ndarray\\]\\], optional): indices to specify which joints to manipulate. Defaults to None (all joints)\n\n*Hint:*\nThis method belongs to the methods used to set the articulation kinematic state:\n\n> `set_linear_velocity`, `set_angular_velocity`, `set_joint_positions`,\n> `set_joint_velocities`, `set_joint_efforts`\n\n---\n**Example:**\n\n```python\n>>> # set all the robot joint efforts to 0.0\n>>> prim.set_joint_efforts(np.array([0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]))\n>>>\n>>> # set only the fingers efforts: panda_finger_joint1 (7) and panda_finger_joint2 (8) to 10\n>>> prim.set_joint_efforts(np.array([10, 10]), joint_indices=np.array([7, 8]))\n```\n",
"snippet":"robot.set_joint_efforts(efforts=efforts)\n",
"category":"method"
},
{
"title":"set_joint_positions",
"description":"Set the articulation joint positions\n\n*Warning:*\nThis method will immediately set (teleport) the affected joints to the indicated value.\nUse the `apply_action` method to control robot joints.\n\n**Args:**\n\n * `positions` (np.ndarray): articulation joint positions\n * `joint_indices` (Optional\\[Union\\[list, np.ndarray\\]\\], optional): indices to specify which joints to manipulate. Defaults to None (all joints)\n\n*Hint:*\nThis method belongs to the methods used to set the articulation kinematic state:\n\n> `set_linear_velocity`, `set_angular_velocity`, `set_joint_positions`,\n> `set_joint_velocities`, `set_joint_efforts`\n\n---\n**Example:**\n\n```python\n>>> # set all the robot joints\n>>> prim.set_joint_positions(np.array([0.0, -1.0, 0.0, -2.2, 0.0, 2.4, 0.8, 0.04, 0.04]))\n>>>\n>>> # set only the fingers in closed position: panda_finger_joint1 (7) and panda_finger_joint2 (8) to 0.0\n>>> prim.set_joint_positions(np.array([0.04, 0.04]), joint_indices=np.array([7, 8]))\n```\n",
"snippet":"robot.set_joint_positions(positions=positions)\n",
"category":"method"
},
{
"title":"set_joint_velocities",
"description":"Set the articulation joint velocities\n\n*Warning:*\nThis method will immediately set the affected joints to the indicated value.\nUse the `apply_action` method to control robot joints.\n\n**Args:**\n\n * `velocities` (np.ndarray): articulation joint velocities\n * `joint_indices` (Optional\\[Union\\[list, np.ndarray\\]\\], optional): indices to specify which joints to manipulate. Defaults to None (all joints)\n\n*Hint:*\nThis method belongs to the methods used to set the articulation kinematic state:\n\n> `set_linear_velocity`, `set_angular_velocity`, `set_joint_positions`,\n> `set_joint_velocities`, `set_joint_efforts`\n\n---\n**Example:**\n\n```python\n>>> # set all the robot joint velocities to 0.0\n>>> prim.set_joint_velocities(np.array([0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]))\n>>>\n>>> # set only the fingers velocities: panda_finger_joint1 (7) and panda_finger_joint2 (8) to -0.01\n>>> prim.set_joint_velocities(np.array([-0.01, -0.01]), joint_indices=np.array([7, 8]))\n```\n",
"snippet":"robot.set_joint_velocities(velocities=velocities)\n",
"category":"method"
},
{
"title":"set_joints_default_state",
"description":"Set the joint default states (positions, velocities and/or efforts) to be applied after each reset.\n\n*Note:*\nThe default states will be set during post-reset (e.g., calling `.post_reset()` or `world.reset()` methods)\n\n**Args:**\n\n * `positions` (Optional\\[np.ndarray\\], optional): joint positions. Defaults to None.\n * `velocities` (Optional\\[np.ndarray\\], optional): joint velocities. Defaults to None.\n * `efforts` (Optional\\[np.ndarray\\], optional): joint efforts. Defaults to None.\n\n---\n**Example:**\n\n```python\n>>> # configure default joint states\n>>> prim.set_joints_default_state(\n...     positions=np.array([0.0, -1.0, 0.0, -2.2, 0.0, 2.4, 0.8, 0.04, 0.04]),\n...     velocities=np.zeros(shape=(prim.num_dof,)),\n...     efforts=np.zeros(shape=(prim.num_dof,))\n... )\n>>>\n>>> # set default states during post-reset\n>>> prim.post_reset()\n```\n",
"snippet":"robot.set_joints_default_state()\n",
"category":"method"
},
{
"title":"set_linear_velocity",
"description":"Set the linear velocity of the root articulation prim\n\n*Warning:*\nThis method will immediately set the articulation state\n\n**Args:**\n\n * `velocity` (np.ndarray): 3D linear velocity vector. Shape (3,).\n\n*Hint:*\nThis method belongs to the methods used to set the articulation kinematic state:\n\n> `set_linear_velocity`, `set_angular_velocity`, `set_joint_positions`,\n> `set_joint_velocities`, `set_joint_efforts`\n\n---\n**Example:**\n\n```python\n>>> prim.set_linear_velocity(np.array([0.1, 0.0, 0.0]))\n```\n",
"snippet":"robot.set_linear_velocity(velocity=velocity)\n",
"category":"method"
},
{
"title":"set_local_pose",
"description":"Set prim's pose with respect to the local frame (the prim's parent frame).\n\n*Warning:*\nThis method will change (teleport) the prim pose immediately to the indicated value\n\n**Args:**\n\n * `translation` (Optional\\[Sequence\\[float\\]\\], optional): translation in the local frame of the prim (with respect to its parent prim). shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the local frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n\n*Hint:*\nThis method belongs to the methods used to set the prim state\n\n---\n**Example:**\n\n```python\n>>> prim.set_local_pose(translation=np.array([1.0, 0.5, 0.0]), orientation=np.array([1., 0., 0., 0.]))\n```\n",
"snippet":"robot.set_local_pose()\n",
"category":"method"
},
{
"title":"set_local_scale",
"description":"Set prim's scale with respect to the local frame (the prim's parent frame).\n\n**Args:**\n\n * `scale` (Optional\\[Sequence\\[float\\]\\]): scale to be applied to the prim's dimensions. shape is (3, ). Defaults to None, which means left unchanged.\n\n---\n**Example:**\n\n```python\n>>> # scale prim 10 times smaller\n>>> prim.set_local_scale(np.array([0.1, 0.1, 0.1]))\n```\n",
"snippet":"robot.set_local_scale(scale=scale)\n",
"category":"method"
},
{
"title":"set_sleep_threshold",
"description":"Set the threshold for articulations to enter a sleep state\n\nSearch for *Articulations and Sleeping* in for more details\n\n**Args:**\n\n * `threshold` (float): sleep threshold\n\n---\n**Example:**\n\n```python\n>>> prim.set_sleep_threshold(0.01)\n```\n",
"snippet":"robot.set_sleep_threshold(threshold=threshold)\n",
"category":"method"
},
{
"title":"set_solver_position_iteration_count",
"description":"Set the solver (position) iteration count for the articulation\n\nThe solver iteration count determines how accurately contacts, drives, and limits are resolved.\nSearch for *Solver Iteration Count* in for more details.\n\n*Warning:*\nSetting a higher number of iterations may improve the fidelity of the simulation, although it may affect its performance.\n\n**Args:**\n\n * `count` (int): position iteration count\n\n---\n**Example:**\n\n```python\n>>> prim.set_solver_position_iteration_count(64)\n```\n",
"snippet":"robot.set_solver_position_iteration_count(count=count)\n",
"category":"method"
},
{
"title":"set_solver_velocity_iteration_count",
"description":"Set the solver (velocity) iteration count for the articulation\n\nThe solver iteration count determines how accurately contacts, drives, and limits are resolved.\nSearch for *Solver Iteration Count* in for more details.\n\n*Warning:*\nSetting a higher number of iterations may improve the fidelity of the simulation, although it may affect its performance.\n\n**Args:**\n\n * `count` (int): velocity iteration count\n\n---\n**Example:**\n\n```python\n>>> prim.set_solver_velocity_iteration_count(64)\n```\n",
"snippet":"robot.set_solver_velocity_iteration_count(count=count)\n",
"category":"method"
},
{
"title":"set_stabilization_threshold",
"description":"Set the mass-normalized kinetic energy below which the articulation may participate in stabilization\n\nSearch for *Stabilization Threshold* in for more details\n\n**Args:**\n\n * `threshold` (float): stabilization threshold\n\n---\n**Example:**\n\n```python\n>>> prim.set_stabilization_threshold(0.005)\n```\n",
"snippet":"robot.set_stabilization_threshold(threshold=threshold)\n",
"category":"method"
},
{
"title":"set_visibility",
"description":"Set the visibility of the prim in stage\n\n**Args:**\n\n * `visible` (bool): flag to set the visibility of the usd prim in stage.\n\n---\n**Example:**\n\n```python\n>>> # make prim not visible in the stage\n>>> prim.set_visibility(visible=False)\n```\n",
"snippet":"robot.set_visibility(visible=visible)\n",
"category":"method"
},
{
"title":"set_world_pose",
"description":"Ses prim's pose with respect to the world's frame\n\n*Warning:*\nThis method will change (teleport) the prim pose immediately to the indicated value\n\n**Args:**\n\n * `position` (Optional\\[Sequence\\[float\\]\\], optional): position in the world frame of the prim. shape is (3, ). Defaults to None, which means left unchanged.\n * `orientation` (Optional\\[Sequence\\[float\\]\\], optional): quaternion orientation in the world frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (4, ). Defaults to None, which means left unchanged.\n\n*Hint:*\nThis method belongs to the methods used to set the prim state\n\n---\n**Example:**\n\n```python\n>>> prim.set_world_pose(position=np.array([1.0, 0.5, 0.0]), orientation=np.array([1., 0., 0., 0.]))\n```\n",
"snippet":"robot.set_world_pose()\n",
"category":"method"
}
]
},
{
"title":"RobotView",
"snippets":[
{
"title":"import ...",
"description":"Import class",
"snippet":"from omni.isaac.core.robots import RobotView\n",
"category":"import"
},
{
"title":"RobotView",
"description":"Implementation (on `ArticulationView` class) to deal with articulation prims as robots\n\nThis class wraps all matching articulations found at the regex provided at the `prim_paths_expr` argument\n\n*Warning:*\nThe robot (articulation) view object must be initialized in order to be able to operate on it.\nSee the `initialize` method for more details.\n\n**Args:**\n\n * `prim_paths_expr` (str): prim paths regex to encapsulate all prims that match it. example: \"/World/Env\\[1-5\\]/Franka\" will match /World/Env1/Franka, /World/Env2/Franka, etc. (a non regex prim path can also be used to encapsulate one rigid prim).\n * `name` (str, optional): shortname to be used as a key by Scene class. Note: needs to be unique if the object is added to the Scene. Defaults to \"rigid\\_prim\\_view\".\n * `positions` (Optional\\[Union\\[np.ndarray, torch.Tensor\\]\\], optional): default positions in the world frame of the prims. shape is (N, 3). Defaults to None, which means left unchanged.\n * `translations` (Optional\\[Union\\[np.ndarray, torch.Tensor\\]\\], optional): default translations in the local frame of the prims (with respect to its parent prims). shape is (N, 3). Defaults to None, which means left unchanged.\n * `orientations` (Optional\\[Union\\[np.ndarray, torch.Tensor\\]\\], optional): default quaternion orientations in the world/ local frame of the prims (depends if translation or position is specified). quaternion is scalar-first (w, x, y, z). shape is (N, 4).\n * `scales` (Optional\\[Union\\[np.ndarray, torch.Tensor\\]\\], optional): local scales to be applied to the prim's dimensions in the view. shape is (N, 3). Defaults to None, which means left unchanged.\n * `visibilities` (Optional\\[Union\\[np.ndarray, torch.Tensor\\]\\], optional): set to false for an invisible prim in the stage while rendering. shape is (N,). Defaults to None.\n\n---\n**Example:**\n\n```python\n>>> import omni.isaac.core.utils.stage as stage_utils\n>>> from omni.isaac.cloner import GridCloner\n>>> from omni.isaac.core.robots import RobotView\n>>> from pxr import UsdGeom\n>>>\n>>> usd_path = \"/home/<user>/Documents/Assets/Robots/Franka/franka_alt_fingers.usd\"\n>>> env_zero_path = \"/World/envs/env_0\"\n>>> num_envs = 5\n>>>\n>>> # load the Franka Panda robot USD file\n>>> stage_utils.add_reference_to_stage(usd_path, prim_path=f\"{env_zero_path}/panda\")  # /World/envs/env_0/panda\n>>>\n>>> # clone the environment (num_envs)\n>>> cloner = GridCloner(spacing=1.5)\n>>> cloner.define_base_env(env_zero_path)\n>>> UsdGeom.Xform.Define(stage_utils.get_current_stage(), env_zero_path)\n>>> cloner.clone(source_prim_path=env_zero_path, prim_paths=cloner.generate_paths(\"/World/envs/env\", num_envs))\n>>>\n>>> # wrap all robots\n>>> prims = RobotView(prim_paths_expr=\"/World/envs/env.*/panda\", name=\"franka_panda_view\")\n>>> print(prims)\n<omni.isaac.core.robots.robot_view.RobotView object at 0x7f12785a5fc0>\n```\n",
"snippet":"robot_view = RobotView(prim_paths_expr=prim_paths_expr)\n",
"category":"class"
},
{
"title":"apply_action",
"description":"Apply joint positions (targets), velocities (targets) and/or efforts to control an articulation\n\n*Note:*\nThis method can be used instead of the separate `set_joint_position_targets`,\n`set_joint_velocity_targets` and `set_joint_efforts`\n\n**Args:**\n\n * `control_actions` (ArticulationActions): actions to be applied for next physics step.\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n*Hint:*\nHigh stiffness makes the joints snap faster and harder to the desired target,\nand higher damping smoothes but also slows down the joint's movement to target\n\n * For position control, set relatively high stiffness and low damping (to reduce vibrations)\n * For velocity control, stiffness must be set to zero with a non-zero damping\n * For effort control, stiffness and damping must be set to zero\n\n---\n**Example:**\n\n```python\n>>> from omni.isaac.core.utils.types import ArticulationActions\n>>>\n>>> # move all the articulation joints to the indicated position.\n>>> # Since there are 5 envs, the joint positions are repeated 5 times\n>>> positions = np.tile(np.array([0.0, -1.0, 0.0, -2.2, 0.0, 2.4, 0.8, 0.04, 0.04]), (num_envs, 1))\n>>> action = ArticulationActions(joint_positions=positions)\n>>> prims.apply_action(action)\n>>>\n>>> # close the robot fingers: panda_finger_joint1 (7) and panda_finger_joint2 (8) to 0.0\n>>> # for the first, middle and last of the 5 envs\n>>> positions = np.tile(np.array([0.0, 0.0]), (3, 1))\n>>> action = ArticulationActions(joint_positions=positions, joint_indices=np.array([7, 8]))\n>>> prims.apply_action(action, indices=np.array([0, 2, 4]))\n```\n",
"snippet":"robot_view.apply_action(control_actions=control_actions)\n",
"category":"method"
},
{
"title":"apply_visual_materials",
"description":"Apply visual material to the prims and optionally their prim descendants.\n\n**Args:**\n\n * `visual_materials` (Union\\[VisualMaterial, List\\[VisualMaterial\\]\\]): visual materials to be applied to the prims. Currently supports PreviewSurface, OmniPBR and OmniGlass. If a list is provided then its size has to be equal the view's size or indices size. If one material is provided it will be applied to all prims in the view.\n * `weaker_than_descendants` (Optional\\[Union\\[bool, List\\[bool\\]\\]\\], optional): True if the material shouldn't override the descendants materials, otherwise False. Defaults to False. If a list of visual materials is provided then a list has to be provided with the same size for this arg as well.\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Raises:**\n\n * Exception: length of visual materials != length of prims indexed\n    Exception: length of visual materials != length of weaker descendants bools arg\n\n---\n**Example:**\n\n```python\n>>> from omni.isaac.core.materials import OmniGlass\n>>>\n>>> # create a dark-red glass visual material\n>>> material = OmniGlass(\n...     prim_path=\"/World/material/glass\",  # path to the material prim to create\n...     ior=1.25,\n...     depth=0.001,\n...     thin_walled=False,\n...     color=np.array([0.5, 0.0, 0.0])\n... )\n>>> prims.apply_visual_materials(material)\n```\n",
"snippet":"robot_view.apply_visual_materials(visual_materials=visual_materials)\n",
"category":"method"
},
{
"title":"get_angular_velocities",
"description":"Get the angular velocities of prims in the view.\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view)\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: angular velocities of the prims in the view. shape is (M, 3).\n\n---\n**Example:**\n\n```python\n>>> # get all articulation angular velocities. Returned shape is (5, 3) for the example: 5 envs, angular (3)\n>>> prims.get_angular_velocities()\n[[0. 0. 0.]\n [0. 0. 0.]\n [0. 0. 0.]\n [0. 0. 0.]\n [0. 0. 0.]]\n>>>\n>>> # get only the articulation angular velocities for the first, middle and last of the 5 envs\n>>> # Returned shape is (5, 3) for the example: 3 envs selected, angular (3)\n>>> prims.get_angular_velocities(indices=np.array([0, 2, 4]))\n[[0. 0. 0.]\n [0. 0. 0.]\n [0. 0. 0.]]\n```\n",
"snippet":"angular_velocities = robot_view.get_angular_velocities()\n",
"category":"method"
},
{
"title":"get_applied_actions",
"description":"Get the last applied actions\n\n**Args:**\n\n * `clone` (bool, optional): True to return clones of the internal buffers. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * ArticulationActions: current applied actions (i.e: current position targets and velocity targets)\n\n---\n**Example:**\n\n```python\n>>> # last applied action: joint_positions -> [0.0, -1.0, 0.0, -2.2, 0.0, 2.4, 0.8, 0.04, 0.04].\n>>> # Returned shape is (5, 9) for the example: 5 envs, 9 DOFs\n>>> actions = prims.get_applied_actions()\n>>> actions\n<omni.isaac.core.utils.types.ArticulationActions object at 0x7f28af31d870>\n>>> actions.joint_positions\n[[ 0.   -1.    0.   -2.2   0.    2.4   0.8   0.04  0.04]\n [ 0.   -1.    0.   -2.2   0.    2.4   0.8   0.04  0.04]\n [ 0.   -1.    0.   -2.2   0.    2.4   0.8   0.04  0.04]\n [ 0.   -1.    0.   -2.2   0.    2.4   0.8   0.04  0.04]\n [ 0.   -1.    0.   -2.2   0.    2.4   0.8   0.04  0.04]]\n>>> actions.joint_velocities\n[[0. 0. 0. 0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0. 0. 0. 0.]]\n>>> actions.joint_efforts\n[[0. 0. 0. 0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0. 0. 0. 0.]]\n```\n",
"snippet":"applied_actions = robot_view.get_applied_actions()\n",
"category":"method"
},
{
"title":"get_applied_joint_efforts",
"description":"Get the joint efforts of articulations in the view\n\nThis method will return the efforts set by the `set_joint_efforts` method\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `joint_indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): joint indices to specify which joints to query. Shape (K,). Where K \\<= num of dofs. Defaults to None (i.e: all dofs).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: joint efforts of articulations in the view. Shape is (M, K).\n\n---\n**Example:**\n\n```python\n>>> # get all applied joint efforts. Returned shape is (5, 9) for the example: 5 envs, 9 DOFs\n>>> prims.get_applied_joint_efforts()\n[[0. 0. 0. 0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0. 0. 0. 0.]]\n>>>\n>>> # get finger applied efforts: panda_finger_joint1 (7) and panda_finger_joint2 (8)\n>>> # for the first, middle and last of the 5 envs. Returned shape is (3, 2)\n>>> prims.get_applied_joint_efforts(indices=np.array([0, 2, 4]), joint_indices=np.array([7, 8]))\n[[0. 0.]\n [0. 0.]\n [0. 0.]]\n```\n",
"snippet":"applied_joint_efforts = robot_view.get_applied_joint_efforts()\n",
"category":"method"
},
{
"title":"get_applied_visual_materials",
"description":"Get the current applied visual materials\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Returns:**\n\n * List\\[VisualMaterial\\]: a list of the current applied visual materials to the prims if its type is currently supported.\n\n---\n**Example:**\n\n```python\n>>> # get all applied visual materials. Returned size is 5 for the example: 5 envs\n>>> prims.get_applied_visual_materials()\n[<omni.isaac.core.materials.omni_glass.OmniGlass object at 0x7f829c165de0>,\n <omni.isaac.core.materials.omni_glass.OmniGlass object at 0x7f829c165de0>,\n <omni.isaac.core.materials.omni_glass.OmniGlass object at 0x7f829c165de0>,\n <omni.isaac.core.materials.omni_glass.OmniGlass object at 0x7f829c165de0>,\n <omni.isaac.core.materials.omni_glass.OmniGlass object at 0x7f829c165de0>]\n>>>\n>>> # get the applied visual materials for the first, middle and last of the 5 envs. Returned size is 3\n>>> prims.get_applied_visual_materials(indices=np.array([0, 2, 4]))\n[<omni.isaac.core.materials.omni_glass.OmniGlass object at 0x7f829c165de0>,\n <omni.isaac.core.materials.omni_glass.OmniGlass object at 0x7f829c165de0>,\n <omni.isaac.core.materials.omni_glass.OmniGlass object at 0x7f829c165de0>]\n```\n",
"snippet":"applied_visual_materials = robot_view.get_applied_visual_materials()\n",
"category":"method"
},
{
"title":"get_armatures",
"description":"Get armatures for articulation joints in the view\n\nSearch for *\"Joint Armature\"* in for more details.\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `joint_indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): joint indices to specify which joints to query. Shape (K,). Where K \\<= num of dofs. Defaults to None (i.e: all dofs).\n * `clone` (Optional\\[bool\\]): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: joint armatures for articulations in the view. shape (M, K).\n\n---\n**Example:**\n\n```python\n>>> # get joint armatures. Returned shape is (5, 9) for the example: 5 envs, 9 DOFs\n>>> prims.get_armatures()\n[[0. 0. 0. 0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0. 0. 0. 0.]]\n>>>\n>>> # get only the finger joint (panda_finger_joint1 (7) and panda_finger_joint2 (8)) armatures\n>>> # for the first, middle and last of the 5 envs. Returned shape is (3, 2)\n>>> prims.get_armatures(indices=np.array([0,2,4]), joint_indices=np.array([7,8]))\n[[0. 0.]\n [0. 0.]\n [0. 0.]]\n```\n",
"snippet":"armatures = robot_view.get_armatures()\n",
"category":"method"
},
{
"title":"get_articulation_body_count",
"description":"Get the number of rigid bodies (links) of the articulations\n\n**Returns:**\n\n * int: maximum number of rigid bodies (links) in the articulation\n\n---\n**Example:**\n\n```python\n>>> prims.get_articulation_body_count()\n12\n```\n",
"snippet":"articulation_body_count = robot_view.get_articulation_body_count()\n",
"category":"method"
},
{
"title":"get_body_coms",
"description":"Get rigid body center of mass (COM) of articulations in the view.\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `body_indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): body indices to specify which bodies to query. Shape (K,). Where K \\<= num of bodies. Defaults to None (i.e: all bodies).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: rigid body center of mass positions and orientations\n    of articulations in the view. Position shape is (M, K, 3), orientation shape is (M, k, 4).\n\n---\n**Example:**\n\n```python\n>>> # get all body center of mass. Returned shape is (5, 12, 3) for positions and (5, 12, 4) for orientations\n>>> # for the example: 5 envs, 12 rigid bodies\n>>> positions, orientations = prims.get_body_coms()\n>>> positions\n[[[0. 0. 0.]\n  [0. 0. 0.]\n  ...\n  [0. 0. 0.]\n  [0. 0. 0.]]]\n>>> orientations\n[[[1. 0. 0. 0.]\n  [1. 0. 0. 0.]\n  ...\n  [1. 0. 0. 0.]\n  [1. 0. 0. 0.]]]\n>>>\n>>> # get finger body center of mass: panda_leftfinger (10) and panda_rightfinger (11) for the first,\n>>> # middle and last of the 5 envs. Returned shape is (3, 2, 3) for positions and (3, 2, 4) for orientations\n>>> positions, orientations = prims.get_body_coms(indices=np.array([0, 2, 4]), body_indices=np.array([10, 11]))\n>>> positions\n[[[0. 0. 0.]\n  [0. 0. 0.]]\n [[0. 0. 0.]\n  [0. 0. 0.]]\n [[0. 0. 0.]\n  [0. 0. 0.]]]\n>>> orientations\n[[[1. 0. 0. 0.]\n  [1. 0. 0. 0.]]\n [[1. 0. 0. 0.]\n  [1. 0. 0. 0.]]\n [[1. 0. 0. 0.]\n  [1. 0. 0. 0.]]]\n```\n",
"snippet":"body_coms = robot_view.get_body_coms()\n",
"category":"method"
},
{
"title":"get_body_index",
"description":"Get a ridig body (link) index in the articulation view given its name\n\n**Args:**\n\n * `body_name` (str): name of the ridig body to query\n\n**Returns:**\n\n * int: index of the rigid body in the articulation buffers\n\n---\n**Example:**\n\n```python\n>>> # get the index of the left finger: panda_leftfinger\n>>> prims.get_body_index(\"panda_leftfinger\")\n10\n```\n",
"snippet":"body_index = robot_view.get_body_index(body_name=body_name)\n",
"category":"method"
},
{
"title":"get_body_inertias",
"description":"Get rigid body inertias of articulations in the view\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `body_indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): body indices to specify which bodies to query. Shape (K,). Where K \\<= num of bodies. Defaults to None (i.e: all bodies).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: rigid body inertias of articulations in the view. Shape is (M, K, 9).\n\n---\n**Example:**\n\n```python\n>>> # get all body inertias. Returned shape is (5, 12, 9) for the example: 5 envs, 12 rigid bodies\n>>> prims.get_body_inertias()\n[[[1.2988697e-06  0.0  0.0  0.0  1.6535528e-06  0.0  0.0  0.0  2.0331163e-06]\n  [1.8686389e-06  0.0  0.0  0.0  1.4378986e-06  0.0  0.0  0.0  9.0681192e-07]\n  ...\n  [4.2041304e-10  0.0  0.0  0.0  3.9026365e-10  0.0  0.0  0.0  1.3347495e-10]\n  [4.2041304e-10  0.0  0.0  0.0  3.9026365e-10  0.0  0.0  0.0  1.3347495e-10]]]\n>>>\n>>> # get finger body inertias: panda_leftfinger (10) and panda_rightfinger (11)\n>>> # for the first, middle and last of the 5 envs. Returned shape is (3, 2, 9)\n>>> prims.get_body_inertias(indices=np.array([0, 2, 4]), body_indices=np.array([10, 11]))\n[[[4.2041304e-10  0.0  0.0  0.0  3.9026365e-10  0.0  0.0  0.0  1.3347495e-10]\n  [4.2041304e-10  0.0  0.0  0.0  3.9026365e-10  0.0  0.0  0.0  1.3347495e-10]]\n ...\n [[4.2041304e-10  0.0  0.0  0.0  3.9026365e-10  0.0  0.0  0.0  1.3347495e-10]\n  [4.2041304e-10  0.0  0.0  0.0  3.9026365e-10  0.0  0.0  0.0  1.3347495e-10]]]\n```\n",
"snippet":"body_inertias = robot_view.get_body_inertias()\n",
"category":"method"
},
{
"title":"get_body_inv_inertias",
"description":"Get rigid body inverse inertias of articulations in the view\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `body_indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): body indices to specify which bodies to query. Shape (K,). Where K \\<= num of bodies. Defaults to None (i.e: all bodies).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: rigid body inverse inertias of articulations in the view.\n    Shape is (M, K, 9).\n\n---\n**Example:**\n\n```python\n>>> # get all body inverse inertias. Returned shape is (5, 12, 9) for the example: 5 envs, 12 rigid bodies\n>>> prims.get_body_inv_inertias()\n[[[7.6990012e+05  0.0  0.0  0.0  6.0475844e+05  0.0  0.0  0.0  4.9185578e+05]\n  [5.3514888e+05  0.0  0.0  0.0  6.9545931e+05  0.0  0.0  0.0  1.1027645e+06]\n  ...\n  [2.3786132e+09  0.0  0.0  0.0  2.5623703e+09  0.0  0.0  0.0  7.4920422e+09]\n  [2.3786132e+09  0.0  0.0  0.0  2.5623703e+09  0.0  0.0  0.0  7.4920422e+09]]]\n>>>\n>>> # get finger body inverse inertias: panda_leftfinger (10) and panda_rightfinger (11)\n>>> # for the first, middle and last of the 5 envs. Returned shape is (3, 2, 9)\n>>> prims.get_body_inv_inertias(indices=np.array([0, 2, 4]), body_indices=np.array([10, 11]))\n[[[2.3786132e+09  0.0  0.0  0.0  2.5623703e+09  0.0  0.0  0.0  7.4920422e+09]\n  [2.3786132e+09  0.0  0.0  0.0  2.5623703e+09  0.0  0.0  0.0  7.4920422e+09]]\n ...\n [[2.3786132e+09  0.0  0.0  0.0  2.5623703e+09  0.0  0.0  0.0  7.4920422e+09]\n  [2.3786132e+09  0.0  0.0  0.0  2.5623703e+09  0.0  0.0  0.0  7.4920422e+09]]]\n```\n",
"snippet":"body_inv_inertias = robot_view.get_body_inv_inertias()\n",
"category":"method"
},
{
"title":"get_body_inv_masses",
"description":"Get rigid body inverse masses of articulations in the view\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `body_indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): body indices to specify which bodies to query. Shape (K,). Where K \\<= num of bodies. Defaults to None (i.e: all bodies).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: rigid body inverse masses of articulations in the view.\n    Shape is (M, K).\n\n---\n**Example:**\n\n```python\n>>> # get all body inverse masses. Returned shape is (5, 12) for the example: 5 envs, 12 rigid bodies\n>>> prims.get_body_inv_masses()\n[[ 0.35534042  0.42372888  0.42025304  0.37737525  0.3710848  0.33542618  0.8860687\n   2.4673615  10. 1.7910539  71.14793  71.14793]\n [ 0.35534042  0.42372888  0.42025304  0.37737525  0.3710848  0.33542618  0.8860687\n   2.4673615  10. 1.7910539  71.14793  71.14793]\n [ 0.35534042  0.42372888  0.42025304  0.37737525  0.3710848  0.33542618  0.8860687\n   2.4673615  10. 1.7910539  71.14793  71.14793]\n [ 0.35534042  0.42372888  0.42025304  0.37737525  0.3710848  0.33542618  0.8860687\n   2.4673615  10. 1.7910539  71.14793  71.14793]\n [ 0.35534042  0.42372888  0.42025304  0.37737525  0.3710848  0.33542618  0.8860687\n   2.4673615  10. 1.7910539  71.14793  71.14793]]\n>>>\n>>> # get finger body inverse masses: panda_leftfinger (10) and panda_rightfinger (11)\n>>> # for the first, middle and last of the 5 envs. Returned shape is (3, 2)\n>>> prims.get_body_inv_masses(indices=np.array([0, 2, 4]), body_indices=np.array([10, 11]))\n[[71.14793 71.14793]\n [71.14793 71.14793]\n [71.14793 71.14793]]\n```\n",
"snippet":"body_inv_masses = robot_view.get_body_inv_masses()\n",
"category":"method"
},
{
"title":"get_body_masses",
"description":"Get rigid body masses of articulations in the view\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `body_indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): body indices to specify which bodies to query. Shape (K,). Where K \\<= num of bodies. Defaults to None (i.e: all bodies).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: rigid body masses of articulations in the view.\n    Shape is (M, K).\n\n---\n**Example:**\n\n```python\n>>> # get all body masses. Returned shape is (5, 12) for the example: 5 envs, 12 rigid bodies\n>>> prims.get_body_masses()\n[[2.8142028  2.3599997  2.3795187  2.6498823  2.6948018  2.981282\n  1.1285807  0.40529126 0.1  0.5583305  0.01405522 0.01405522]\n [2.8142028  2.3599997  2.3795187  2.6498823  2.6948018  2.981282\n  1.1285807  0.40529126 0.1  0.5583305  0.01405522 0.01405522]\n [2.8142028  2.3599997  2.3795187  2.6498823  2.6948018  2.981282\n  1.1285807  0.40529126 0.1  0.5583305  0.01405522 0.01405522]\n [2.8142028  2.3599997  2.3795187  2.6498823  2.6948018  2.981282\n  1.1285807  0.40529126 0.1  0.5583305  0.01405522 0.01405522]\n [2.8142028  2.3599997  2.3795187  2.6498823  2.6948018  2.981282\n  1.1285807  0.40529126 0.1  0.5583305  0.01405522 0.01405522]]\n>>>\n>>> # get finger body masses: panda_leftfinger (10) and panda_rightfinger (11)\n>>> # for the first, middle and last of the 5 envs. Returned shape is (3, 2)\n>>> prims.get_body_masses(indices=np.array([0, 2, 4]), body_indices=np.array([10, 11]))\n[[0.01405522 0.01405522]\n [0.01405522 0.01405522]\n [0.01405522 0.01405522]]\n```\n",
"snippet":"body_masses = robot_view.get_body_masses()\n",
"category":"method"
},
{
"title":"get_coriolis_and_centrifugal_forces",
"description":"Get the Coriolis and centrifugal forces (joint DOF forces required to counteract Coriolis and\ncentrifugal forces for the given articulation state) of articulations in the view\n\nSearch for *Coriolis and Centrifugal Forces* in for more details\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `joint_indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): joint indices to specify which joints to query. Shape (K,). Where K \\<= num of dofs. Defaults to None (i.e: all dofs).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: Coriolis and centrifugal forces of articulations in the view.\n    Shape is (M, K).\n\n---\n**Example:**\n\n```python\n>>> # get all coriolis and centrifugal forces. Returned shape is (5, 9) for the example: 5 envs, 9 DOFs\n>>> prims.get_coriolis_and_centrifugal_forces()\n[[ 1.6842524e-06 -1.8269569e-04  5.2162073e-07 -9.7677548e-05  3.0365106e-07\n   6.7375149e-06  6.1105780e-08 -4.6237556e-06 -4.1627968e-06]\n [ 1.6842524e-06 -1.8269569e-04  5.2162073e-07 -9.7677548e-05  3.0365106e-07\n   6.7375149e-06  6.1105780e-08 -4.6237556e-06 -4.1627968e-06]\n [ 1.6842561e-06 -1.8269687e-04  5.2162375e-07 -9.7677454e-05  3.0365084e-07\n   6.7375931e-06  6.1106007e-08 -4.6237533e-06 -4.1627954e-06]\n [ 1.6842561e-06 -1.8269687e-04  5.2162375e-07 -9.7677454e-05  3.0365084e-07\n   6.7375931e-06  6.1106007e-08 -4.6237533e-06 -4.1627954e-06]\n [ 1.6842524e-06 -1.8269569e-04  5.2162073e-07 -9.7677548e-05  3.0365106e-07\n   6.7375149e-06  6.1105780e-08 -4.6237556e-06 -4.1627968e-06]]\n>>>\n>>> # get finger joint coriolis and centrifugal forces: panda_finger_joint1 (7) and panda_finger_joint2 (8)\n>>> # for the first, middle and last of the 5 envs. Returned shape is (3, 2)\n>>> prims.get_coriolis_and_centrifugal_forces(indices=np.array([0, 2, 4]), joint_indices=np.array([7, 8]))\n[[-4.6237556e-06 -4.1627968e-06]\n [-4.6237533e-06 -4.1627954e-06]\n [-4.6237556e-06 -4.1627968e-06]]\n```\n",
"snippet":"coriolis_and_centrifugal_forces = robot_view.get_coriolis_and_centrifugal_forces()\n",
"category":"method"
},
{
"title":"get_default_state",
"description":"Get the default states (positions and orientations) defined with the `set_default_state` method\n\n**Returns:**\n\n * XFormPrimViewState: returns the default state of the prims that is used after each reset.\n\n---\n**Example:**\n\n```python\n>>> state = prims.get_default_state()\n>>> state\n<omni.isaac.core.utils.types.XFormPrimViewState object at 0x7f82f73e3070>\n>>> state.positions\n[[ 1.5  -0.75  0.  ]\n [ 1.5   0.75  0.  ]\n [ 0.   -0.75  0.  ]\n [ 0.    0.75  0.  ]\n [-1.5  -0.75  0.  ]]\n>>> state.orientations\n[[1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]]\n```\n",
"snippet":"default_state = robot_view.get_default_state()\n",
"category":"method"
},
{
"title":"get_dof_index",
"description":"Get a DOF index in the joint buffers given its name\n\n**Args:**\n\n * `dof_name` (str): name of the joint that corresponds to the degree of freedom to query\n\n**Returns:**\n\n * int: index of the degree of freedom in the joint buffers\n\n---\n**Example:**\n\n```python\n>>> # get the index of the left finger joint: panda_finger_joint1\n>>> prims.get_dof_index(\"panda_finger_joint1\")\n7\n```\n",
"snippet":"dof_index = robot_view.get_dof_index(dof_name=dof_name)\n",
"category":"method"
},
{
"title":"get_dof_limits",
"description":"Get the articulations DOFs limits (lower and upper)\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.array\\]: degrees of freedom position limits.\n    Shape is (N, num\\_dof, 2). For the last dimension, index 0 corresponds to lower limits and index 1 corresponds to upper limits\n\n---\n**Example:**\n\n```python\n>>> # get DOF limits. Returned shape is (5, 9, 2) for the example: 5 envs, 9 DOFs\n>>> prims.get_dof_limits()\n[[[-2.8973  2.8973]\n [-1.7628  1.7628]\n [-2.8973  2.8973]\n [-3.0718 -0.0698]\n [-2.8973  2.8973]\n [-0.0175  3.7525]\n [-2.8973  2.8973]\n [ 0.      0.04  ]\n [ 0.      0.04  ]]\n...\n[[-2.8973  2.8973]\n [-1.7628  1.7628]\n [-2.8973  2.8973]\n [-3.0718 -0.0698]\n [-2.8973  2.8973]\n [-0.0175  3.7525]\n [-2.8973  2.8973]\n [ 0.      0.04  ]\n [ 0.      0.04  ]]]\n```\n",
"snippet":"dof_limits = robot_view.get_dof_limits()\n",
"category":"method"
},
{
"title":"get_dof_types",
"description":"Get the DOF types given the DOF names\n\n**Args:**\n\n * `dof_names` (List\\[str\\], optional): names of the joints that corresponds to the degrees of freedom to query. Defaults to None.\n\n**Returns:**\n\n * List\\[str\\]: types of the joints that corresponds to the degrees of freedom. Types can be invalid, translation or rotation.\n\n---\n**Example:**\n\n```python\n>>> # get all DOF types\n>>> prims.get_dof_types()\n[<DofType.Rotation: 0>, <DofType.Rotation: 0>, <DofType.Rotation: 0>,\n <DofType.Rotation: 0>, <DofType.Rotation: 0>, <DofType.Rotation: 0>,\n <DofType.Rotation: 0>, <DofType.Translation: 1>, <DofType.Translation: 1>]\n>>>\n>>> # get only the finger DOF types: panda_finger_joint1 and panda_finger_joint2\n>>> prims.get_dof_types(dof_names=[\"panda_finger_joint1\", \"panda_finger_joint2\"])\n[<DofType.Translation: 1>, <DofType.Translation: 1>]\n```\n",
"snippet":"dof_types = robot_view.get_dof_types()\n",
"category":"method"
},
{
"title":"get_effort_modes",
"description":"Get effort modes for articulations in the view\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `joint_indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): joint indices to specify which joints to query. Shape (K,). Where K \\<= num of dofs. Defaults to None (i.e: all dofs).\n\n**Returns:**\n\n * List: Returns a List of size (M, K) indicating the effort modes: `acceleration` or `force`\n\n---\n**Example:**\n\n```python\n>>> # get the effort mode for all joints\n>>> prims.get_effort_modes()\n[['acceleration', 'acceleration', 'acceleration', 'acceleration', 'acceleration', 'acceleration', 'acceleration', 'acceleration', 'acceleration'],\n ['acceleration', 'acceleration', 'acceleration', 'acceleration', 'acceleration', 'acceleration', 'acceleration', 'acceleration', 'acceleration'],\n ['acceleration', 'acceleration', 'acceleration', 'acceleration', 'acceleration', 'acceleration', 'acceleration', 'acceleration', 'acceleration'],\n ['acceleration', 'acceleration', 'acceleration', 'acceleration', 'acceleration', 'acceleration', 'acceleration', 'acceleration', 'acceleration'],\n ['acceleration', 'acceleration', 'acceleration', 'acceleration', 'acceleration', 'acceleration', 'acceleration', 'acceleration', 'acceleration']]\n>>>\n>>> # get only the finger joints effort modes for the first, middle and last of the 5 envs\n>>> prims.get_effort_modes(indices=np.array([0, 2, 4]), joint_indices=np.array([7, 8]))\n[['acceleration', 'acceleration'], ['acceleration', 'acceleration'], ['acceleration', 'acceleration']]\n```\n",
"snippet":"effort_modes = robot_view.get_effort_modes()\n",
"category":"method"
},
{
"title":"get_enabled_self_collisions",
"description":"Get the enable self collisions flag (`physxArticulation:enabledSelfCollisions`) for all articulations\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: self collisions flags (boolean interpreted as int). shape (M,)\n\n---\n**Example:**\n\n```python\n>>> # get all self collisions flags. Returned shape is (5,) for the example: 5 envs\n>>> prims.get_enabled_self_collisions()\n[0 0 0 0 0]\n>>>\n>>> # get the self collisions flags for the first, middle and last of the 5 envs. Returned shape is (3,)\n>>> prims.get_enabled_self_collisions(indices=np.array([0, 2, 4]))\n[0 0 0]\n```\n",
"snippet":"enabled_self_collisions = robot_view.get_enabled_self_collisions()\n",
"category":"method"
},
{
"title":"get_fixed_tendon_dampings",
"description":"Get the dampings of fixed tendons for articulations in the view\n\nSearch for *Fixed Tendon* in for more details\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: fixed tendon dampings of articulations in the view.\n    Shape is (M, K).\n\n---\n**Example:**\n\n```python\n>>> # get the fixed tendon dampings\n>>> # for the ShadowHand articulation that has 4 fixed tendons (prims.num_fixed_tendons)\n>>> prims.get_fixed_tendon_dampings()\n[[0. 0. 0. 0.]\n [0. 0. 0. 0.]\n [0. 0. 0. 0.]\n [0. 0. 0. 0.]\n [0. 0. 0. 0.]]\n```\n",
"snippet":"fixed_tendon_dampings = robot_view.get_fixed_tendon_dampings()\n",
"category":"method"
},
{
"title":"get_fixed_tendon_limit_stiffnesses",
"description":"Get the limit stiffness of fixed tendons for articulations in the view\n\nSearch for *Fixed Tendon* in for more details\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: fixed tendon stiffnesses of articulations in the view.\n    Shape is (M, K).\n\n---\n**Example:**\n\n```python\n>>> # get the fixed tendon limit stiffnesses\n>>> # for the ShadowHand articulation that has 4 fixed tendons (prims.num_fixed_tendons)\n>>> prims.get_fixed_tendon_limit_stiffnesses()\n[[0. 0. 0. 0.]\n [0. 0. 0. 0.]\n [0. 0. 0. 0.]\n [0. 0. 0. 0.]\n [0. 0. 0. 0.]]\n```\n",
"snippet":"fixed_tendon_limit_stiffnesses = robot_view.get_fixed_tendon_limit_stiffnesses()\n",
"category":"method"
},
{
"title":"get_fixed_tendon_limits",
"description":"Get the limits of fixed tendons for articulations in the view\n\nSearch for *Fixed Tendon* in for more details\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: fixed tendon stiffnesses of articulations in the view.\n    Shape is (M, K, 2).\n\n---\n**Example:**\n\n```python\n>>> # get the fixed tendon limits\n>>> # for the ShadowHand articulation that has 4 fixed tendons (prims.num_fixed_tendons)\n>>> prims.get_fixed_tendon_limits()\n[[[-0.001  0.001] [-0.001  0.001] [-0.001  0.001] [-0.001  0.001]]\n [[-0.001  0.001] [-0.001  0.001] [-0.001  0.001] [-0.001  0.001]]\n [[-0.001  0.001] [-0.001  0.001] [-0.001  0.001] [-0.001  0.001]]\n [[-0.001  0.001] [-0.001  0.001] [-0.001  0.001] [-0.001  0.001]]\n [[-0.001  0.001] [-0.001  0.001] [-0.001  0.001] [-0.001  0.001]]]\n```\n",
"snippet":"fixed_tendon_limits = robot_view.get_fixed_tendon_limits()\n",
"category":"method"
},
{
"title":"get_fixed_tendon_offsets",
"description":"Get the offsets of fixed tendons for articulations in the view\n\nSearch for *Fixed Tendon* in for more details\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: fixed tendon stiffnesses of articulations in the view.\n    Shape is (M, K).\n\n---\n**Example:**\n\n```python\n>>> # get the fixed tendon offsets\n>>> # for the ShadowHand articulation that has 4 fixed tendons (prims.num_fixed_tendons)\n>>> prims.get_fixed_tendon_offsets()\n[[0. 0. 0. 0.]\n [0. 0. 0. 0.]\n [0. 0. 0. 0.]\n [0. 0. 0. 0.]\n [0. 0. 0. 0.]]\n```\n",
"snippet":"fixed_tendon_offsets = robot_view.get_fixed_tendon_offsets()\n",
"category":"method"
},
{
"title":"get_fixed_tendon_rest_lengths",
"description":"Get the rest length of fixed tendons for articulations in the view\n\nSearch for *Fixed Tendon* in for more details\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: fixed tendon stiffnesses of articulations in the view.\n    Shape is (M, K).\n\n---\n**Example:**\n\n```python\n>>> # get the fixed tendon rest lengths\n>>> # for the ShadowHand articulation that has 4 fixed tendons (prims.num_fixed_tendons)\n>>> prims.get_fixed_tendon_rest_lengths()\n[[0. 0. 0. 0.]\n [0. 0. 0. 0.]\n [0. 0. 0. 0.]\n [0. 0. 0. 0.]\n [0. 0. 0. 0.]]\n```\n",
"snippet":"fixed_tendon_rest_lengths = robot_view.get_fixed_tendon_rest_lengths()\n",
"category":"method"
},
{
"title":"get_fixed_tendon_stiffnesses",
"description":"Get the stiffness of fixed tendons for articulations in the view\n\nSearch for *Fixed Tendon* in for more details\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: fixed tendon stiffnesses of articulations in the view.\n    Shape is (M, K).\n\n---\n**Example:**\n\n```python\n>>> # get the fixed tendon stiffnesses\n>>> # for the ShadowHand articulation that has 4 fixed tendons (prims.num_fixed_tendons)\n>>> prims.get_fixed_tendon_stiffnesses()\n[[0. 0. 0. 0.]\n [0. 0. 0. 0.]\n [0. 0. 0. 0.]\n [0. 0. 0. 0.]\n [0. 0. 0. 0.]]\n```\n",
"snippet":"fixed_tendon_stiffnesses = robot_view.get_fixed_tendon_stiffnesses()\n",
"category":"method"
},
{
"title":"get_friction_coefficients",
"description":"Get the friction coefficients for the articulation joints in the view\n\nSearch for *\"Joint Friction Coefficient\"* in for more details.\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `joint_indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): joint indices to specify which joints to query. Shape (K,). Where K \\<= num of dofs. Defaults to None (i.e: all dofs).\n * `clone` (Optional\\[bool\\]): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: joint friction coefficients for articulations in the view. shape (M, K).\n\n---\n**Example:**\n\n```python\n>>> # get joint friction coefficients. Returned shape is (5, 9) for the example: 5 envs, 9 DOFs\n>>> prims.get_friction_coefficients()\n[[0. 0. 0. 0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0. 0. 0. 0.]]\n>>>\n>>> # get only the finger joint (panda_finger_joint1 (7) and panda_finger_joint2 (8)) friction coefficients\n>>> # for the first, middle and last of the 5 envs. Returned shape is (3, 2)\n>>> prims.get_friction_coefficients(indices=np.array([0,2,4]), joint_indices=np.array([7,8]))\n[[0. 0.]\n [0. 0.]\n [0. 0.]]\n```\n",
"snippet":"friction_coefficients = robot_view.get_friction_coefficients()\n",
"category":"method"
},
{
"title":"get_gains",
"description":"Get the implicit Proportional-Derivative (PD) controller's Kps (stiffnesses) and Kds (dampings) of articulations in the view\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `joint_indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): joint indices to specify which joints to query. Shape (K,). Where K \\<= num of dofs. Defaults to None (i.e: all dofs).\n * `clone` (bool, optional): True to return clones of the internal buffers. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Tuple\\[Union\\[np.ndarray, torch.Tensor\\], Union\\[np.ndarray, torch.Tensor\\], Union\\[wp.indexedarray, wp.index\\]\\]:\n    stiffness and damping of articulations in the view respectively. shapes are (M, K).\n\n---\n**Example:**\n\n```python\n>>> # get all joint stiffness and damping. Returned shape is (5, 9) for the example: 5 envs, 9 DOFs\n>>> stiffnesses, dampings = prims.get_gains()\n>>> stiffnesses\n[[60000. 60000. 60000. 60000. 25000. 15000.  5000.  6000.  6000.]\n [60000. 60000. 60000. 60000. 25000. 15000.  5000.  6000.  6000.]\n [60000. 60000. 60000. 60000. 25000. 15000.  5000.  6000.  6000.]\n [60000. 60000. 60000. 60000. 25000. 15000.  5000.  6000.  6000.]\n [60000. 60000. 60000. 60000. 25000. 15000.  5000.  6000.  6000.]]\n>>> dampings\n[[3000. 3000. 3000. 3000. 3000. 3000. 3000. 1000. 1000.]\n [3000. 3000. 3000. 3000. 3000. 3000. 3000. 1000. 1000.]\n [3000. 3000. 3000. 3000. 3000. 3000. 3000. 1000. 1000.]\n [3000. 3000. 3000. 3000. 3000. 3000. 3000. 1000. 1000.]\n [3000. 3000. 3000. 3000. 3000. 3000. 3000. 1000. 1000.]]\n>>>\n>>> # get finger joints stiffness and damping: panda_finger_joint1 (7) and panda_finger_joint2 (8)\n>>> # for the first, middle and last of the 5 envs. Returned shape is (3, 2)\n>>> stiffnesses, dampings = prims.get_gains(indices=np.array([0, 2, 4]), joint_indices=np.array([7, 8]))\n>>> stiffnesses\n[[6000. 6000.]\n [6000. 6000.]\n [6000. 6000.]]\n>>> dampings\n[[1000. 1000.]\n [1000. 1000.]\n [1000. 1000.]]\n```\n",
"snippet":"gains = robot_view.get_gains()\n",
"category":"method"
},
{
"title":"get_generalized_gravity_forces",
"description":"Get the generalized gravity forces (joint DOF forces required to counteract gravitational\nforces for the given articulation pose) of articulations in the view\n\nSearch for *Generalized Gravity Force* in for more details\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `joint_indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): joint indices to specify which joints to query. Shape (K,). Where K \\<= num of dofs. Defaults to None (i.e: all dofs).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: generalized gravity forces of articulations in the view.\n    Shape is (M, K).\n\n---\n**Example:**\n\n```python\n>>>\n\n>>> # get all generalized gravity forces. Returned shape is (5, 9) for the example: 5 envs, 9 DOFs\n>>> prims.get_generalized_gravity_forces()\n[[ 1.32438602e-08 -6.90832138e+00 -1.08629465e-05  1.91585541e+01  5.13810664e-06\n   1.18674076e+00  8.01788883e-06  5.18786255e-03 -5.18784765e-03]\n [ 1.32438602e-08 -6.90832138e+00 -1.08629465e-05  1.91585541e+01  5.13810664e-06\n   1.18674076e+00  8.01788883e-06  5.18786255e-03 -5.18784765e-03]\n [ 1.32438585e-08 -6.90830994e+00 -1.08778477e-05  1.91585541e+01  5.14090061e-06\n   1.18674052e+00  8.02161412e-06  5.18786255e-03 -5.18784765e-03]\n [ 1.32438585e-08 -6.90830994e+00 -1.08778477e-05  1.91585541e+01  5.14090061e-06\n   1.18674052e+00  8.02161412e-06  5.18786255e-03 -5.18784765e-03]\n [ 1.32438602e-08 -6.90832138e+00 -1.08629465e-05  1.91585541e+01  5.13810664e-06\n   1.18674076e+00  8.01788883e-06  5.18786255e-03 -5.18784765e-03]]\n>>>\n>>> # get finger joint generalized gravity forces: panda_finger_joint1 (7) and panda_finger_joint2 (8)\n>>> # for the first, middle and last of the 5 envs. Returned shape is (3, 2)\n>>> prims.get_generalized_gravity_forces(indices=np.array([0, 2, 4]), joint_indices=np.array([7, 8]))\n[[ 0.00518786 -0.00518785]\n [ 0.00518786 -0.00518785]\n [ 0.00518786 -0.00518785]]\n```\n",
"snippet":"generalized_gravity_forces = robot_view.get_generalized_gravity_forces()\n",
"category":"method"
},
{
"title":"get_jacobian_shape",
"description":"Get the Jacobian matrix shape of a single articulation\n\nThe Jacobian matrix maps the joint space velocities of a DOF to it's cartesian and angular velocities\n\nThe shape of the Jacobian depends on the number of links (rigid bodies), DOFs,\nand whether the articulation base is fixed (e.g., robotic manipulators) or not (e.g,. mobile robots).\n\n-   Fixed articulation base: `(num_bodies - 1, 6, num_dof)`\n-   Non-fixed articulation base: `(num_bodies, 6, num_dof + 6)`\n\nEach body has 6 values in the Jacobian representing its linear and angular motion along the\nthree coordinate axes. The extra 6 DOFs in the last dimension, for non-fixed base cases,\ncorrespond to the linear and angular degrees of freedom of the free root link\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.array\\]: shape of jacobian for a single articulation.\n\n---\n**Example:**\n\n```python\n>>> # for the Franka Panda (a robotic manipulator with fixed base):\n>>> # - num_bodies: 12\n>>> # - num_dof: 9\n>>> prims.get_jacobian_shape()\n(11, 6, 9)\n```\n",
"snippet":"jacobian_shape = robot_view.get_jacobian_shape()\n",
"category":"method"
},
{
"title":"get_jacobians",
"description":"Get the Jacobian matrices of articulations in the view\n\n*Note:*\nThe first dimension corresponds to the amount of wrapped articulations while the last 3 dimensions are the\nJacobian matrix shape. Refer to the `get_jacobian_shape` method for details about the Jacobian matrix shape\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: Jacobian matrices of articulations in the view.\n    Shape is (M, jacobian\\_shape).\n\n---\n**Example:**\n\n```python\n>>> # get the Jacobian matrices. Returned shape is (5, 11, 6, 9) for the example: 5 envs, 12 links, 9 DOFs\n>>> prims.get_jacobians()\n[[[[ 4.2254178e-09  0.0000000e+00  0.0000000e+00 ...  0.0000000e+00  0.0000000e+00  0.0000000e+00]\n   [ 1.2093576e-08  0.0000000e+00  0.0000000e+00 ...  0.0000000e+00  0.0000000e+00  0.0000000e+00]\n   [-6.0873992e-16  0.0000000e+00  0.0000000e+00 ...  0.0000000e+00  0.0000000e+00  0.0000000e+00]\n   [ 1.4458647e-07  0.0000000e+00  0.0000000e+00 ...  0.0000000e+00  0.0000000e+00  0.0000000e+00]\n   [-1.8178657e-10  0.0000000e+00  0.0000000e+00 ...  0.0000000e+00  0.0000000e+00  0.0000000e+00]\n   [ 9.9999976e-01  0.0000000e+00  0.0000000e+00 ...  0.0000000e+00  0.0000000e+00  0.0000000e+00]]\n  ...\n  [[-4.5089945e-02  8.1210062e-02 -3.8495898e-02 ...  2.8108317e-02  0.0000000e+00 -4.9317405e-02]\n   [ 4.2863289e-01  9.7436900e-04  4.0475106e-01 ...  2.4577195e-03  0.0000000e+00  9.9807423e-01]\n   [ 6.5973169e-09 -4.2914307e-01 -2.1542320e-02 ...  2.8352857e-02  0.0000000e+00 -3.7625343e-02]\n   [ 1.4458647e-07 -1.1999309e-02 -5.3927803e-01 ...  7.0976764e-01  0.0000000e+00  0.0000000e+00]\n   [-1.8178657e-10  9.9992776e-01 -6.4710006e-03 ...  8.5178167e-03  0.0000000e+00  0.0000000e+00]\n   [ 9.9999976e-01 -3.8743019e-07  8.4210289e-01 ... -7.0438433e-01  0.0000000e+00  0.0000000e+00]]]]\n```\n",
"snippet":"jacobians = robot_view.get_jacobians()\n",
"category":"method"
},
{
"title":"get_joint_index",
"description":"Get a joint index in the joint buffers given its name\n\n**Args:**\n\n * `joint_name` (str): name of the joint that corresponds to the index of the joint in the articulation\n\n**Returns:**\n\n * int: index of the joint in the joint buffers\n",
"snippet":"joint_index = robot_view.get_joint_index(joint_name=joint_name)\n",
"category":"method"
},
{
"title":"get_joint_positions",
"description":"Get the joint positions of articulations in the view\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `joint_indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): joint indices to specify which joints to query. Shape (K,). Where K \\<= num of dofs. Defaults to None (i.e: all dofs).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: joint positions of articulations in the view.\n    Shape is (M, K).\n\n---\n**Example:**\n\n```python\n>>> # get all joint positions. Returned shape is (5, 9) for the example: 5 envs, 9 DOFs\n>>> prims.get_joint_positions()\n[[ 1.1999921e-02 -5.6962633e-01  1.3219320e-08 -2.8105433e+00  6.8276213e-06\n   3.0301569e+00  7.3234755e-01  3.9912373e-02  3.9999999e-02]\n [ 1.1999921e-02 -5.6962633e-01  1.3219320e-08 -2.8105433e+00  6.8276213e-06\n   3.0301569e+00  7.3234755e-01  3.9912373e-02  3.9999999e-02]\n [ 1.1999921e-02 -5.6962633e-01  1.3220056e-08 -2.8105433e+00  6.8276104e-06\n   3.0301569e+00  7.3234755e-01  3.9912373e-02  3.9999999e-02]\n [ 1.1999921e-02 -5.6962633e-01  1.3220056e-08 -2.8105433e+00  6.8276104e-06\n   3.0301569e+00  7.3234755e-01  3.9912373e-02  3.9999999e-02]\n [ 1.1999921e-02 -5.6962633e-01  1.3219320e-08 -2.8105433e+00  6.8276213e-06\n   3.0301569e+00  7.3234755e-01  3.9912373e-02  3.9999999e-02]]\n>>>\n>>> # get finger joint positions: panda_finger_joint1 (7) and panda_finger_joint2 (8)\n>>> # for the first, middle and last of the 5 envs. Returned shape is (3, 2)\n>>> prims.get_joint_positions(indices=np.array([0, 2, 4]), joint_indices=np.array([7, 8]))\n[[0.03991237 0.04      ]\n [0.03991237 0.04      ]\n [0.03991237 0.04      ]]\n```\n",
"snippet":"joint_positions = robot_view.get_joint_positions()\n",
"category":"method"
},
{
"title":"get_joint_velocities",
"description":"Get the joint velocities of articulations in the view\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `joint_indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): joint indices to specify which joints to query. Shape (K,). Where K \\<= num of dofs. Defaults to None (i.e: all dofs).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: joint velocities of articulations in the view.\n    Shape is (M, K).\n\n---\n**Example:**\n\n```python\n>>> # get all joint velocities. Returned shape is (5, 9) for the example: 5 envs, 9 DOFs\n>>> prims.get_joint_velocities()\n[[ 1.9010375e-06 -7.6763844e-03 -2.1396865e-07  1.1063669e-02 -4.6333633e-05\n   3.4824573e-02  8.8469200e-02  5.4033857e-04  1.0287426e-05]\n [ 1.9010375e-06 -7.6763844e-03 -2.1396865e-07  1.1063669e-02 -4.6333633e-05\n   3.4824573e-02  8.8469200e-02  5.4033857e-04  1.0287426e-05]\n [ 1.9010074e-06 -7.6763779e-03 -2.1403629e-07  1.1063648e-02 -4.6333400e-05\n   3.4824558e-02  8.8469170e-02  5.4033566e-04  1.0287110e-05]\n [ 1.9010074e-06 -7.6763779e-03 -2.1403629e-07  1.1063648e-02 -4.6333400e-05\n   3.4824558e-02  8.8469170e-02  5.4033566e-04  1.0287110e-05]\n [ 1.9010375e-06 -7.6763844e-03 -2.1396865e-07  1.1063669e-02 -4.6333633e-05\n   3.4824573e-02  8.8469200e-02  5.4033857e-04  1.0287426e-05]]\n>>>\n>>> # get finger joint velocities: panda_finger_joint1 (7) and panda_finger_joint2 (8)\n>>> # for the first, middle and last of the 5 envs. Returned shape is (3, 2)\n>>> prims.get_joint_velocities(indices=np.array([0, 2, 4]), joint_indices=np.array([7, 8]))\n[[5.4033857e-04 1.0287426e-05]\n [5.4033566e-04 1.0287110e-05]\n [5.4033857e-04 1.0287426e-05]]\n```\n",
"snippet":"joint_velocities = robot_view.get_joint_velocities()\n",
"category":"method"
},
{
"title":"get_joints_default_state",
"description":"Get the default joint states defined with the `set_joints_default_state` method\n\n**Returns:**\n\n * JointsState: an object that contains the default joint states\n\n---\n**Example:**\n\n```python\n>>> # returned shape is (5, 9) for the example: 5 envs, 9 DOFs\n>>> states = prims.get_joints_default_state()\n>>> states\n<omni.isaac.core.utils.types.JointsState object at 0x7fc2c174fd90>\n>>> states.positions\n[[ 0.   -1.    0.   -2.2   0.    2.4   0.8   0.04  0.04]\n [ 0.   -1.    0.   -2.2   0.    2.4   0.8   0.04  0.04]\n [ 0.   -1.    0.   -2.2   0.    2.4   0.8   0.04  0.04]\n [ 0.   -1.    0.   -2.2   0.    2.4   0.8   0.04  0.04]\n [ 0.   -1.    0.   -2.2   0.    2.4   0.8   0.04  0.04]]\n>>> states.velocities\n[[0. 0. 0. 0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0. 0. 0. 0.]]\n>>> states.efforts\n[[0. 0. 0. 0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0. 0. 0. 0.]]\n```\n",
"snippet":"joints_default_state = robot_view.get_joints_default_state()\n",
"category":"method"
},
{
"title":"get_joints_state",
"description":"Get the current joint states (positions and velocities)\n\n**Returns:**\n\n * JointsState: an object that contains the current joint positions and velocities\n\n---\n**Example:**\n\n```python\n>>> # returned shape is (5, 9) for the example: 5 envs, 9 DOFs\n>>> states = prims.get_joints_state()\n>>> states\n<omni.isaac.core.utils.types.JointsState object at 0x7fc1a23a82e0>\n>>> states.positions\n[[ 1.1999921e-02 -5.6962633e-01  1.3219320e-08 -2.8105433e+00  6.8276213e-06\n   3.0301569e+00  7.3234755e-01  3.9912373e-02  3.9999999e-02]\n [ 1.1999921e-02 -5.6962633e-01  1.3219320e-08 -2.8105433e+00  6.8276213e-06\n   3.0301569e+00  7.3234755e-01  3.9912373e-02  3.9999999e-02]\n [ 1.1999921e-02 -5.6962633e-01  1.3220056e-08 -2.8105433e+00  6.8276104e-06\n   3.0301569e+00  7.3234755e-01  3.9912373e-02  3.9999999e-02]\n [ 1.1999921e-02 -5.6962633e-01  1.3220056e-08 -2.8105433e+00  6.8276104e-06\n   3.0301569e+00  7.3234755e-01  3.9912373e-02  3.9999999e-02]\n [ 1.1999921e-02 -5.6962633e-01  1.3219320e-08 -2.8105433e+00  6.8276213e-06\n   3.0301569e+00  7.3234755e-01  3.9912373e-02  3.9999999e-02]]\n>>> states.velocities\n[[ 1.9010375e-06 -7.6763844e-03 -2.1396865e-07  1.1063669e-02 -4.6333633e-05\n   3.4824573e-02  8.8469200e-02  5.4033857e-04  1.0287426e-05]\n [ 1.9010375e-06 -7.6763844e-03 -2.1396865e-07  1.1063669e-02 -4.6333633e-05\n   3.4824573e-02  8.8469200e-02  5.4033857e-04  1.0287426e-05]\n [ 1.9010074e-06 -7.6763779e-03 -2.1403629e-07  1.1063648e-02 -4.6333400e-05\n   3.4824558e-02  8.8469170e-02  5.4033566e-04  1.0287110e-05]\n [ 1.9010074e-06 -7.6763779e-03 -2.1403629e-07  1.1063648e-02 -4.6333400e-05\n   3.4824558e-02  8.8469170e-02  5.4033566e-04  1.0287110e-05]\n [ 1.9010375e-06 -7.6763844e-03 -2.1396865e-07  1.1063669e-02 -4.6333633e-05\n   3.4824573e-02  8.8469200e-02  5.4033857e-04  1.0287426e-05]]\n```\n",
"snippet":"joints_state = robot_view.get_joints_state()\n",
"category":"method"
},
{
"title":"get_linear_velocities",
"description":"Get the linear velocities of prims in the view.\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view)\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: linear velocities of the prims in the view. shape is (M, 3).\n\n---\n**Example:**\n\n```python\n>>> # get all articulation linear velocities. Returned shape is (5, 3) for the example: 5 envs, linear (3)\n>>> prims.get_linear_velocities()\n[[0. 0. 0.]\n [0. 0. 0.]\n [0. 0. 0.]\n [0. 0. 0.]\n [0. 0. 0.]]\n>>>\n>>> # get only the articulation linear velocities for the first, middle and last of the 5 envs.\n>>> # Returned shape is (3, 3) for the example: 3 envs selected, linear (3)\n>>> prims.get_linear_velocities(indices=np.array([0, 2, 4]))\n[[0. 0. 0.]\n [0. 0. 0.]\n [0. 0. 0.]]\n```\n",
"snippet":"linear_velocities = robot_view.get_linear_velocities()\n",
"category":"method"
},
{
"title":"get_link_index",
"description":"Get a link index in the link buffers given its name\n\n**Args:**\n\n * `link_name` (str): name of the link that corresponds to the index of the link in the articulation\n\n**Returns:**\n\n * int: index of the link in the link buffers\n",
"snippet":"link_index = robot_view.get_link_index(link_name=link_name)\n",
"category":"method"
},
{
"title":"get_local_poses",
"description":"Get prim poses in the view with respect to the local frame (the prim's parent frame).\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view)\n\n**Returns:**\n\n * Union\\[Tuple\\[np.ndarray, np.ndarray\\], Tuple\\[torch.Tensor, torch.Tensor\\], Tuple\\[wp.indexedarray, wp.indexedarray\\]\\]:\n    first index is positions in the local frame of the prims. shape is (M, 3). Second index is quaternion orientations\n    in the local frame of the prims. Quaternion is scalar-first (w, x, y, z). shape is (M, 4).\n\n---\n**Example:**\n\n```python\n>>> # get all articulation poses with respect to the local frame.\n>>> # Returned shape is position (5, 3) and orientation (5, 4) for the example: 5 envs\n>>> positions, orientations = prims.get_local_poses()\n>>> positions\n[[ 0.0000000e+00  0.0000000e+00 -2.8610229e-08]\n [ 0.0000000e+00  0.0000000e+00 -2.8610229e-08]\n [-4.5299529e-08  0.0000000e+00 -2.8610229e-08]\n [-4.5299529e-08  0.0000000e+00 -2.8610229e-08]\n [ 0.0000000e+00  0.0000000e+00 -2.8610229e-08]]\n>>> orientations\n[[1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]]\n>>>\n>>> # get only the articulation poses with respect to the local frame for the first, middle and last of the 5 envs.\n>>> # Returned shape is position (3, 3) and orientation (3, 4) for the example: 3 envs selected\n>>> positions, orientations = prims.get_local_poses(indices=np.array([0, 2, 4]))\n>>> positions\n[[ 0.0000000e+00  0.0000000e+00 -2.8610229e-08]\n [-4.5299529e-08  0.0000000e+00 -2.8610229e-08]\n [ 0.0000000e+00  0.0000000e+00 -2.8610229e-08]]\n>>> orientations\n[[1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]]\n```\n",
"snippet":"local_poses = robot_view.get_local_poses()\n",
"category":"method"
},
{
"title":"get_local_poses",
"description":"Get prim poses in the view with respect to the local frame (the prim's parent frame)\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Returns:**\n\n * Union\\[Tuple\\[np.ndarray, np.ndarray\\], Tuple\\[torch.Tensor, torch.Tensor\\], Tuple\\[wp.indexedarray, wp.indexedarray\\]\\]: first index is translations in the local frame of the prims. shape is (M, 3). second index is quaternion orientations in the local frame of the prims. quaternion is scalar-first (w, x, y, z). shape is (M, 4).\n\n---\n**Example:**\n\n```python\n>>> # get all prims poses with respect to the local frame.\n>>> # Returned shape is position (5, 3) and orientation (5, 4) for the example: 5 envs\n>>> positions, orientations = prims.get_local_poses()\n>>> positions\n[[ 1.5  -0.75  0.  ]\n [ 1.5   0.75  0.  ]\n [ 0.   -0.75  0.  ]\n [ 0.    0.75  0.  ]\n [-1.5  -0.75  0.  ]]\n>>> orientations\n[[1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]]\n>>>\n>>> # get only the prims poses with respect to the local frame for the first, middle and last of the 5 envs.\n>>> # Returned shape is position (3, 3) and orientation (3, 4) for the example: 3 envs selected\n>>> positions, orientations = prims.get_local_poses(indices=np.array([0, 2, 4]))\n>>> positions\n[[ 1.5  -0.75  0.  ]\n [ 0.   -0.75  0.  ]\n [-1.5  -0.75  0.  ]]\n>>> orientations\n[[1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]]\n```\n",
"snippet":"local_poses = robot_view.get_local_poses()\n",
"category":"method"
},
{
"title":"get_local_scales",
"description":"Get prim scales in the view with respect to the local frame (the parent's frame).\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: scales applied to the prim's dimensions in the local frame. shape is (M, 3).\n\n---\n**Example:**\n\n```python\n>>> # get all prims scales with respect to the local frame.\n>>> # Returned shape is (5, 3) for the example: 5 envs\n>>> prims.get_local_scales()\n[[1. 1. 1.]\n [1. 1. 1.]\n [1. 1. 1.]\n [1. 1. 1.]\n [1. 1. 1.]]\n>>>\n>>> # get only the prims scales with respect to the local frame for the first, middle and last of the 5 envs.\n>>> # Returned shape is (3, 3) for the example: 3 envs selected\n>>> prims.get_local_scales(indices=np.array([0, 2, 4]))\n[[1. 1. 1.]\n [1. 1. 1.]\n [1. 1. 1.]]\n```\n",
"snippet":"local_scales = robot_view.get_local_scales()\n",
"category":"method"
},
{
"title":"get_mass_matrices",
"description":"Get the mass matrices of articulations in the view\n\n*Note:*\nThe first dimension corresponds to the amount of wrapped articulations while the last 2 dimensions are the\nmass matrix shape. Refer to the `get_mass_matrix_shape` method for details about the mass matrix shape\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: mass matrices of articulations in the view.\n    Shape is (M, mass\\_matrix\\_shape).\n\n---\n**Example:**\n\n```python\n>>> # get the mass matrices. Returned shape is (5, 9, 9) for the example: 5 envs, 9 DOFs\n>>> prims.get_mass_matrices()\n[[[ 5.0900602e-01  1.1794259e-06  4.2570841e-01 -1.6387942e-06 -3.1573933e-02\n   -1.9736715e-06 -3.1358242e-04 -6.0441834e-03  6.0441834e-03]\n  [ 1.1794259e-06  1.0598221e+00  7.4729815e-07 -4.2621672e-01  2.3612277e-08\n   -4.9647894e-02 -2.9080724e-07 -1.8432185e-04  1.8432130e-04]\n  ...\n  [-6.0441834e-03 -1.8432185e-04 -5.7159867e-03  4.0070520e-04  9.6930371e-04 1.2324301e-04  2.5264668e-10  1.4055224e-02  0.0000000e+00]\n  [ 6.0441834e-03  1.8432130e-04  5.7159867e-03 -4.0070404e-04 -9.6930366e-04\n   -1.2324269e-04 -3.6906206e-10  0.0000000e+00  1.4055224e-02]]]\n```\n",
"snippet":"mass_matrices = robot_view.get_mass_matrices()\n",
"category":"method"
},
{
"title":"get_mass_matrix_shape",
"description":"Get the mass matrix shape of a single articulation\n\nThe mass matrix contains the generalized mass of the robot depending on the current configuration\n\nThe shape of the max matrix depends on the number of DOFs: `(num_dof, num_dof)`\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.array\\]: shape of mass matrix for a single articulation.\n\n---\n**Example:**\n\n```python\n>>> # for the Franka Panda:\n>>> # - num_dof: 9\n>>> prims.get_jacobian_shape()\n(9, 9)\n```\n",
"snippet":"mass_matrix_shape = robot_view.get_mass_matrix_shape()\n",
"category":"method"
},
{
"title":"get_max_efforts",
"description":"Get the maximum efforts for articulation in the view\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `joint_indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): joint indices to specify which joints to query. Shape (K,). Where K \\<= num of dofs. Defaults to None (i.e: all dofs).\n * `clone` (Optional\\[bool\\]): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: maximum efforts for articulations in the view. shape (M, K).\n\n---\n**Example:**\n\n```python\n>>> # get all joint maximum efforts. Returned shape is (5, 9) for the example: 5 envs, 9 DOFs\n>>> prims.get_max_efforts()\n[[5220. 5220. 5220. 5220.  720.  720.  720.  720.  720.]\n [5220. 5220. 5220. 5220.  720.  720.  720.  720.  720.]\n [5220. 5220. 5220. 5220.  720.  720.  720.  720.  720.]\n [5220. 5220. 5220. 5220.  720.  720.  720.  720.  720.]\n [5220. 5220. 5220. 5220.  720.  720.  720.  720.  720.]]\n>>>\n>>> # get finger joint maximum efforts: panda_finger_joint1 (7) and panda_finger_joint2 (8)\n>>> # for the first, middle and last of the 5 envs. Returned shape is (3, 2)\n>>> prims.get_max_efforts(indices=np.array([0, 2, 4]), joint_indices=np.array([7, 8]))\n[[720. 720.]\n [720. 720.]\n [720. 720.]]\n```\n",
"snippet":"max_efforts = robot_view.get_max_efforts()\n",
"category":"method"
},
{
"title":"get_measured_joint_efforts",
"description":"Returns the efforts computed/measured by the physics solver of the joint forces in the DOF motion direction\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `joint_indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor\\]\\], optional): joint indices to specify which joints to query. Shape (K,). Where K \\<= num of dofs. Defaults to None (i.e: all dofs).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor\\]: computed joint efforts of articulations in the view. shape is (M, K).\n\n---\n**Example:**\n\n```python\n>>> # get all measured joint efforts. Returned shape is (5, 9) for the example: 5 envs, 9 DOFs\n>>> prims.get_measured_joint_efforts()\n[[ 4.8250298e-05 -6.9073005e+00  5.3364405e-05  1.9157070e+01 -5.8759182e-05\n   1.1863427e+00 -5.6388220e-05  5.1680300e-03 -5.1910817e-03]\n [ 4.8250298e-05 -6.9073005e+00  5.3364405e-05  1.9157070e+01 -5.8759182e-05\n   1.1863427e+00 -5.6388220e-05  5.1680300e-03 -5.1910817e-03]\n [ 4.8254540e-05 -6.9072919e+00  5.3344327e-05  1.9157072e+01 -5.8761045e-05\n   1.1863427e+00 -5.6405144e-05  5.1680212e-03 -5.1910840e-03]\n [ 4.8254540e-05 -6.9072919e+00  5.3344327e-05  1.9157072e+01 -5.8761045e-05\n   1.1863427e+00 -5.6405144e-05  5.1680212e-03 -5.1910840e-03]\n [ 4.8250298e-05 -6.9073005e+00  5.3364405e-05  1.9157070e+01 -5.8759182e-05\n   1.1863427e+00 -5.6388220e-05  5.1680300e-03  -5.1910817e-03]]\n>>>\n>>> # get finger measured joint efforts: panda_finger_joint1 (7) and panda_finger_joint2 (8)\n>>> # for the first, middle and last of the 5 envs. Returned shape is (3, 2)\n>>> prims.get_measured_joint_efforts(indices=np.array([0, 2, 4]), joint_indices=np.array([7, 8]))\n[[ 0.00516803 -0.00519108]\n [ 0.00516802 -0.00519108]\n [ 0.00516803 -0.00519108]]\n```\n",
"snippet":"measured_joint_efforts = robot_view.get_measured_joint_efforts()\n",
"category":"method"
},
{
"title":"get_measured_joint_forces",
"description":"Get the measured joint reaction forces and torques (link incoming joint forces and torques) to external loads\n\n*Note:*\nSince the *name-\\>index* map for joints has not been exposed yet,\nit is possible to access the joint names and their indices through the articulation metadata.\n\n> ```python\n> ```\n>\n> prims.\\_metadata.joint\\_names \\# list of names prims.\\_metadata.joint\\_indices \\# dict of name: index\n>\n> To retrieve a specific row for the link incoming joint force/torque use `joint_index + 1`\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `joint_indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor\\]\\], optional): link indices to specify which link's incoming joints to query. Shape (K,). Where K \\<= num of links/bodies. Defaults to None (i.e: all dofs).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor\\]: joint forces and torques of articulations in the view.\n    Shape is (M, num\\_joint + 1, 6). Column index 0 is the incoming joint of the base link.\n    For the last dimension the first 3 values are for forces and the last 3 for torques\n\n---\n**Example:**\n\n```python\n>>> # get all measured joint forces and torques. Returned shape is (5, 12, 6) for the example:\n>>> # 5 envs, 9 DOFs (but 12 joints including the fixed and root joints)\n>>> prims.get_measured_joint_forces()\n[[[ 0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00]\n  [ 1.49950760e+02  3.52353277e-06  5.62586996e-04  4.82502983e-05 -6.90729856e+00  2.69259126e-05]\n  [-2.60467059e-05 -1.06778236e+02 -6.83844986e+01 -6.90730047e+00 -5.27759657e-05 -1.24897576e-06]\n  [ 8.71209946e+01 -4.46646191e-05 -5.57951622e+01  5.33644052e-05 -2.45385647e+01  1.38957939e-05]\n  [ 5.18576926e-05 -4.81099091e+01  6.07092705e+01  1.91570702e+01 -5.81023924e-05  1.46875891e-06]\n  [-3.16910419e+01  2.31799815e-04  3.99901695e+01 -5.87591821e-05 -1.18634319e+00  2.24427877e-05]\n  [-1.07621672e-04  1.53405371e+01 -1.54584875e+01  1.18634272e+00  6.09036942e-05 -1.60679410e-05]\n  [-7.54189777e+00 -5.08146524e+00 -5.65130091e+00 -5.63882204e-05  3.88599992e-01 -3.49432468e-01]\n  [ 4.74214745e+00 -3.19458222e+00  3.55281782e+00  5.58562024e-05  8.47946014e-03  7.64050474e-03]\n  [ 4.07607269e+00  2.16406956e-01 -4.05131817e+00 -5.95658377e-04  1.14070829e-02  2.13965313e-06]\n  [ 5.16803004e-03 -9.77545828e-02 -9.70939621e-02 -8.41282599e-12 -1.29066744e-12 -1.93477560e-11]\n  [-5.19108167e-03  9.75882635e-02 -9.71064270e-02  8.41282859e-12  1.29066018e-12 -1.93477543e-11]]\n ...\n [[ 0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00]\n  [ 1.49950760e+02  3.52353277e-06  5.62586996e-04  4.82502983e-05 -6.90729856e+00  2.69259126e-05]\n  [-2.60467059e-05 -1.06778236e+02 -6.83844986e+01 -6.90730047e+00 -5.27759657e-05 -1.24897576e-06]\n  [ 8.71209946e+01 -4.46646191e-05 -5.57951622e+01  5.33644052e-05 -2.45385647e+01  1.38957939e-05]\n  [ 5.18576926e-05 -4.81099091e+01  6.07092705e+01  1.91570702e+01 -5.81023924e-05  1.46875891e-06]\n  [-3.16910419e+01  2.31799815e-04  3.99901695e+01 -5.87591821e-05 -1.18634319e+00  2.24427877e-05]\n  [-1.07621672e-04  1.53405371e+01 -1.54584875e+01  1.18634272e+00  6.09036942e-05 -1.60679410e-05]\n  [-7.54189777e+00 -5.08146524e+00 -5.65130091e+00 -5.63882204e-05  3.88599992e-01 -3.49432468e-01]\n  [ 4.74214745e+00 -3.19458222e+00  3.55281782e+00  5.58562024e-05  8.47946014e-03  7.64050474e-03]\n  [ 4.07607269e+00  2.16406956e-01 -4.05131817e+00 -5.95658377e-04  1.14070829e-02  2.13965313e-06]\n  [ 5.16803004e-03 -9.77545828e-02 -9.70939621e-02 -8.41282599e-12 -1.29066744e-12 -1.93477560e-11]\n  [-5.19108167e-03  9.75882635e-02 -9.71064270e-02  8.41282859e-12  1.29066018e-12 -1.93477543e-11]]]\n>>>\n>>> # get measured joint forces and torques for the fingers for the first, middle and last of the 5 envs.\n>>> # Returned shape is (3, 2, 6)\n>>> metadata = prims._metadata\n>>> joint_indices = 1 + np.array([\n>>>     metadata.joint_indices[\"panda_finger_joint1\"],\n>>>     metadata.joint_indices[\"panda_finger_joint2\"],\n>>> ])\n>>> joint_indices\n[10 11]\n>>> prims.get_measured_joint_forces(indices=np.array([0, 2, 4]), joint_indices=joint_indices)\n[[[ 5.1680300e-03 -9.7754583e-02 -9.7093962e-02 -8.4128260e-12 -1.2906674e-12 -1.9347756e-11]\n  [-5.1910817e-03  9.7588263e-02 -9.7106427e-02  8.4128286e-12  1.2906602e-12 -1.9347754e-11]]\n [[ 5.1680212e-03 -9.7754560e-02 -9.7093947e-02 -8.4141834e-12 -1.2907383e-12 -1.9348209e-11]\n  [-5.1910840e-03  9.7588278e-02 -9.7106412e-02  8.4141869e-12  1.2907335e-12 -1.9348207e-11]]\n [[ 5.1680300e-03 -9.7754583e-02 -9.7093962e-02 -8.4128260e-12 -1.2906674e-12 -1.9347756e-11]\n  [-5.1910817e-03  9.7588263e-02 -9.7106427e-02  8.4128286e-12  1.2906602e-12 -1.9347754e-11]]]\n```\n",
"snippet":"measured_joint_forces = robot_view.get_measured_joint_forces()\n",
"category":"method"
},
{
"title":"get_sleep_thresholds",
"description":"Get the threshold for articulations to enter a sleep state\n\nSearch for *Articulations and Sleeping* in for more details\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: sleep thresholds. shape (M,).\n\n---\n**Example:**\n\n```python\n>>> # get all sleep thresholds. Returned shape is (5,) for the example: 5 envs\n>>> prims.get_sleep_thresholds()\n[0.005 0.005 0.005 0.005 0.005]\n>>>\n>>> # get the sleep thresholds for the first, middle and last of the 5 envs. Returned shape is (3,)\n>>> prims.get_sleep_thresholds(indices=np.array([0, 2, 4]))\n[0.005 0.005 0.005]\n```\n",
"snippet":"sleep_thresholds = robot_view.get_sleep_thresholds()\n",
"category":"method"
},
{
"title":"get_solver_position_iteration_counts",
"description":"Get the solver (position) iteration count for the articulations\n\nThe solver iteration count determines how accurately contacts, drives, and limits are resolved.\nSearch for *Solver Iteration Count* in for more details.\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: position iteration count. Shape (M,).\n\n---\n**Example:**\n\n```python\n>>> # get all position iteration count. Returned shape is (5,) for the example: 5 envs\n>>> prims.get_solver_position_iteration_counts()\n[32 32 32 32 32]\n>>>\n>>> # get the position iteration count for the first, middle and last of the 5 envs. Returned shape is (3,)\n>>> prims.get_solver_position_iteration_counts(indices=np.array([0, 2, 4]))\n[32 32 32]\n```\n",
"snippet":"solver_position_iteration_counts = robot_view.get_solver_position_iteration_counts()\n",
"category":"method"
},
{
"title":"get_solver_velocity_iteration_counts",
"description":"Get the solver (velocity) iteration count for the articulations\n\nThe solver iteration count determines how accurately contacts, drives, and limits are resolved.\nSearch for *Solver Iteration Count* in for more details.\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: velocity iteration count. Shape (M,).\n\n---\n**Example:**\n\n```python\n>>> # get all velocity iteration count. Returned shape is (5,) for the example: 5 envs\n>>> prims.get_solver_velocity_iteration_counts()\n[32 32 32 32 32]\n>>>\n>>> # get the velocity iteration count for the first, middle and last of the 5 envs. Returned shape is (3,)\n>>> prims.get_solver_velocity_iteration_counts(indices=np.array([0, 2, 4]))\n[32 32 32]\n```\n",
"snippet":"solver_velocity_iteration_counts = robot_view.get_solver_velocity_iteration_counts()\n",
"category":"method"
},
{
"title":"get_stabilization_thresholds",
"description":"Get the mass-normalized kinetic energy below which the articulations may participate in stabilization\n\nSearch for *Stabilization Threshold* in for more details\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: stabilization threshold. Shape (M,).\n\n---\n**Example:**\n\n```python\n>>> # get all stabilization thresholds. Returned shape is (5,) for the example: 5 envs\n>>> prims.get_solver_velocity_iteration_counts()\n[0.001 0.001 0.001 0.001 0.001]\n>>>\n>>> # get the stabilization thresholds for the first, middle and last of the 5 envs. Returned shape is (3,)\n>>> prims.get_solver_velocity_iteration_counts(indices=np.array([0, 2, 4]))\n[0.001 0.001 0.001]\n```\n",
"snippet":"stabilization_thresholds = robot_view.get_stabilization_thresholds()\n",
"category":"method"
},
{
"title":"get_velocities",
"description":"Get the linear and angular velocities of prims in the view.\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view)\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: linear and angular velocities of the prims in the view concatenated. shape is (M, 6).\n    For the last dimension the first 3 values are for linear velocities and the last 3 for angular velocities\n\n---\n**Example:**\n\n```python\n>>> # get all articulation velocities. Returned shape is (5, 6) for the example: 5 envs, linear (3) and angular (3)\n>>> prims.get_velocities()\n[[0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0.]]\n>>>\n>>> # get only the articulation velocities for the first, middle and last of the 5 envs.\n>>> # Returned shape is (3, 6) for the example: 3 envs selected, linear (3) and angular (3)\n>>> prims.get_velocities(indices=np.array([0, 2, 4]))\n[[0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0.]]\n```\n",
"snippet":"velocities = robot_view.get_velocities()\n",
"category":"method"
},
{
"title":"get_visibilities",
"description":"Returns the current visibilities of the prims in stage.\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: Shape (M,) with type bool, where each item holds True if the prim is visible in stage. False otherwise.\n\n---\n**Example:**\n\n```python\n>>> # get all visibilities. Returned shape is (5,) for the example: 5 envs\n>>> prims.get_visibilities()\n[ True  True  True  True  True]\n>>>\n>>> # get the visibilities for the first, middle and last of the 5 envs. Returned shape is (3,)\n>>> prims.get_visibilities(indices=np.array([0, 2, 4]))\n[ True  True  True]\n```\n",
"snippet":"visibilities = robot_view.get_visibilities()\n",
"category":"method"
},
{
"title":"get_world_poses",
"description":"Get the poses of the prims in the view with respect to the world's frame.\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `clone` (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n**Returns:**\n\n * Union\\[Tuple\\[np.ndarray, np.ndarray\\], Tuple\\[torch.Tensor, torch.Tensor\\], Tuple\\[wp.indexedarray, wp.indexedarray\\]\\]:\n    first index is positions in the world frame of the prims. shape is (M, 3). Second index is quaternion orientations\n    in the world frame of the prims. Quaternion is scalar-first (w, x, y, z). shape is (M, 4).\n\n---\n**Example:**\n\n```python\n>>> # get all articulation poses with respect to the world's frame.\n>>> # Returned shape is position (5, 3) and orientation (5, 4) for the example: 5 envs\n>>> positions, orientations = prims.get_world_poses()\n>>> positions\n[[ 1.5000000e+00 -7.5000000e-01 -2.8610229e-08]\n [ 1.5000000e+00  7.5000000e-01 -2.8610229e-08]\n [-4.5299529e-08 -7.5000000e-01 -2.8610229e-08]\n [-4.5299529e-08  7.5000000e-01 -2.8610229e-08]\n [-1.5000000e+00 -7.5000000e-01 -2.8610229e-08]]\n>>> orientations\n[[1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]]\n>>>\n>>> # get only the articulation poses with respect to the world's frame for the first, middle and last of the 5 envs.\n>>> # Returned shape is position (3, 3) and orientation (3, 4) for the example: 3 envs selected\n>>> positions, orientations = prims.get_world_poses(indices=np.array([0, 2, 4]))\n>>> positions\n[[ 1.5000000e+00 -7.5000000e-01 -2.8610229e-08]\n [-4.5299529e-08 -7.5000000e-01 -2.8610229e-08]\n [-1.5000000e+00 -7.5000000e-01 -2.8610229e-08]]\n>>> orientations\n[[1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]]\n```\n",
"snippet":"world_poses = robot_view.get_world_poses()\n",
"category":"method"
},
{
"title":"get_world_poses",
"description":"Get the poses of the prims in the view with respect to the world's frame\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Returns:**\n\n * Union\\[Tuple\\[np.ndarray, np.ndarray\\], Tuple\\[torch.Tensor, torch.Tensor\\], Tuple\\[wp.indexedarray, wp.indexedarray\\]\\]: first index is positions in the world frame of the prims. shape is (M, 3). second index is quaternion orientations in the world frame of the prims. quaternion is scalar-first (w, x, y, z). shape is (M, 4).\n\n---\n**Example:**\n\n```python\n>>> # get all prims poses with respect to the world's frame.\n>>> # Returned shape is position (5, 3) and orientation (5, 4) for the example: 5 envs\n>>> positions, orientations = prims.get_world_poses()\n>>> positions\n[[ 1.5  -0.75  0.  ]\n [ 1.5   0.75  0.  ]\n [ 0.   -0.75  0.  ]\n [ 0.    0.75  0.  ]\n [-1.5  -0.75  0.  ]]\n>>> orientations\n[[1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]]\n>>>\n>>> # get only the prims poses with respect to the world's frame for the first, middle and last of the 5 envs.\n>>> # Returned shape is position (3, 3) and orientation (3, 4) for the example: 3 envs selected\n>>> positions, orientations = prims.get_world_poses(indices=np.array([0, 2, 4]))\n>>> positions\n[[ 1.5  -0.75  0.  ]\n [ 0.   -0.75  0.  ]\n [-1.5  -0.75  0.  ]]\n>>> orientations\n[[1. 0. 0. 0.]\n [1. 0. 0. 0.]\n [1. 0. 0. 0.]]\n```\n",
"snippet":"world_poses = robot_view.get_world_poses()\n",
"category":"method"
},
{
"title":"get_world_scales",
"description":"Get prim scales in the view with respect to the world's frame\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Returns:**\n\n * Union\\[np.ndarray, torch.Tensor, wp.indexedarray\\]: scales applied to the prim's dimensions in the world frame. shape is (M, 3).\n\n---\n**Example:**\n\n```python\n>>> # get all prims scales with respect to the world's frame.\n>>> # Returned shape is (5, 3) for the example: 5 envs\n>>> prims.get_world_scales()\n[[1. 1. 1.]\n [1. 1. 1.]\n [1. 1. 1.]\n [1. 1. 1.]\n [1. 1. 1.]]\n>>>\n>>> # get only the prims scales with respect to the world's frame for the first, middle and last of the 5 envs.\n>>> # Returned shape is (3, 3) for the example: 3 envs selected\n>>> prims.get_world_scales(indices=np.array([0, 2, 4]))\n[[1. 1. 1.]\n [1. 1. 1.]\n [1. 1. 1.]]\n```\n",
"snippet":"world_scales = robot_view.get_world_scales()\n",
"category":"method"
},
{
"title":"initialize",
"description":"Create a physics simulation view if not passed and set other properties using the PhysX tensor API\n\n*Note:*\nIf the articulation view has been added to the world scene (e.g., `world.scene.add(prims)`),\nit will be automatically initialized when the world is reset (e.g., `world.reset()`).\n\n*Warning:*\nThis method needs to be called after each hard reset (e.g., Stop + Play on the timeline)\nbefore interacting with any other class method.\n\n**Args:**\n\n * `physics_sim_view` (omni.physics.tensors.SimulationView, optional): current physics simulation view. Defaults to None.\n\n---\n**Example:**\n\n```python\n>>> prims.initialize()\n```\n",
"snippet":"robot_view.initialize()\n",
"category":"method"
},
{
"title":"initialize",
"description":"Create a physics simulation view if not passed and set other properties using the PhysX tensor API\n\n*Note:*\nFor this particular class, calling this method will do nothing\n\n**Args:**\n\n * `physics_sim_view` (omni.physics.tensors.SimulationView, optional): current physics simulation view. Defaults to None.\n\n---\n**Example:**\n\n```python\n>>> prims.initialize()\n```\n",
"snippet":"robot_view.initialize()\n",
"category":"method"
},
{
"title":"is_physics_handle_valid",
"description":"Check if articulation view's physics handler is initialized\n\n*Warning:*\nIf the physics handler is not valid many of the methods that requires PhysX will return None.\n\n**Returns:**\n\n * bool: False if .initialize() needs to be called again for the physics handle to be valid. Otherwise True\n\n---\n**Example:**\n\n```python\n>>> prims.is_physics_handle_valid()\nTrue\n```\n",
"snippet":"value = robot_view.is_physics_handle_valid()\n",
"category":"method"
},
{
"title":"is_valid",
"description":"Check that all prims have a valid USD Prim\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Returns:**\n\n * bool: True if all prim paths specified in the view correspond to a valid prim in stage. False otherwise.\n\n---\n**Example:**\n\n```python\n>>> prims.is_valid()\nTrue\n```\n",
"snippet":"value = robot_view.is_valid()\n",
"category":"method"
},
{
"title":"is_visual_material_applied",
"description":"Check if there is a visual material applied\n\n**Args:**\n\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n**Returns:**\n\n * List\\[bool\\]: True if there is a visual material applied is applied to the corresponding prim in the view. False otherwise.\n\n---\n**Example:**\n\n```python\n>>> # given a visual material that is applied only to the first and the last environment\n>>> prims.is_visual_material_applied()\n[True, False, False, False, True]\n>>>\n>>> # check for the first, middle and last of the 5 envs\n>>> prims.is_visual_material_applied(indices=np.array([0, 2, 4]))\n[True, False, True]\n```\n",
"snippet":"value = robot_view.is_visual_material_applied()\n",
"category":"method"
},
{
"title":"post_reset",
"description":"Reset the robots to their default states\n\n*Note:*\nFor the robots, in addition to configuring the root prim's default positions and spatial orientations\n(defined via the `set_default_state` method), the joint's positions, velocities, and efforts\n(defined via the `set_joints_default_state` method) and the joint's stiffness and dampings\n(defined via the `set_gains` method) are imposed\n\n---\n**Example:**\n\n```python\n>>> prims.post_reset()\n```\n",
"snippet":"robot_view.post_reset()\n",
"category":"method"
},
{
"title":"post_reset",
"description":"Reset the articulations to their default states\n\n*Note:*\nFor the articulations, in addition to configuring the root prim's default positions and spatial orientations\n(defined via the `set_default_state` method), the joint's positions, velocities, and efforts\n(defined via the `set_joints_default_state` method) and the joint stiffnesses and dampings\n(defined via the `set_gains` method) are imposed\n\n---\n**Example:**\n\n```python\n>>> prims.post_reset()\n```\n",
"snippet":"robot_view.post_reset()\n",
"category":"method"
},
{
"title":"post_reset",
"description":"Reset the prims to its default state (positions and orientations)\n\n---\n**Example:**\n\n```python\n>>> prims.post_reset()\n```\n",
"snippet":"robot_view.post_reset()\n",
"category":"method"
},
{
"title":"set_angular_velocities",
"description":"Set the angular velocities of the prims in the view\n\nThe method does this through the physx API only. It has to be called after initialization.\nNote: This method is not supported for the gpu pipeline. `set_velocities` method should be used instead.\n\n*Warning:*\nThis method will immediately set the articulation state\n\n**Args:**\n\n * `velocities` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\]): angular velocities to set the rigid prims to. shape is (M, 3).\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n*Hint:*\nThis method belongs to the methods used to set the articulation kinematic state:\n\n> `set_velocities` (`set_linear_velocities`, `set_angular_velocities`),\n> `set_joint_positions`, `set_joint_velocities`, `set_joint_efforts`\n\n---\n**Example:**\n\n```python\n>>> # set each articulation linear velocity to (0.1, 0.1, 0.1)\n>>> velocities = np.full((num_envs, 3), fill_value=0.1)\n>>> prims.set_angular_velocities(velocities)\n>>>\n>>> # set only the articulation linear velocities for the first, middle and last of the 5 envs\n>>> velocities = np.full((3, 3), fill_value=0.1)\n>>> prims.set_angular_velocities(velocities, indices=np.array([0, 2, 4]))\n```\n",
"snippet":"robot_view.set_angular_velocities()\n",
"category":"method"
},
{
"title":"set_armatures",
"description":"Set armatures for articulation joints in the view\n\nSearch for *\"Joint Armature\"* in for more details.\n\n**Args:**\n\n * `values` (Union\\[np.ndarray, torch.Tensor, wp.array\\]): armatures for articulation joints in the view. shape (M, K).\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `joint_indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): joint indices to specify which joints to manipulate. Shape (K,). Where K \\<= num of dofs. Defaults to None (i.e: all dofs).\n\n---\n**Example:**\n\n```python\n>>> # set all joint armatures to 0.05 for all envs\n>>> prims.set_armatures(np.full((num_envs, prims.num_dof), 0.05))\n>>>\n>>> # set only the finger joint (panda_finger_joint1 (7) and panda_finger_joint2 (8)) armatures\n>>> # for the first, middle and last of the 5 envs to 0.05\n>>> prims.set_armatures(np.full((3, 2), 0.05), indices=np.array([0,2,4]), joint_indices=np.array([7,8]))\n```\n",
"snippet":"robot_view.set_armatures(values=values)\n",
"category":"method"
},
{
"title":"set_body_coms",
"description":"Set body center of mass (COM) positions and orientations for articulation bodies in the view.\n\n**Args:**\n\n * `positions` (Union\\[np.ndarray, torch.Tensor, wp.array\\]): body center of mass positions for articulations in the view. shape (M, K, 3).\n * `orientations` (Union\\[np.ndarray, torch.Tensor, wp.array\\]): body center of mass orientations for articulations in the view. shape (M, K, 4).\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `body_indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): body indices to specify which bodies to manipulate. Shape (K,). Where K \\<= num of bodies. Defaults to None (i.e: all bodies).\n\n---\n**Example:**\n\n```python\n>>> # set the center of mass for all the articulation rigid bodies to the indicated values.\n>>> # Since there are 5 envs, the inertias are repeated 5 times\n>>> positions = np.tile(np.array([0.01, 0.02, 0.03]), (num_envs, prims.num_bodies, 1))\n>>> orientations = np.tile(np.array([1.0, 0.0, 0.0, 0.0]), (num_envs, prims.num_bodies, 1))\n>>> prims.set_body_coms(positions, orientations)\n>>>\n>>> # set the fingers center of mass: panda_leftfinger (10) and panda_rightfinger (11) to 0.2\n>>> # for the first, middle and last of the 5 envs\n>>> positions = np.tile(np.array([0.01, 0.02, 0.03]), (3, 2, 1))\n>>> orientations = np.tile(np.array([1.0, 0.0, 0.0, 0.0]), (3, 2, 1))\n>>> prims.set_body_coms(positions, orientations, indices=np.array([0, 2, 4]), body_indices=np.array([10, 11]))\n```\n",
"snippet":"robot_view.set_body_coms()\n",
"category":"method"
},
{
"title":"set_body_inertias",
"description":"Set body inertias for articulation bodies in the view.\n\n**Args:**\n\n * `values` (Union\\[np.ndarray, torch.Tensor, wp.array\\]): body inertias for articulations in the view. shape (M, K, 9).\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `body_indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): body indices to specify which bodies to manipulate. Shape (K,). Where K \\<= num of bodies. Defaults to None (i.e: all bodies).\n\n---\n**Example:**\n\n```python\n>>> # set the inertias for all the articulation rigid bodies to the indicated values.\n>>> # Since there are 5 envs, the inertias are repeated 5 times\n>>> inertias = np.tile(np.array([0.1, 0.0, 0.0, 0.0, 0.1, 0.0, 0.0, 0.0, 0.1]), (num_envs, prims.num_bodies, 1))\n>>> prims.set_body_inertias(inertias)\n>>>\n>>> # set the fingers inertias: panda_leftfinger (10) and panda_rightfinger (11) to 0.2\n>>> # for the first, middle and last of the 5 envs\n>>> inertias = np.tile(np.array([0.1, 0.0, 0.0, 0.0, 0.1, 0.0, 0.0, 0.0, 0.1]), (3, 2, 1))\n>>> prims.set_body_inertias(inertias, indices=np.array([0, 2, 4]), body_indices=np.array([10, 11]))\n```\n",
"snippet":"robot_view.set_body_inertias(values=values)\n",
"category":"method"
},
{
"title":"set_body_masses",
"description":"Set body masses for articulation bodies in the view\n\n**Args:**\n\n * `values` (Union\\[np.ndarray, torch.Tensor, wp.array\\]): body masses for articulations in the view. shape (M, K).\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `body_indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): body indices to specify which bodies to manipulate. Shape (K,). Where K \\<= num of bodies. Defaults to None (i.e: all bodies).\n\n---\n**Example:**\n\n```python\n>>> # set the masses for all the articulation rigid bodies to the indicated values.\n>>> # Since there are 5 envs, the masses are repeated 5 times\n>>> masses = np.tile(np.array([1.2, 1.1, 1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.2]), (num_envs, 1))\n>>> prims.set_body_masses(masses)\n>>>\n>>> # set the fingers masses: panda_leftfinger (10) and panda_rightfinger (11) to 0.2\n>>> # for the first, middle and last of the 5 envs\n>>> masses = np.tile(np.array([0.2, 0.2]), (3, 1))\n>>> prims.set_body_masses(masses, indices=np.array([0, 2, 4]), body_indices=np.array([10, 11]))\n```\n",
"snippet":"robot_view.set_body_masses(values=values)\n",
"category":"method"
},
{
"title":"set_default_state",
"description":"Set the default state of the prims (positions and orientations), that will be used after each reset.\n\n*Note:*\nThe default states will be set during post-reset (e.g., calling `.post_reset()` or `world.reset()` methods)\n\n**Args:**\n\n * `positions` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): positions in the world frame of the prim. shape is (M, 3). Defaults to None, which means left unchanged.\n * `orientations` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): quaternion orientations in the world frame of the prim. quaternion is scalar-first (w, x, y, z). shape is (M, 4). Defaults to None, which means left unchanged.\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n---\n**Example:**\n\n```python\n>>> # configure default states for all prims\n>>> positions = np.zeros((num_envs, 3))\n>>> positions[:, 0] = np.arange(num_envs)\n>>> orientations = np.tile(np.array([1.0, 0.0, 0.0, 0.0]), (num_envs, 1))\n>>> prims.set_default_state(positions=positions, orientations=orientations)\n>>>\n>>> # set default states during post-reset\n>>> prims.post_reset()\n```\n",
"snippet":"robot_view.set_default_state()\n",
"category":"method"
},
{
"title":"set_effort_modes",
"description":"Set effort modes for articulations in the view\n\n**Args:**\n\n * `mode` (str): effort mode to be applied to prims in the view: `acceleration` or `force`.\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `joint_indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): joint indices to specify which joints to manipulate. Shape (K,). Where K \\<= num of dofs. Defaults to None (i.e: all dofs).\n\n---\n**Example:**\n\n```python\n>>> # set the effort mode for all joints to 'force'\n>>> prims.set_effort_modes(\"force\")\n>>>\n>>> # set only the finger joints effort mode to 'force' for the first, middle and last of the 5 envs\n>>> prims.set_effort_modes(\"force\", indices=np.array([0, 2, 4]), joint_indices=np.array([7, 8]))\n```\n",
"snippet":"robot_view.set_effort_modes(mode=mode)\n",
"category":"method"
},
{
"title":"set_enabled_self_collisions",
"description":"Set the enable self collisions flag (`physxArticulation:enabledSelfCollisions`)\n\n**Args:**\n\n * `flags` (Union\\[np.ndarray, torch.Tensor, wp.array\\]): true to enable self collision. otherwise false. shape (M,)\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n---\n**Example:**\n\n```python\n>>> # enable the self collisions flag for all envs\n>>> prims.set_enabled_self_collisions(np.full((num_envs,), True))\n>>>\n>>> # enable the self collisions flag only for the first, middle and last of the 5 envs\n>>> prims.set_enabled_self_collisions(np.full((3,), True), indices=np.array([0, 2, 4]))\n```\n",
"snippet":"robot_view.set_enabled_self_collisions(flags=flags)\n",
"category":"method"
},
{
"title":"set_fixed_tendon_properties",
"description":"Set fixed tendon properties for articulations in the view\n\nSearch for *Fixed Tendon* in for more details\n\n**Args:**\n\n * `stiffnesses` (Union\\[np.ndarray, torch.Tensor, wp.array\\]): fixed tendon stiffnesses for articulations in the view. shape (M, K).\n * `dampings` (Union\\[np.ndarray, torch.Tensor, wp.array\\]): fixed tendon dampings for articulations in the view. shape (M, K).\n * `limit_stiffnesses` (Union\\[np.ndarray, torch.Tensor, wp.array\\]): fixed tendon limit stiffnesses for articulations in the view. shape (M, K).\n * `limits` (Union\\[np.ndarray, torch.Tensor, wp.array\\]): fixed tendon limits for articulations in the view. shape (M, K, 2).\n * `rest_lengths` (Union\\[np.ndarray, torch.Tensor, wp.array\\]): fixed tendon rest lengths for articulations in the view. shape (M, K).\n * `offsets` (Union\\[np.ndarray, torch.Tensor, wp.array\\]): fixed tendon offsets for articulations in the view. shape (M, K).\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n---\n**Example:**\n\n```python\n>>> # set the limit stiffnesses and dampings\n>>> # for the ShadowHand articulation that has 4 fixed tendons (prims.num_fixed_tendons)\n>>> limit_stiffnesses = np.full((num_envs, prims.num_fixed_tendons), fill_value=10.0)\n>>> dampings = np.full((num_envs, prims.num_fixed_tendons), fill_value=0.1)\n>>> prims.set_fixed_tendon_properties(dampings=dampings, limit_stiffnesses=limit_stiffnesses)\n```\n",
"snippet":"robot_view.set_fixed_tendon_properties()\n",
"category":"method"
},
{
"title":"set_friction_coefficients",
"description":"Set the friction coefficients for articulation joints in the view\n\nSearch for *\"Joint Friction Coefficient\"* in for more details.\n\n**Args:**\n\n * `values` (Union\\[np.ndarray, torch.Tensor, wp.array\\]): friction coefficients for articulation joints in the view. shape (M, K).\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `joint_indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): joint indices to specify which joints to manipulate. Shape (K,). Where K \\<= num of dofs. Defaults to None (i.e: all dofs).\n\n---\n**Example:**\n\n```python\n>>> # set all joint friction coefficients to 0.05 for all envs\n>>> prims.set_friction_coefficients(np.full((num_envs, prims.num_dof), 0.05))\n>>>\n>>> # set only the finger joint (panda_finger_joint1 (7) and panda_finger_joint2 (8)) friction coefficients\n>>> # for the first, middle and last of the 5 envs to 0.05\n>>> prims.set_friction_coefficients(np.full((3, 2), 0.05), indices=np.array([0,2,4]), joint_indices=np.array([7,8]))\n```\n",
"snippet":"robot_view.set_friction_coefficients(values=values)\n",
"category":"method"
},
{
"title":"set_gains",
"description":"Set the implicit Proportional-Derivative (PD) controller's Kps (stiffnesses) and Kds (dampings) of articulations in the view\n\n**Args:**\n\n * `kps` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): stiffness of the drives. shape is (M, K). Defaults to None.\n * `kds` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): damping of the drives. shape is (M, K).. Defaults to None.\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `joint_indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): joint indices to specify which joints to manipulate. Shape (K,). Where K \\<= num of dofs. Defaults to None (i.e: all dofs).\n * `save_to_usd` (bool, optional): True to save the gains in the usd. otherwise False.\n\n---\n**Example:**\n\n```python\n>>> # set the gains (stiffnesses and dampings) for all the articulation joints to the indicated values.\n>>> # Since there are 5 envs, the gains are repeated 5 times\n>>> stiffnesses = np.tile(np.array([100000, 100000, 100000, 100000, 80000, 80000, 80000, 50000, 50000]), (num_envs, 1))\n>>> dampings = np.tile(np.array([8000, 8000, 8000, 8000, 5000, 5000, 5000, 2000, 2000]), (num_envs, 1))\n>>> prims.set_gains(kps=stiffnesses, kds=dampings)\n>>>\n>>> # set the fingers gains (stiffnesses and dampings): panda_finger_joint1 (7) and panda_finger_joint2 (8)\n>>> # to 50000 and 2000 respectively for the first, middle and last of the 5 envs\n>>> stiffnesses = np.tile(np.array([50000, 50000]), (3, 1))\n>>> dampings = np.tile(np.array([2000, 2000]), (3, 1))\n>>> prims.set_gains(kps=stiffnesses, kds=dampings, indices=np.array([0, 2, 4]), joint_indices=np.array([7, 8]))\n```\n",
"snippet":"robot_view.set_gains()\n",
"category":"method"
},
{
"title":"set_joint_efforts",
"description":"Set the joint efforts of articulations in the view\n\n*Note:*\nThis method can be used for effort control. For this purpose, there must be no joint drive\nor the stiffness and damping must be set to zero.\n\n**Args:**\n\n * `efforts` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\]): efforts of articulations in the view to be set to in the next frame. shape is (M, K).\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `joint_indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): joint indices to specify which joints to manipulate. Shape (K,). Where K \\<= num of dofs. Defaults to None (i.e: all dofs).\n\n*Hint:*\nThis method belongs to the methods used to set the articulation kinematic states:\n\n> `set_velocities` (`set_linear_velocities`, `set_angular_velocities`),\n> `set_joint_positions`, `set_joint_velocities`, `set_joint_efforts`\n\n---\n**Example:**\n\n```python\n>>> # set the efforts for all the articulation joints to the indicated values.\n>>> # Since there are 5 envs, the joint efforts are repeated 5 times\n>>> efforts = np.tile(np.array([10, 20, 30, 40, 50, 60, 70, 80, 90]), (num_envs, 1))\n>>> prims.set_joint_efforts(efforts)\n>>>\n>>> # set the fingers efforts: panda_finger_joint1 (7) and panda_finger_joint2 (8) to 10\n>>> # for the first, middle and last of the 5 envs\n>>> efforts = np.tile(np.array([10, 10]), (3, 1))\n>>> prims.set_joint_efforts(efforts, indices=np.array([0, 2, 4]), joint_indices=np.array([7, 8]))\n```\n",
"snippet":"robot_view.set_joint_efforts(efforts=efforts)\n",
"category":"method"
},
{
"title":"set_joint_position_targets",
"description":"Set the joint position targets for the implicit Proportional-Derivative (PD) controllers\n\n*Note:*\nThis is an independent method for controlling joints. To apply multiple targets (position, velocity,\nand/or effort) in the same call, consider using the `apply_action` method\n\n**Args:**\n\n * `positions` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\]): joint position targets for the implicit PD controller. shape is (M, K).\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `joint_indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): joint indices to specify which joints to manipulate. Shape (K,). Where K \\<= num of dofs. Defaults to None (i.e: all dofs).\n\n*Hint:*\nHigh stiffness makes the joints snap faster and harder to the desired target,\nand higher damping smoothes but also slows down the joint's movement to target\n\n * For position control, set relatively high stiffness and low damping (to reduce vibrations)\n\n---\n**Example:**\n\n```python\n>>> # apply the target positions (to move all the robot joints) to the indicated values.\n>>> # Since there are 5 envs, the joint positions are repeated 5 times\n>>> positions = np.tile(np.array([0.0, -1.0, 0.0, -2.2, 0.0, 2.4, 0.8, 0.04, 0.04]), (num_envs, 1))\n>>> prims.set_joint_position_targets(positions)\n>>>\n>>> # close the robot fingers: panda_finger_joint1 (7) and panda_finger_joint2 (8) to 0.0\n>>> # for the first, middle and last of the 5 envs\n>>> positions = np.tile(np.array([0.0, 0.0]), (3, 1))\n>>> prims.set_joint_position_targets(positions, indices=np.array([0, 2, 4]), joint_indices=np.array([7, 8]))\n```\n",
"snippet":"robot_view.set_joint_position_targets(positions=positions)\n",
"category":"method"
},
{
"title":"set_joint_positions",
"description":"Set the joint positions of articulations in the view\n\n*Warning:*\nThis method will immediately set (teleport) the affected joints to the indicated value.\nUse the `set_joint_position_targets` or the `apply_action` methods to control the articulation joints.\n\n**Args:**\n\n * `positions` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\]): joint positions of articulations in the view to be set to in the next frame. shape is (M, K).\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `joint_indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): joint indices to specify which joints to manipulate. Shape (K,). Where K \\<= num of dofs. Defaults to None (i.e: all dofs).\n\n*Hint:*\nThis method belongs to the methods used to set the articulation kinematic states:\n\n> `set_velocities` (`set_linear_velocities`, `set_angular_velocities`),\n> `set_joint_positions`, `set_joint_velocities`, `set_joint_efforts`\n\n---\n**Example:**\n\n```python\n>>> # set all the articulation joints.\n>>> # Since there are 5 envs, the joint positions are repeated 5 times\n>>> positions = np.tile(np.array([0.0, -1.0, 0.0, -2.2, 0.0, 2.4, 0.8, 0.04, 0.04]), (num_envs, 1))\n>>> prims.set_joint_positions(positions)\n>>>\n>>> # set only the fingers in closed position: panda_finger_joint1 (7) and panda_finger_joint2 (8) to 0.0\n>>> # for the first, middle and last of the 5 envs\n>>> positions = np.tile(np.array([0.0, 0.0]), (3, 1))\n>>> prims.set_joint_positions(positions, indices=np.array([0, 2, 4]), joint_indices=np.array([7, 8]))\n```\n",
"snippet":"robot_view.set_joint_positions(positions=positions)\n",
"category":"method"
},
{
"title":"set_joint_velocities",
"description":"Set the joint velocities of articulations in the view\n\n*Warning:*\nThis method will immediately set the affected joints to the indicated value.\nUse the `set_joint_velocity_targets` or the `apply_action` methods to control the articulation joints.\n\n**Args:**\n\n * `velocities` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\]): joint velocities of articulations in the view to be set to in the next frame. shape is (M, K).\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `joint_indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): joint indices to specify which joints to manipulate. Shape (K,). Where K \\<= num of dofs. Defaults to None (i.e: all dofs).\n\n*Hint:*\nThis method belongs to the methods used to set the articulation kinematic states:\n\n> `set_velocities` (`set_linear_velocities`, `set_angular_velocities`),\n> `set_joint_positions`, `set_joint_velocities`, `set_joint_efforts`\n\n---\n**Example:**\n\n```python\n>>> # set the velocities for all the articulation joints to the indicated values.\n>>> # Since there are 5 envs, the joint velocities are repeated 5 times\n>>> velocities = np.tile(np.array([0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9]), (num_envs, 1))\n>>> prims.set_joint_velocities(velocities)\n>>>\n>>> # set the fingers velocities: panda_finger_joint1 (7) and panda_finger_joint2 (8) to -0.1\n>>> # for the first, middle and last of the 5 envs\n>>> velocities = np.tile(np.array([-0.1, -0.1]), (3, 1))\n>>> prims.set_joint_velocities(velocities, indices=np.array([0, 2, 4]), joint_indices=np.array([7, 8]))\n```\n",
"snippet":"robot_view.set_joint_velocities(velocities=velocities)\n",
"category":"method"
},
{
"title":"set_joint_velocity_targets",
"description":"Set the joint velocity targets for the implicit Proportional-Derivative (PD) controllers\n\n*Note:*\nThis is an independent method for controlling joints. To apply multiple targets (position, velocity,\nand/or effort) in the same call, consider using the `apply_action` method\n\n**Args:**\n\n * `velocities` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\]): joint velocity targets for the implicit PD controller. shape is (M, K).\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `joint_indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): joint indices to specify which joints to manipulate. Shape (K,). Where K \\<= num of dofs. Defaults to None (i.e: all dofs).\n\n*Hint:*\nHigh stiffness makes the joints snap faster and harder to the desired target,\nand higher damping smoothes but also slows down the joint's movement to target\n\n * For velocity control, stiffness must be set to zero with a non-zero damping\n\n---\n**Example:**\n\n```python\n>>> # apply the target velocities for all the articulation joints to the indicated values.\n>>> # Since there are 5 envs, the joint velocities are repeated 5 times\n>>> velocities = np.tile(np.array([0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9]), (num_envs, 1))\n>>> prims.set_joint_velocity_targets(velocities)\n>>>\n>>> # apply the fingers target velocities: panda_finger_joint1 (7) and panda_finger_joint2 (8) to -1.0\n>>> # for the first, middle and last of the 5 envs\n>>> velocities = np.tile(np.array([-0.1, -0.1]), (3, 1))\n>>> prims.set_joint_velocity_targets(velocities, indices=np.array([0, 2, 4]), joint_indices=np.array([7, 8]))\n```\n",
"snippet":"robot_view.set_joint_velocity_targets(velocities=velocities)\n",
"category":"method"
},
{
"title":"set_joints_default_state",
"description":"Set the joints default state (joint positions, velocities and efforts) to be applied after each reset.\n\n*Note:*\nThe default states will be set during post-reset (e.g., calling `.post_reset()` or `world.reset()` methods)\n\n**Args:**\n\n * `positions` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): default joint positions. shape is (N, num of dofs). Defaults to None.\n * `velocities` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): default joint velocities. shape is (N, num of dofs). Defaults to None.\n * `efforts` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): default joint efforts. shape is (N, num of dofs). Defaults to None.\n\n---\n**Example:**\n\n```python\n>>> # configure default joint states for all articulations\n>>> positions = np.tile(np.array([0.0, -1.0, 0.0, -2.2, 0.0, 2.4, 0.8, 0.04, 0.04]), (num_envs, 1))\n>>> prims.set_joints_default_state(\n...     positions=positions,\n...     velocities=np.zeros((num_envs, prims.num_dof)),\n...     efforts=np.zeros((num_envs, prims.num_dof))\n... )\n>>>\n>>> # set default states during post-reset\n>>> prims.post_reset()\n```\n",
"snippet":"robot_view.set_joints_default_state()\n",
"category":"method"
},
{
"title":"set_linear_velocities",
"description":"Set the linear velocities of the prims in the view\n\nThe method does this through the PhysX API only. It has to be called after initialization.\nNote: This method is not supported for the gpu pipeline. `set_velocities` method should be used instead.\n\n*Warning:*\nThis method will immediately set the articulation state\n\n**Args:**\n\n * `velocities` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\]): linear velocities to set the rigid prims to. shape is (M, 3).\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n*Hint:*\nThis method belongs to the methods used to set the articulation kinematic state:\n\n> `set_velocities` (`set_linear_velocities`, `set_angular_velocities`),\n> `set_joint_positions`, `set_joint_velocities`, `set_joint_efforts`\n\n---\n**Example:**\n\n```python\n>>> # set each articulation linear velocity to (1.0, 1.0, 1.0)\n>>> velocities = np.ones((num_envs, 3))\n>>> prims.set_linear_velocities(velocities)\n>>>\n>>> # set only the articulation linear velocities for the first, middle and last of the 5 envs\n>>> velocities = np.ones((3, 3))\n>>> prims.set_linear_velocities(velocities, indices=np.array([0, 2, 4]))\n```\n",
"snippet":"robot_view.set_linear_velocities()\n",
"category":"method"
},
{
"title":"set_local_poses",
"description":"Set prim poses in the view with respect to the local frame (the prim's parent frame).\n\n*Warning:*\nThis method will change (teleport) the prim poses immediately to the indicated value\n\n**Args:**\n\n * `translations` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): translations in the local frame of the prims (with respect to its parent prim). shape is (M, 3). Defaults to None, which means left unchanged.\n * `orientations` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): quaternion orientations in the local frame of the prims. quaternion is scalar-first (w, x, y, z). shape is (M, 4). Defaults to None, which means left unchanged.\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n*Hint:*\nThis method belongs to the methods used to set the prim state\n\n---\n**Example:**\n\n```python\n>>> # reposition all articulations\n>>> positions = np.zeros((num_envs, 3))\n>>> positions[:,0] = np.arange(num_envs)\n>>> orientations = np.tile(np.array([1.0, 0.0, 0.0, 0.0]), (num_envs, 1))\n>>> prims.set_local_poses(positions, orientations)\n>>>\n>>> # reposition only the articulations for the first, middle and last of the 5 envs\n>>> positions = np.zeros((3, 3))\n>>> positions[:,1] = np.arange(3)\n>>> orientations = np.tile(np.array([1.0, 0.0, 0.0, 0.0]), (3, 1))\n>>> prims.set_local_poses(positions, orientations, indices=np.array([0, 2, 4]))\n```\n",
"snippet":"robot_view.set_local_poses()\n",
"category":"method"
},
{
"title":"set_local_poses",
"description":"Set prim poses in the view with respect to the local frame (the prim's parent frame)\n\n*Warning:*\nThis method will change (teleport) the prim poses immediately to the indicated value\n\n**Args:**\n\n * `translations` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): translations in the local frame of the prims (with respect to its parent prim). shape is (M, 3). Defaults to None, which means left unchanged.\n * `orientations` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): quaternion orientations in the local frame of the prims. quaternion is scalar-first (w, x, y, z). shape is (M, 4). Defaults to None, which means left unchanged.\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n*Hint:*\nThis method belongs to the methods used to set the prim state\n\n---\n**Example:**\n\n```python\n>>> # reposition all prims\n>>> positions = np.zeros((num_envs, 3))\n>>> positions[:,0] = np.arange(num_envs)\n>>> orientations = np.tile(np.array([1.0, 0.0, 0.0, 0.0]), (num_envs, 1))\n>>> prims.set_local_poses(positions, orientations)\n>>>\n>>> # reposition only the prims for the first, middle and last of the 5 envs\n>>> positions = np.zeros((3, 3))\n>>> positions[:,1] = np.arange(3)\n>>> orientations = np.tile(np.array([1.0, 0.0, 0.0, 0.0]), (3, 1))\n>>> prims.set_local_poses(positions, orientations, indices=np.array([0, 2, 4]))\n```\n",
"snippet":"robot_view.set_local_poses()\n",
"category":"method"
},
{
"title":"set_local_scales",
"description":"Set prim scales in the view with respect to the local frame (the prim's parent frame)\n\n**Args:**\n\n * `scales` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\]): scales to be applied to the prim's dimensions in the view. shape is (M, 3).\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n---\n**Example:**\n\n```python\n>>> # set the scale for all prims. Since there are 5 envs, the scale is repeated 5 times\n>>> scales = np.tile(np.array([1.0, 0.75, 0.5]), (num_envs, 1))\n>>> prims.set_local_scales(scales)\n>>>\n>>> # set the scale for the first, middle and last of the 5 envs\n>>> scales = np.tile(np.array([1.0, 0.75, 0.5]), (3, 1))\n>>> prims.set_local_scales(scales, indices=np.array([0, 2, 4]))\n```\n",
"snippet":"robot_view.set_local_scales(scales=scales)\n",
"category":"method"
},
{
"title":"set_max_efforts",
"description":"Set maximum efforts for articulation in the view\n\n**Args:**\n\n * `values` (Union\\[np.ndarray, torch.Tensor, wp.array\\]): maximum efforts for articulations in the view. shape (M, K).\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `joint_indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): joint indices to specify which joints to manipulate. Shape (K,). Where K \\<= num of dofs. Defaults to None (i.e: all dofs).\n\n---\n**Example:**\n\n```python\n>>> # set the max efforts for all the articulation joints to the indicated values.\n>>> # Since there are 5 envs, the joint efforts are repeated 5 times\n>>> max_efforts = np.tile(np.array([10000, 9000, 8000, 7000, 6000, 5000, 4000, 1000, 1000]), (num_envs, 1))\n>>> prims.set_max_efforts(max_efforts)\n>>>\n>>> # set the fingers max efforts: panda_finger_joint1 (7) and panda_finger_joint2 (8) to 1000\n>>> # for the first, middle and last of the 5 envs\n>>> max_efforts = np.tile(np.array([1000, 1000]), (3, 1))\n>>> prims.set_max_efforts(max_efforts, indices=np.array([0, 2, 4]), joint_indices=np.array([7, 8]))\n```\n",
"snippet":"robot_view.set_max_efforts(values=values)\n",
"category":"method"
},
{
"title":"set_sleep_thresholds",
"description":"Set the threshold for articulations to enter a sleep state\n\nSearch for *Articulations and Sleeping* in for more details\n\n**Args:**\n\n * `thresholds` (Union\\[np.ndarray, torch.Tensor, wp.array\\]): sleep thresholds to be applied. shape (M,).\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n---\n**Example:**\n\n```python\n>>> # set the sleep threshold for all envs\n>>> prims.set_sleep_thresholds(np.full((num_envs,), 0.01))\n>>>\n>>> # set only the sleep threshold for the first, middle and last of the 5 envs\n>>> prims.set_sleep_thresholds(np.full((3,), 0.01), indices=np.array([0, 2, 4]))\n```\n",
"snippet":"robot_view.set_sleep_thresholds(thresholds=thresholds)\n",
"category":"method"
},
{
"title":"set_solver_position_iteration_counts",
"description":"Set the solver (position) iteration count for the articulations\n\nThe solver iteration count determines how accurately contacts, drives, and limits are resolved.\nSearch for *Solver Iteration Count* in for more details.\n\n*Warning:*\nSetting a higher number of iterations may improve the fidelity of the simulation, although it may affect its performance.\n\n**Args:**\n\n * `counts` (Union\\[np.ndarray, torch.Tensor, wp.array\\]): number of iterations for the solver. Shape (M,).\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n---\n**Example:**\n\n```python\n>>> # set the position iteration count for all envs\n>>> prims.set_solver_position_iteration_counts(np.full((num_envs,), 64))\n>>>\n>>> # set only the position iteration count for the first, middle and last of the 5 envs\n>>> prims.set_solver_position_iteration_counts(np.full((3,), 64), indices=np.array([0, 2, 4]))\n```\n",
"snippet":"robot_view.set_solver_position_iteration_counts(counts=counts)\n",
"category":"method"
},
{
"title":"set_solver_velocity_iteration_counts",
"description":"Set the solver (velocity) iteration count for the articulations\n\nThe solver iteration count determines how accurately contacts, drives, and limits are resolved.\nSearch for *Solver Iteration Count* in for more details.\n\n*Warning:*\nSetting a higher number of iterations may improve the fidelity of the simulation, although it may affect its performance.\n\n**Args:**\n\n * `counts` (Union\\[np.ndarray, torch.Tensor, wp.array\\]): number of iterations for the solver. Shape (M,).\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n---\n**Example:**\n\n```python\n>>> # set the velocity iteration count for all envs\n>>> prims.set_solver_velocity_iteration_counts(np.full((num_envs,), 64))\n>>>\n>>> # set only the velocity iteration count for the first, middle and last of the 5 envs\n>>> prims.set_solver_velocity_iteration_counts(np.full((3,), 64), indices=np.array([0, 2, 4]))\n```\n",
"snippet":"robot_view.set_solver_velocity_iteration_counts(counts=counts)\n",
"category":"method"
},
{
"title":"set_stabilization_thresholds",
"description":"Set the mass-normalized kinetic energy below which the articulation may participate in stabilization\n\nSearch for *Stabilization Threshold* in for more details\n\n**Args:**\n\n * `thresholds` (Union\\[np.ndarray, torch.Tensor, wp.array\\]): stabilization thresholds to be applied. Shape (M,).\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n---\n**Example:**\n\n```python\n>>> # set the stabilization threshold for all envs\n>>> prims.set_stabilization_thresholds(np.full((num_envs,), 0.005))\n>>>\n>>> # set only the stabilization threshold for the first, middle and last of the 5 envs\n>>> prims.set_stabilization_thresholds(np.full((3,), 0.0051), indices=np.array([0, 2, 4]))\n```\n",
"snippet":"robot_view.set_stabilization_thresholds(thresholds=thresholds)\n",
"category":"method"
},
{
"title":"set_velocities",
"description":"Set the linear and angular velocities of the prims in the view at once.\n\nThe method does this through the PhysX API only. It has to be called after initialization\n\n*Warning:*\nThis method will immediately set the articulation state\n\n**Args:**\n\n * `velocities` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\]): linear and angular velocities respectively to set the rigid prims to. shape is (M, 6).\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n*Hint:*\nThis method belongs to the methods used to set the articulation kinematic state:\n\n> `set_velocities` (`set_linear_velocities`, `set_angular_velocities`),\n> `set_joint_positions`, `set_joint_velocities`, `set_joint_efforts`\n\n---\n**Example:**\n\n```python\n>>> # set each articulation linear velocity to (1., 1., 1.) and angular velocity to (.1, .1, .1)\n>>> velocities = np.ones((num_envs, 6))\n>>> velocities[:,3:] = 0.1\n>>> prims.set_velocities(velocities)\n>>>\n>>> # set only the articulation velocities for the first, middle and last of the 5 envs\n>>> velocities = np.ones((3, 6))\n>>> velocities[:,3:] = 0.1\n>>> prims.set_velocities(velocities, indices=np.array([0, 2, 4]))\n```\n",
"snippet":"robot_view.set_velocities()\n",
"category":"method"
},
{
"title":"set_visibilities",
"description":"Set the visibilities of the prims in stage\n\n**Args:**\n\n * `visibilities` (Union\\[np.ndarray, torch.Tensor, wp.array\\]): flag to set the visibilities of the usd prims in stage. Shape (M,). Where M \\<= size of the encapsulated prims in the view.\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Defaults to None (i.e: all prims in the view).\n\n---\n**Example:**\n\n```python\n>>> # make all prims not visible in the stage\n>>> prims.set_visibilities(visibilities=[False] * num_envs)\n```\n",
"snippet":"robot_view.set_visibilities(visibilities=visibilities)\n",
"category":"method"
},
{
"title":"set_world_poses",
"description":"Set poses of prims in the view with respect to the world's frame.\n\n*Warning:*\nThis method will change (teleport) the prim poses immediately to the indicated value\n\n**Args:**\n\n * `positions` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): positions in the world frame of the prim. shape is (M, 3). Defaults to None, which means left unchanged.\n * `orientations` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): quaternion orientations in the world frame of the prims. quaternion is scalar-first (w, x, y, z). shape is (M, 4). Defaults to None, which means left unchanged.\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n*Hint:*\nThis method belongs to the methods used to set the prim state\n\n---\n**Example:**\n\n```python\n>>> # reposition all articulations in row (x-axis)\n>>> positions = np.zeros((num_envs, 3))\n>>> positions[:,0] = np.arange(num_envs)\n>>> orientations = np.tile(np.array([1.0, 0.0, 0.0, 0.0]), (num_envs, 1))\n>>> prims.set_world_poses(positions, orientations)\n>>>\n>>> # reposition only the articulations for the first, middle and last of the 5 envs in column (y-axis)\n>>> positions = np.zeros((3, 3))\n>>> positions[:,1] = np.arange(3)\n>>> orientations = np.tile(np.array([1.0, 0.0, 0.0, 0.0]), (3, 1))\n>>> prims.set_world_poses(positions, orientations, indices=np.array([0, 2, 4]))\n```\n",
"snippet":"robot_view.set_world_poses()\n",
"category":"method"
},
{
"title":"set_world_poses",
"description":"Set prim poses in the view with respect to the world's frame\n\n*Warning:*\nThis method will change (teleport) the prim poses immediately to the indicated value\n\n**Args:**\n\n * `positions` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): positions in the world frame of the prims. shape is (M, 3). Defaults to None, which means left unchanged.\n * `orientations` (Optional\\[Union\\[np.ndarray, torch.Tensor, wp.array\\]\\], optional): quaternion orientations in the world frame of the prims. quaternion is scalar-first (w, x, y, z). shape is (M, 4). Defaults to None, which means left unchanged.\n * `indices` (Optional\\[Union\\[np.ndarray, list, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to query. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n*Hint:*\nThis method belongs to the methods used to set the prim state\n\n---\n**Example:**\n\n```python\n>>> # reposition all prims in row (x-axis)\n>>> positions = np.zeros((num_envs, 3))\n>>> positions[:,0] = np.arange(num_envs)\n>>> orientations = np.tile(np.array([1.0, 0.0, 0.0, 0.0]), (num_envs, 1))\n>>> prims.set_world_poses(positions, orientations)\n>>>\n>>> # reposition only the prims for the first, middle and last of the 5 envs in column (y-axis)\n>>> positions = np.zeros((3, 3))\n>>> positions[:,1] = np.arange(3)\n>>> orientations = np.tile(np.array([1.0, 0.0, 0.0, 0.0]), (3, 1))\n>>> prims.set_world_poses(positions, orientations, indices=np.array([0, 2, 4]))\n```\n",
"snippet":"robot_view.set_world_poses()\n",
"category":"method"
},
{
"title":"switch_control_mode",
"description":"Switch control mode between `\"position\"`, `\"velocity\"`, or `\"effort\"` for all joints\n\nThis method will set the implicit Proportional-Derivative (PD) controller's Kps (stiffnesses) and Kds (dampings),\ndefined via the `set_gains` method, of the selected articulations and joints according to the following rule:\n\n| Control mode | Stiffnesses | Dampings |\n|--------------|-------------|----------|\n| `\"position\"` | Kps         | Kds      |\n| `\"velocity\"` | 0           | Kds      |\n| `\"effort\"`   | 0           | 0        |\n\n**Args:**\n\n * `mode` (str): control mode to switch the articulations specified to. It can be `\"position\"`, `\"velocity\"`, or `\"effort\"`\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n * `joint_indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): joint indices to specify which joints to manipulate. Shape (K,). Where K \\<= num of dofs. Defaults to None (i.e: all dofs).\n\n---\n**Example:**\n\n```python\n>>> # set 'velocity' as control mode for all joints\n>>> prims.switch_control_mode(\"velocity\")\n>>>\n>>> # set 'effort' as control mode only for the fingers: panda_finger_joint1 (7) and panda_finger_joint2 (8)\n>>> # for the first, middle and last of the 5 envs\n>>> prims.switch_control_mode(\"effort\", indices=np.array([0, 2, 4]), joint_indices=np.array([7, 8]))\n```\n",
"snippet":"robot_view.switch_control_mode(mode=mode)\n",
"category":"method"
},
{
"title":"switch_dof_control_mode",
"description":"Switch control mode between `\"position\"`, `\"velocity\"`, or `\"effort\"` for the specified DOF\n\nThis method will set the implicit Proportional-Derivative (PD) controller's Kps (stiffnesses) and Kds (dampings),\ndefined via the `set_gains` method, of the selected DOF according to the following rule:\n\n| Control mode | Stiffnesses | Dampings |\n|--------------|-------------|----------|\n| `\"position\"` | Kps         | Kds      |\n| `\"velocity\"` | 0           | Kds      |\n| `\"effort\"`   | 0           | 0        |\n\n**Args:**\n\n * `mode` (str): control mode to switch the DOF specified to. It can be `\"position\"`, `\"velocity\"` or `\"effort\"`\n * `dof_index` (int): dof index to switch the control mode of.\n * `indices` (Optional\\[Union\\[np.ndarray, List, torch.Tensor, wp.array\\]\\], optional): indices to specify which prims to manipulate. Shape (M,). Where M \\<= size of the encapsulated prims in the view. Defaults to None (i.e: all prims in the view).\n\n---\n**Example:**\n\n```python\n>>> # set 'velocity' as control mode for the panda_joint1 (0) joint for all envs\n>>> prims.switch_dof_control_mode(\"velocity\", dof_index=0)\n>>>\n>>> # set 'effort' as control mode for the panda_joint1 (0) for the first, middle and last of the 5 envs\n>>> prims.switch_dof_control_mode(\"effort\", dof_index=0, indices=np.array([0, 2, 4]))\n```\n",
"snippet":"robot_view.switch_dof_control_mode(mode=mode, dof_index=dof_index)\n",
"category":"method"
}
]
}
]
},
{
"title":"Scenes",
"snippets":[
{
"title":"Scene",
"snippets":[
{
"title":"import ...",
"description":"Import class",
"snippet":"from omni.isaac.core.scenes import Scene\n",
"category":"import"
},
{
"title":"Scene",
"description":"Provide methods to add objects of interest in the stage to retrieve their information and set their\nreset default state in an easy way\n\n---\n**Example:**\n\n```python\n>>> from omni.isaac.core.scenes import Scene\n>>>\n>>> scene = Scene()\n>>> scene\n<omni.isaac.core.scenes.scene.Scene object at 0x...>\n```\n",
"snippet":"scene = Scene()\n",
"category":"class"
},
{
"title":"add",
"description":"Add an object to the scene registry\n\n**Args:**\n\n * `obj` (XFormPrim): object to be added\n\n**Raises:**\n\n * Exception: The object type is not supported yet\n\n**Returns:**\n\n * XFormPrim: object\n\n---\n**Example:**\n\n```python\n>>> from omni.isaac.core.prims import XFormPrimView\n>>>\n>>> prims = XFormPrimView(prim_paths_expr=\"/World\")\n>>> scene.add(prims)\n<omni.isaac.core.prims.xform_prim_view.XFormPrimView object at 0x...>\n```\n",
"snippet":"value = scene.add(obj=obj)\n",
"category":"method"
},
{
"title":"add_default_ground_plane",
"description":"Create a ground plane (using the default asset for Isaac Sim environments) and add it to the scene registry\n\n**Args:**\n\n * `z_position` (float, optional): ground plane position in the z-axis. Defaults to 0.\n * `name` (str, optional): shortname to be used as a key by Scene class. Note: needs to be unique if the object is added to the Scene. Defaults to \"default\\_ground\\_plane\".\n * `prim_path` (str, optional): prim path of the prim to create. Defaults to \"/World/defaultGroundPlane\".\n * `static_friction` (float, optional): static friction coefficient. Defaults to 0.5.\n * `dynamic_friction` (float, optional): dynamic friction coefficient. Defaults to 0.5.\n * `restitution` (float, optional): restitution coefficient. Defaults to 0.8.\n\n**Returns:**\n\n * GroundPlane: ground plane instance\n\n---\n**Example:**\n\n```python\n>>> scene.add_default_ground_plane()\nserver...\n<omni.isaac.core.objects.ground_plane.GroundPlane object at 0x...>\n```\n",
"snippet":"value = scene.add_default_ground_plane()\n",
"category":"method"
},
{
"title":"add_ground_plane",
"description":"Create a ground plane and add it to the scene registry\n\n**Args:**\n\n * `size` (Optional\\[float\\], optional): length of each edge. Defaults to 5000.0.\n * `z_position` (float, optional): ground plane position in the z-axis. Defaults to 0.\n * `name` (str, optional): shortname to be used as a key by Scene class. Note: needs to be unique if the object is added to the Scene. Defaults to \"ground\\_plane\".\n * `prim_path` (str, optional): prim path of the prim to create. Defaults to \"/World/groundPlane\".\n * `static_friction` (float, optional): static friction coefficient. Defaults to 0.5.\n * `dynamic_friction` (float, optional): dynamic friction coefficient. Defaults to 0.5.\n * `restitution` (float, optional): restitution coefficient. Defaults to 0.8.\n * `color` (Optional\\[np.ndarray\\], optional): color of the visual plane. Defaults to None, which means 50% gray\n\n**Returns:**\n\n * GroundPlane: ground plane instance\n\n---\n**Example:**\n\n```python\n>>> scene.add_ground_plane()\n<omni.isaac.core.objects.ground_plane.GroundPlane object at 0x...>\n```\n",
"snippet":"value = scene.add_ground_plane()\n",
"category":"method"
},
{
"title":"clear",
"description":"Clear the stage from all added objects to the scene registry.\n\n**Args:**\n\n * `registry_only` (bool, optional): True to remove the object from the scene registry only and not the USD. Defaults to False.\n\n---\n**Example:**\n\n```python\n>>> scene.clear()\n```\n",
"snippet":"scene.clear()\n",
"category":"method"
},
{
"title":"compute_object_AABB",
"description":"Compute the bounding box points (minimum and maximum) of a registered object given its name\n\n*Warning:*\nThe bounding box computations should be enabled, via the `enable_bounding_boxes_computations` method,\nbefore querying the Axis-Aligned Bounding Box (AABB) of an object\n\n**Args:**\n\n * `name` (str): object name\n\n**Raises:**\n\n * Exception: If the bounding box computation is not enabled\n\n**Returns:**\n\n * Tuple\\[np.ndarray, np.ndarray\\]: bounding box points (minimum and maximum)\n\n---\n**Example:**\n\n```python\n>>> scene.enable_bounding_boxes_computations()\n>>>\n>>> bbox = scene.compute_object_AABB(\"ground_plane\")\n>>> bbox[0]  # minimum\narray([-50., -50.,  0.])\n>>> bbox[1]  # maximum\narray([50., 50.,  0.])\n```\n",
"snippet":"value = scene.compute_object_AABB(name=name)\n",
"category":"method"
},
{
"title":"disable_bounding_boxes_computations",
"description":"Disable the bounding boxes computations\n\n---\n**Example:**\n\n```python\n>>> scene.disable_bounding_boxes_computations()\n```\n",
"snippet":"scene.disable_bounding_boxes_computations()\n",
"category":"method"
},
{
"title":"enable_bounding_boxes_computations",
"description":"Enable the bounding boxes computations\n\n---\n**Example:**\n\n```python\n>>> scene.enable_bounding_boxes_computations()\n```\n",
"snippet":"scene.enable_bounding_boxes_computations()\n",
"category":"method"
},
{
"title":"get_object",
"description":"Get a registered object by its name if exists otherwise None\n\n*Note:*\nObject can be registered via the `add` method\n\n**Args:**\n\n    name str: object name\n\n**Returns:**\n\n * XFormPrim: object if it exists otherwise None\n\n---\n**Example:**\n\n```python\n>>> # given a default ground plane named 'default_ground_plane'\n>>> scene.get_object(\"default_ground_plane\")\n<omni.isaac.core.objects.ground_plane.GroundPlane object at 0x...>\n```\n",
"snippet":"object = scene.get_object(name=name)\n",
"category":"method"
},
{
"title":"object_exists",
"description":"Check if an object exists in the scene registry\n\n**Args:**\n\n * `name` (str): object name\n\n**Returns:**\n\n * bool: whether the object exists in the scene registry or not\n\n---\n**Example:**\n\n```python\n>>> # given a default ground plane named 'default_ground_plane'\n>>> scene.object_exists(\"default_ground_plane\")\nTrue\n```\n",
"snippet":"value = scene.object_exists(name=name)\n",
"category":"method"
},
{
"title":"post_reset",
"description":"Call the `post_reset` method on all added objects to the scene registry\n\n---\n**Example:**\n\n```python\n>>> scene.post_reset()\n```\n",
"snippet":"scene.post_reset()\n",
"category":"method"
},
{
"title":"remove_object",
"description":"Remove and object from the scene registry and the USD stage if specified (enable by default)\n\n**Args:**\n\n * `name` (str): Name of the prim to be removed.\n * `registry_only` (bool, optional): True to remove the object from the scene registry only and not the USD. Defaults to False.\n\n---\n**Example:**\n\n```python\n>>> # given a default ground plane named 'default_ground_plane'\n>>> scene.remove_object(\"default_ground_plane\")\n```\n",
"snippet":"scene.remove_object(name=name)\n",
"category":"method"
},
{
"title":"stage",
"description":"**Returns:**\n\n * Usd.Stage: current USD stage\n\n---\n**Example:**\n\n```python\n>>> scene.stage\nUsd.Stage.Open(rootLayer=Sdf.Find('anon:0x...usd'), sessionLayer=Sdf.Find('anon:0x...usda'), pathResolverContext=<invalid repr>)\n```\n",
"snippet":"stage = scene.stage\n",
"category":"property"
}
]
},
{
"title":"SceneRegistry",
"snippets":[
{
"title":"import ...",
"description":"Import class",
"snippet":"from omni.isaac.core.scenes import SceneRegistry\n",
"category":"import"
},
{
"title":"SceneRegistry",
"description":"Class to keep track of the different types of objects added to the scene\n\n---\n**Example:**\n\n```python\n>>> from omni.isaac.core.scenes import SceneRegistry\n>>>\n>>> scene_registry = SceneRegistry()\n>>> scene_registry\n<omni.isaac.core.scenes.scene_registry.SceneRegistry object at 0x...>\n```\n",
"snippet":"scene_registry = SceneRegistry()\n",
"category":"class"
},
{
"title":"add_articulated_system",
"description":"Register a `Articulation` (or subclass) object\n\n**Args:**\n\n * `name` (str): object name\n * `articulated_system` (Articulation): object\n",
"snippet":"scene_registry.add_articulated_system(name=name, articulated_system=articulated_system)\n",
"category":"method"
},
{
"title":"add_articulated_view",
"description":"Register a `ArticulationView` (or subclass) object\n\n**Args:**\n\n * `name` (str): object name\n * `articulated_view` (ArticulationView): object\n",
"snippet":"scene_registry.add_articulated_view(name=name, articulated_view=articulated_view)\n",
"category":"method"
},
{
"title":"add_cloth",
"description":"Register a `ClothPrim` (or subclass) object\n\n**Args:**\n\n * `name` (str): object name\n * `cloth` (ClothPrim): object\n",
"snippet":"scene_registry.add_cloth(name=name, cloth=cloth)\n",
"category":"method"
},
{
"title":"add_cloth_view",
"description":"Register a `ClothPrimView` (or subclass) object\n\n**Args:**\n\n * `name` (str): object name\n * `cloth_prim_view` (ClothPrimView): object\n",
"snippet":"scene_registry.add_cloth_view(name=name, cloth_prim_view=cloth_prim_view)\n",
"category":"method"
},
{
"title":"add_deformable",
"description":"Register a `DeformablePrim` (or subclass) object\n\n**Args:**\n\n * `name` (str): object name\n * `deformable` (DeformablePrim): object\n",
"snippet":"scene_registry.add_deformable(name=name, deformable=deformable)\n",
"category":"method"
},
{
"title":"add_deformable_material",
"description":"Register a `DeformableMaterial` (or subclass) object\n\n**Args:**\n\n * `name` (str): object name\n * `deformable_material` (DeformableMaterial): object\n",
"snippet":"scene_registry.add_deformable_material(name=name, deformable_material=deformable_material)\n",
"category":"method"
},
{
"title":"add_deformable_material_view",
"description":"Register a `DeformableMaterialView` (or subclass) object\n\n**Args:**\n\n * `name` (str): object name\n * `deformable_material_view` (DeformableMaterialView): object\n",
"snippet":"scene_registry.add_deformable_material_view(name=name, deformable_material_view=deformable_material_view)\n",
"category":"method"
},
{
"title":"add_deformable_view",
"description":"Register a `DeformablePrimView` (or subclass) object\n\n**Args:**\n\n * `name` (str): object name\n * `deformable_prim_view` (DeformablePrimView): object\n",
"snippet":"scene_registry.add_deformable_view(name=name, deformable_prim_view=deformable_prim_view)\n",
"category":"method"
},
{
"title":"add_geometry_object",
"description":"Register a `GeometryPrim` (or subclass) object\n\n**Args:**\n\n * `name` (str): object name\n * `geometry_object` (GeometryPrim): object\n",
"snippet":"scene_registry.add_geometry_object(name=name, geometry_object=geometry_object)\n",
"category":"method"
},
{
"title":"add_geometry_prim_view",
"description":"Register a `GeometryPrimView` (or subclass) object\n\n**Args:**\n\n * `name` (str): object name\n * `geometry_prim_view` (GeometryPrim): object\n",
"snippet":"scene_registry.add_geometry_prim_view(name=name, geometry_prim_view=geometry_prim_view)\n",
"category":"method"
},
{
"title":"add_particle_material",
"description":"Register a `ParticleMaterial` (or subclass) object\n\n**Args:**\n\n * `name` (str): object name\n * `particle_material` (ParticleMaterial): object\n",
"snippet":"scene_registry.add_particle_material(name=name, particle_material=particle_material)\n",
"category":"method"
},
{
"title":"add_particle_material_view",
"description":"Register a `ParticleMaterialView` (or subclass) object\n\n**Args:**\n\n * `name` (str): object name\n * `particle_material_view` (ParticleMaterialView): object\n",
"snippet":"scene_registry.add_particle_material_view(name=name, particle_material_view=particle_material_view)\n",
"category":"method"
},
{
"title":"add_particle_system",
"description":"Register a `ParticleSystem` (or subclass) object\n\n**Args:**\n\n * `name` (str): object name\n * `particle_system` (ParticleSystemView): object\n",
"snippet":"scene_registry.add_particle_system(name=name, particle_system=particle_system)\n",
"category":"method"
},
{
"title":"add_particle_system_view",
"description":"Register a `ParticleSystemView` (or subclass) object\n\n**Args:**\n\n * `name` (str): object name\n * `particle_system_view` (ParticleSystemView): object\n",
"snippet":"scene_registry.add_particle_system_view(name=name, particle_system_view=particle_system_view)\n",
"category":"method"
},
{
"title":"add_rigid_contact_view",
"description":"Register a `RigidContactView` (or subclass) object\n\n**Args:**\n\n * `name` (str): object name\n * `rigid_contact_view` (RigidContactView): object\n",
"snippet":"scene_registry.add_rigid_contact_view(name=name, rigid_contact_view=rigid_contact_view)\n",
"category":"method"
},
{
"title":"add_rigid_object",
"description":"Register a `RigidPrim` (or subclass) object\n\n**Args:**\n\n * `name` (str): object name\n * `rigid_object` (RigidPrim): object\n",
"snippet":"scene_registry.add_rigid_object(name=name, rigid_object=rigid_object)\n",
"category":"method"
},
{
"title":"add_rigid_prim_view",
"description":"Register a `RigidPrimView` (or subclass) object\n\n**Args:**\n\n * `name` (str): object name\n * `rigid_prim_view` (RigidPrimView): object\n",
"snippet":"scene_registry.add_rigid_prim_view(name=name, rigid_prim_view=rigid_prim_view)\n",
"category":"method"
},
{
"title":"add_robot",
"description":"Register a `Robot` (or subclass) object\n\n**Args:**\n\n * `name` (str): object name\n * `robot` (Robot): object\n",
"snippet":"scene_registry.add_robot(name=name, robot=robot)\n",
"category":"method"
},
{
"title":"add_robot_view",
"description":"Register a `RobotView` (or subclass) object\n\n**Args:**\n\n * `name` (str): object name\n * `robot_view` (RobotView): object\n",
"snippet":"scene_registry.add_robot_view(name=name, robot_view=robot_view)\n",
"category":"method"
},
{
"title":"add_sensor",
"description":"Register a `BaseSensor` (or subclass) object\n\n**Args:**\n\n * `name` (str): object name\n * `sensor` (BaseSensor): object\n",
"snippet":"scene_registry.add_sensor(name=name, sensor=sensor)\n",
"category":"method"
},
{
"title":"add_xform",
"description":"Register a `XFormPrim` (or subclass) object\n\n**Args:**\n\n * `name` (str): object name\n * `robot` (Robot): object\n",
"snippet":"scene_registry.add_xform(name=name, xform=xform)\n",
"category":"method"
},
{
"title":"add_xform_view",
"description":"Register a `XFormPrimView` (or subclass) object\n\n**Args:**\n\n * `name` (str): object name\n * `xform_prim_view` (XFormPrimView): object\n",
"snippet":"scene_registry.add_xform_view(name=name, xform_prim_view=xform_prim_view)\n",
"category":"method"
},
{
"title":"articulated_systems",
"description":"Registered `Articulation` objects\n",
"snippet":"articulated_systems = scene_registry.articulated_systems\n",
"category":"property"
},
{
"title":"articulated_views",
"description":"Registered `ArticulationView` objects\n",
"snippet":"articulated_views = scene_registry.articulated_views\n",
"category":"property"
},
{
"title":"cloth_prim_views",
"description":"Registered `ClothPrimView` objects\n",
"snippet":"cloth_prim_views = scene_registry.cloth_prim_views\n",
"category":"property"
},
{
"title":"cloth_prims",
"description":"Registered `ClothPrim` objects\n",
"snippet":"cloth_prims = scene_registry.cloth_prims\n",
"category":"property"
},
{
"title":"deformable_material_views",
"description":"Registered `DeformableMaterialView` objects\n",
"snippet":"deformable_material_views = scene_registry.deformable_material_views\n",
"category":"property"
},
{
"title":"deformable_materials",
"description":"Registered `DeformableMaterial` objects\n",
"snippet":"deformable_materials = scene_registry.deformable_materials\n",
"category":"property"
},
{
"title":"deformable_prim_views",
"description":"Registered `DeformablePrimView` objects\n",
"snippet":"deformable_prim_views = scene_registry.deformable_prim_views\n",
"category":"property"
},
{
"title":"deformable_prims",
"description":"Registered `DeformablePrim` objects\n",
"snippet":"deformable_prims = scene_registry.deformable_prims\n",
"category":"property"
},
{
"title":"geometry_prim_views",
"description":"Registered `GeometryPrimView` objects\n",
"snippet":"geometry_prim_views = scene_registry.geometry_prim_views\n",
"category":"property"
},
{
"title":"get_object",
"description":"Get a registered object by its name if exists otherwise None\n\n**Args:**\n\n * `name` (str): object name\n\n**Returns:**\n\n * XFormPrim: the object if it exists otherwise None\n\n---\n**Example:**\n\n```python\n>>> # given a registered ground plane named 'default_ground_plane'\n>>> scene_registry.get_object(\"default_ground_plane\")\n<omni.isaac.core.objects.ground_plane.GroundPlane object at 0x...>\n```\n",
"snippet":"object = scene_registry.get_object(name=name)\n",
"category":"method"
},
{
"title":"name_exists",
"description":"Check if an object exists in the registry by its name\n\n**Args:**\n\n * `name` (str): object name\n\n**Returns:**\n\n * bool: whether the object is registered or not\n\n---\n**Example:**\n\n```python\n>>> # given a registered ground plane named 'default_ground_plane'\n>>> scene_registry.name_exists(\"default_ground_plane\")\nTrue\n```\n",
"snippet":"value = scene_registry.name_exists(name=name)\n",
"category":"method"
},
{
"title":"particle_material_views",
"description":"Registered `particle_material_view` objects\n",
"snippet":"particle_material_views = scene_registry.particle_material_views\n",
"category":"property"
},
{
"title":"particle_materials",
"description":"Registered `ParticleMaterial` objects\n",
"snippet":"particle_materials = scene_registry.particle_materials\n",
"category":"property"
},
{
"title":"particle_system_views",
"description":"Registered `ParticleSystemView` objects\n",
"snippet":"particle_system_views = scene_registry.particle_system_views\n",
"category":"property"
},
{
"title":"particle_systems",
"description":"Registered `ParticleSystem` objects\n",
"snippet":"particle_systems = scene_registry.particle_systems\n",
"category":"property"
},
{
"title":"remove_object",
"description":"Remove and object from the registry\n\n*Note:*\nThis method will only remove the object from the internal registry.\nThe wrapped object will not be removed from the USD stage\n\n**Args:**\n\n * `name` (str): object name\n\n**Raises:**\n\n * Exception: If the name doesn't exist in the registry\n\n---\n**Example:**\n\n```python\n>>> # given a registered ground plane named 'default_ground_plane'\n>>> scene_registry.remove_object(\"default_ground_plane\")\n```\n",
"snippet":"scene_registry.remove_object(name=name)\n",
"category":"method"
},
{
"title":"rigid_contact_views",
"description":"Registered `RigidContactView` objects\n",
"snippet":"rigid_contact_views = scene_registry.rigid_contact_views\n",
"category":"property"
},
{
"title":"rigid_objects",
"description":"Registered `RigidPrim` objects\n",
"snippet":"rigid_objects = scene_registry.rigid_objects\n",
"category":"property"
},
{
"title":"rigid_prim_views",
"description":"Registered `RigidPrimView` objects\n",
"snippet":"rigid_prim_views = scene_registry.rigid_prim_views\n",
"category":"property"
},
{
"title":"robot_views",
"description":"Registered `RobotView` objects\n",
"snippet":"robot_views = scene_registry.robot_views\n",
"category":"property"
},
{
"title":"robots",
"description":"Registered `Robot` objects\n",
"snippet":"robots = scene_registry.robots\n",
"category":"property"
},
{
"title":"sensors",
"description":"Registered `BaseSensor` (and derived) objects\n",
"snippet":"sensors = scene_registry.sensors\n",
"category":"property"
},
{
"title":"xform_prim_views",
"description":"Registered `XFormPrimView` objects\n",
"snippet":"xform_prim_views = scene_registry.xform_prim_views\n",
"category":"property"
},
{
"title":"xforms",
"description":"Registered `XFormPrim` objects\n",
"snippet":"xforms = scene_registry.xforms\n",
"category":"property"
}
]
}
]
},
{
"title":"SimulationContext",
"snippets":[
{
"title":"import ...",
"description":"Import class",
"snippet":"from omni.isaac.core.simulation_context import SimulationContext\n",
"category":"import"
},
{
"title":"SimulationContext",
"description":"This class provide functions that take care of many time-related events such as\nperform a physics or a render step for instance. Adding/ removing callback functions that\ngets triggered with certain events such as a physics step, timeline event\n(pause or play..etc), stage open/ close..etc.\n\nIt also includes an instance of PhysicsContext which takes care of many physics related\nsettings such as setting physics dt, solver type..etc.\n\n**Args:**\n\n * `physics_dt` (Optional\\[float\\], optional): dt between physics steps. Defaults to None.\n * `rendering_dt` (Optional\\[float\\], optional): dt between rendering steps. Note: rendering means rendering a frame of the current application and not only rendering a frame to the viewports/cameras. So UI elements of Isaac Sim will be refreshed with this dt as well if running non-headless. Defaults to None.\n * `stage_units_in_meters` (Optional\\[float\\], optional): The metric units of assets. This will affect gravity value..etc. Defaults to None.\n * `physics_prim_path` (Optional\\[str\\], optional): specifies the prim path to create a PhysicsScene at, only in the case where no PhysicsScene already defined. Defaults to \"/physicsScene\".\n * `set_defaults` (bool, optional): set to True to use the defaults settings \\[physics\\_dt = 1.0/ 60.0, stage units in meters = 0.01 (i.e in cms), rendering\\_dt = 1.0 / 60.0, gravity = -9.81 m / s ccd\\_enabled, stabilization\\_enabled, gpu dynamics turned off, broadcast type is MBP, solver type is TGS\\]. Defaults to True.\n * `backend` (str, optional): specifies the backend to be used (numpy or torch or warp). Defaults to numpy.\n * `device` (Optional\\[str\\], optional): specifies the device to be used if running on the gpu with torch or warp backend.\n\n---\n**Example:**\n\n```python\n>>> from omni.isaac.core import SimulationContext\n>>>\n>>> simulation_context = SimulationContext()\n>>> simulation_context\n<omni.isaac.core.simulation_context.simulation_context.SimulationContext object at 0x...>\n```\n",
"snippet":"simulation_context = SimulationContext()\n",
"category":"class"
},
{
"title":"add_physics_callback",
"description":"Add a callback which will be called before each physics step.\n\n`callback_fn` should take a float argument (e.g., `step_size`)\n\n**Args:**\n\n * `callback_name` (str): should be unique.\n * `callback_fn` (Callable\\[\\[float\\], None\\]): \\[description\\]\n\n---\n**Example:**\n\n```python\n>>> def callback_physics(step_size):\n...     print(\"physics callback -> step_size:\", step_size)\n...\n>>> simulation_context.add_physics_callback(\"callback_physics\", callback_physics)\n```\n",
"snippet":"simulation_context.add_physics_callback(callback_name=callback_name, callback_fn=callback_fn)\n",
"category":"method"
},
{
"title":"add_render_callback",
"description":"Add a callback which will be called after each rendering event such as .render().\n\n`callback_fn` should take an argument of type (e.g., `event`)\n\n**Args:**\n\n * `callback_name` (str): \\[description\\]\n * `callback_fn` (Callable): \\[description\\]\n\n---\n**Example:**\n\n```python\n>>> def callback_render(event):\n...     print(\"render callback -> event:\", event)\n...\n>>> simulation_context.add_render_callback(\"callback_render\", callback_render)\n```\n",
"snippet":"simulation_context.add_render_callback(callback_name=callback_name, callback_fn=callback_fn)\n",
"category":"method"
},
{
"title":"add_stage_callback",
"description":"Add a callback which will be called after each stage event such as open/close among others\n\n`callback_fn` should take an argument of type `omni.usd.StageEvent` (e.g., `event`)\n\n**Args:**\n\n * `callback_name` (str): \\[description\\]\n * `callback_fn` (Callable\\[\\[omni.usd.StageEvent\\], None\\]): \\[description\\]\n\n---\n**Example:**\n\n```python\n>>> def callback_stage(event):\n...     print(\"stage callback -> event:\", event)\n...\n>>> simulation_context.add_stage_callback(\"callback_stage\", callback_stage)\n```\n",
"snippet":"simulation_context.add_stage_callback(callback_name=callback_name, callback_fn=callback_fn)\n",
"category":"method"
},
{
"title":"add_timeline_callback",
"description":"Add a callback which will be called after each timeline event such as play/pause.\n\n`callback_fn` should take an argument of type `omni.timeline.TimelineEvent` (e.g., `event`)\n\n**Args:**\n\n * `callback_name` (str): \\[description\\]\n * `callback_fn` (Callable\\[\\[omni.timeline.TimelineEvent\\], None\\]): \\[description\\]\n\n---\n**Example:**\n\n```python\n>>> def callback_timeline(event):\n...     print(\"timeline callback -> event:\", event)\n...\n>>> simulation_context.add_timeline_callback(\"callback_timeline\", callback_timeline)\n```\n",
"snippet":"simulation_context.add_timeline_callback(callback_name=callback_name, callback_fn=callback_fn)\n",
"category":"method"
},
{
"title":"app",
"description":"Returns:\nomni.kit.app.IApp: Omniverse Kit Application interface\nExample:\n.. code-block:: python\n\n\\>\\>\\> simulation\\_context.app\n\\<omni.kit.app.\\_app.IApp object at 0x...\\>\n",
"snippet":"app = simulation_context.app\n",
"category":"property"
},
{
"title":"backend",
"description":"**Returns:**\n\n * str: current backend. Supported backends are: `\"numpy\"`, `\"torch\"` and `\"warp\"`\n\n---\n**Example:**\n\n```python\n>>> simulation_context.backend\nnumpy\n```\n",
"snippet":"backend = simulation_context.backend\n",
"category":"property"
},
{
"title":"backend_utils",
"description":"Get the current backend utils module\n\n| Backend   | Utils module                  |\n|-----------|-------------------------------|\n| `\"numpy\"` | `omni.isaac.core.utils.numpy` |\n| `\"torch\"` | `omni.isaac.core.utils.torch` |\n| `\"warp\"`  | `omni.isaac.core.utils.warp`  |\n\n**Returns:**\n\n * str: current backend utils module\n\n---\n**Example:**\n\n```python\n>>> simulation_context.backend_utils\n<module 'omni.isaac.core.utils.numpy'>\n```\n",
"snippet":"backend_utils = simulation_context.backend_utils\n",
"category":"property"
},
{
"title":"clear",
"description":"Clear the current stage leaving the PhysicsScene and /World\n\n---\n**Example:**\n\n```python\n>>> simulation_context.clear()\n```\n",
"snippet":"simulation_context.clear()\n",
"category":"method"
},
{
"title":"clear_all_callbacks",
"description":"Clear all callbacks which were added using any `add_*_callback` method\n\n---\n**Example:**\n\n```python\n>>> simulation_context.clear_render_callbacks()\n```\n",
"snippet":"simulation_context.clear_all_callbacks()\n",
"category":"method"
},
{
"title":"clear_physics_callbacks",
"description":"Remove all registered physics callbacks\n\n---\n**Example:**\n\n```python\n>>> simulation_context.clear_physics_callbacks()\n```\n",
"snippet":"simulation_context.clear_physics_callbacks()\n",
"category":"method"
},
{
"title":"clear_render_callbacks",
"description":"Remove all registered render callbacks\n\n---\n**Example:**\n\n```python\n>>> simulation_context.clear_render_callbacks()\n```\n",
"snippet":"simulation_context.clear_render_callbacks()\n",
"category":"method"
},
{
"title":"clear_stage_callbacks",
"description":"Remove all registered stage callbacks\n\n---\n**Example:**\n\n```python\n>>> simulation_context.clear_stage_callbacks()\n```\n",
"snippet":"simulation_context.clear_stage_callbacks()\n",
"category":"method"
},
{
"title":"clear_timeline_callbacks",
"description":"Remove all registered timeline callbacks\n\n---\n**Example:**\n\n```python\n>>> simulation_context.clear_timeline_callbacks()\n```\n",
"snippet":"simulation_context.clear_timeline_callbacks()\n",
"category":"method"
},
{
"title":"current_time",
"description":"**Returns:**\n\n * float: current time (simulated physical time) that have elapsed since the simulation was played\n\n---\n**Example:**\n\n```python\n>>> # given a running Isaac Sim instance and after 911 physics steps at 60 Hz\n>>> simulation_context.current_time\n15.183334125205874\n```\n",
"snippet":"current_time = simulation_context.current_time\n",
"category":"property"
},
{
"title":"current_time_step_index",
"description":"**Returns:**\n\n * int: current number of physics steps that have elapsed since the simulation was played\n\n---\n**Example:**\n\n```python\n>>> # given a running Isaac Sim instance and after approximately 15 seconds of physics simulation at 60 Hz\n>>> simulation_context.current_time_step_index\n911\n```\n",
"snippet":"current_time_step_index = simulation_context.current_time_step_index\n",
"category":"property"
},
{
"title":"device",
"description":"**Returns:**\n\n * str: Device used by the physics context. None for numpy backend\n\n---\n**Example:**\n\n```python\n>>> simulation_context.device\nNone\n```\n",
"snippet":"device = simulation_context.device\n",
"category":"property"
},
{
"title":"get_block_on_render",
"description":"Get the block on render flag for the simulation thread\n\n**Returns:**\n\n * bool: True if one frame lag between any data captured from the render products and the current USD stage is guaranteed by blocking the step call.\n\n---\n**Example:**\n\n```python\n>>> simulation_context.get_block_on_render()\nFalse\n```\n",
"snippet":"block_on_render = simulation_context.get_block_on_render()\n",
"category":"method"
},
{
"title":"get_physics_context",
"description":"Get the physics context (a class to deal with a physics scene and its settings) instance\n\n**Raises:**\n\n * Exception: if there is no stage currently opened\n\n**Returns:**\n\n * PhysicsContext: physics context object\n\n---\n**Example:**\n\n```python\n>>> simulation_context.get_physics_context()\n<omni.isaac.core.physics_context.physics_context.PhysicsContext object at 0x...>\n```\n",
"snippet":"physics_context = simulation_context.get_physics_context()\n",
"category":"method"
},
{
"title":"get_physics_dt",
"description":"Get the current physics dt of the physics context\n\n**Raises:**\n\n * Exception: if there is no stage currently opened\n\n**Returns:**\n\n * float: current physics dt of the PhysicsContext\n\n---\n**Example:**\n\n```python\n>>> simulation_context.get_physics_dt()\n0.016666666666666666\n```\n",
"snippet":"physics_dt = simulation_context.get_physics_dt()\n",
"category":"method"
},
{
"title":"get_rendering_dt",
"description":"Get the current rendering dt\n\n**Raises:**\n\n * Exception: if there is no stage currently opened\n\n**Returns:**\n\n * float: current rendering dt\n\n---\n**Example:**\n\n```python\n>>> simulation_context.get_rendering_dt()\n0.016666666666666666\n```\n",
"snippet":"rendering_dt = simulation_context.get_rendering_dt()\n",
"category":"method"
},
{
"title":"initialize_physics",
"description":"Initialize the physics simulation view\n\n---\n**Example:**\n\n```python\n>>> simulation_context.initialize_physics()\n```\n",
"snippet":"simulation_context.initialize_physics()\n",
"category":"method"
},
{
"title":"initialize_simulation_context_async",
"description":"Initialize the simulation context\n\n*Hint:*\nThis method is intended to be used in the Isaac Sim's Extensions workflow where\nthe Kit application has the control over timing of physics and rendering steps\n\n---\n**Example:**\n\n```python\n>>> from omni.kit.async_engine import run_coroutine\n>>>\n>>> async def task():\n...     await simulation_context.initialize_simulation_context_async()\n...\n>>> run_coroutine(task())\n```\n",
"snippet":"simulation_context.initialize_simulation_context_async()\n",
"category":"method"
},
{
"title":"is_playing",
"description":"Check whether the simulation is playing\n\n**Returns:**\n\n * bool: True if the simulator is playing.\n\n---\n**Example:**\n\n```python\n>>> # given a simulation in play\n>>> simulation_context.is_playing()\nTrue\n```\n",
"snippet":"value = simulation_context.is_playing()\n",
"category":"method"
},
{
"title":"is_simulating",
"description":"Check whether the simulation is running or not\n\n*Warning:*\nWith deprecation of Dynamic Control Toolbox, this function is not needed\n\n> It can return True if start\\_simulation is called even if play was pressed/called.\n\n**Returns:**\n\n * bool\" True if physics simulation is happening.\n\n---\n**Example:**\n\n```python\n>>> # given a running simulation\n>>> simulation_context.is_simulating()\nTrue\n```\n",
"snippet":"value = simulation_context.is_simulating()\n",
"category":"method"
},
{
"title":"is_stopped",
"description":"Check whether the simulation is playing\n\n**Returns:**\n\n * bool: True if the simulator is stopped.\n\n---\n**Example:**\n\n```python\n>>> # given a simulation in play\n>>> simulation_context.is_stopped()\nFalse\n```\n",
"snippet":"value = simulation_context.is_stopped()\n",
"category":"method"
},
{
"title":"pause",
"description":"Pause the physics simulation\n\n---\n**Example:**\n\n```python\n>>> simulation_context.pause()\n```\n",
"snippet":"simulation_context.pause()\n",
"category":"method"
},
{
"title":"pause_async",
"description":"Pause the physics simulation\n\n---\n**Example:**\n\n```python\n>>> from omni.kit.async_engine import run_coroutine\n>>>\n>>> async def task():\n...     await simulation_context.pause_async()\n...\n>>> run_coroutine(task())\n```\n",
"snippet":"simulation_context.pause_async()\n",
"category":"method"
},
{
"title":"physics_callback_exists",
"description":"Check if a physics callback exists\n\n**Args:**\n\n * `callback_name` (str): callback name\n\n**Returns:**\n\n * bool: whether the callback is registered\n\n---\n**Example:**\n\n```python\n>>> # given a registered callback named 'callback_physics'\n>>> simulation_context.physics_callback_exists(\"callback_physics\")\nTrue\n```\n",
"snippet":"value = simulation_context.physics_callback_exists(callback_name=callback_name)\n",
"category":"method"
},
{
"title":"physics_sim_view",
"description":"*Note:*\nThe physics simulation view instance will be only available after initializing the physics\n(see `initialize_physics`) or resetting the simulation context (see `reset`)\n\n**Returns:**\n\n * PhysicsContext: Physics simulation view instance\n\n---\n**Example:**\n\n```python\n>>> simulation_context.physics_sim_view\n<omni.physics.tensors.impl.api.SimulationView object at 0x...>\n```\n",
"snippet":"physics_sim_view = simulation_context.physics_sim_view\n",
"category":"property"
},
{
"title":"play",
"description":"Start playing simulation\n\n*Note:*\nIt does one step internally to propagate all physics handles properly.\n\n---\n**Example:**\n\n```python\n>>> simulation_context.play()\n```\n",
"snippet":"simulation_context.play()\n",
"category":"method"
},
{
"title":"play_async",
"description":"Start playing simulation\n\n---\n**Example:**\n\n```python\n>>> from omni.kit.async_engine import run_coroutine\n>>>\n>>> async def task():\n...     await simulation_context.play_async()\n...\n>>> run_coroutine(task())\n```\n",
"snippet":"simulation_context.play_async()\n",
"category":"method"
},
{
"title":"remove_physics_callback",
"description":"Remove a physics callback by its name\n\n**Args:**\n\n * `callback_name` (str): callback name\n\n---\n**Example:**\n\n```python\n>>> # given a registered callback named 'callback_physics'\n>>> simulation_context.remove_physics_callback(\"callback_physics\")\n```\n",
"snippet":"simulation_context.remove_physics_callback(callback_name=callback_name)\n",
"category":"method"
},
{
"title":"remove_render_callback",
"description":"Remove a render callback by its name\n\n**Args:**\n\n * `callback_name` (str): callback name\n\n---\n**Example:**\n\n```python\n>>> # given a registered callback named 'callback_render'\n>>> simulation_context.remove_render_callback(\"callback_render\")\n```\n",
"snippet":"simulation_context.remove_render_callback(callback_name=callback_name)\n",
"category":"method"
},
{
"title":"remove_stage_callback",
"description":"Remove a stage callback by its name\n\n**Args:**\n\n * `callback_name` (str): callback name\n\n---\n**Example:**\n\n```python\n>>> # given a registered callback named 'callback_stage'\n>>> simulation_context.remove_stage_callback(\"callback_stage\")\n```\n",
"snippet":"simulation_context.remove_stage_callback(callback_name=callback_name)\n",
"category":"method"
},
{
"title":"remove_timeline_callback",
"description":"Remove a timeline callback by its name\n\n**Args:**\n\n * `callback_name` (str): callback name\n\n---\n**Example:**\n\n```python\n>>> # given a registered callback named 'timeline'\n>>> simulation_context.timeline_callback(\"timeline\")\n```\n",
"snippet":"simulation_context.remove_timeline_callback(callback_name=callback_name)\n",
"category":"method"
},
{
"title":"render",
"description":"Refresh the Isaac Sim app rendering components including UI elements, viewports and others\n\n*Warning:*\nThis method is not intended to be used in the Isaac Sim's Extensions workflow\nsince the Kit application has the control over the rendering steps\n\n---\n**Example:**\n\n```python\n>>> simulation_context.render()\n```\n",
"snippet":"simulation_context.render()\n",
"category":"method"
},
{
"title":"render_async",
"description":"Refresh the Isaac Sim app rendering components including UI elements, viewports and others\n\n*Hint:*\nThis method is intended to be used in the Isaac Sim's Extensions workflow where\nthe Kit application has the control over timing of physics and rendering steps\n\n---\n**Example:**\n\n```python\n>>> from omni.kit.async_engine import run_coroutine\n>>>\n>>> async def task():\n...     await simulation_context.render_async()\n...\n>>> run_coroutine(task())\n```\n",
"snippet":"simulation_context.render_async()\n",
"category":"method"
},
{
"title":"render_callback_exists",
"description":"Check if a render callback exists\n\n**Args:**\n\n * `callback_name` (str): callback name\n\n**Returns:**\n\n * bool: whether the callback is registered\n\n---\n**Example:**\n\n```python\n>>> # given a registered callback named 'callback_render'\n>>> simulation_context.render_callback_exists(\"callback_render\")\nTrue\n```\n",
"snippet":"value = simulation_context.render_callback_exists(callback_name=callback_name)\n",
"category":"method"
},
{
"title":"reset",
"description":"Reset the physics simulation view.\n\n*Warning:*\nThis method is not intended to be used in the Isaac Sim's Extensions workflow since the Kit application\nhas the control over the rendering steps. For the Extensions workflow use the `reset_async` method instead\n\n**Args:**\n\n * `soft` (bool, optional): if set to True simulation won't be stopped and start again. It only calls the reset on the scene objects.\n\n---\n**Example:**\n\n```python\n>>> simulation_context.reset()\n```\n",
"snippet":"simulation_context.reset()\n",
"category":"method"
},
{
"title":"reset_async",
"description":"Reset the physics simulation view (asynchronous version).\n\n**Args:**\n\n * `soft` (bool, optional): if set to True simulation won't be stopped and start again. It only calls the reset on the scene objects.\n\n---\n**Example:**\n\n```python\n>>> from omni.kit.async_engine import run_coroutine\n>>>\n>>> async def task():\n>>>     await simulation_context.reset_async()\n>>>\n>>> run_coroutine(task())\n```\n",
"snippet":"simulation_context.reset_async()\n",
"category":"method"
},
{
"title":"set_block_on_render",
"description":"Set block on render flag for the simulation thread\n\n*Note:*\nThis guarantee a one frame lag between any data captured from the render products and the current USD stage if enabled.\n\n**Args:**\n\n * `block` (bool): True to block the thread until the renderer is done.\n\n---\n**Example:**\n\n```python\n>>> simulation_context.set_block_on_render(False)\n```\n",
"snippet":"simulation_context.set_block_on_render(block=block)\n",
"category":"method"
},
{
"title":"set_simulation_dt",
"description":"Specify the physics step and rendering step size to use when stepping and rendering.\n\n**Args:**\n\n * `physics_dt` (float): The physics time-step. None means it won't change the current setting. (default: None).\n * `rendering_dt` (float): The rendering time-step. None means it won't change the current setting. (default: None)\n\n*Hint:*\nIt is recommended that the two values be divisible, with the `rendering_dt` being equal to or greater\nthan the `physics_dt`\n\n---\n**Example:**\n\n```python\n>>> set physics dt to 120 Hz and rendering dt to 60Hz (2 physics steps for each rendering)\n>>> simulation_context.set_simulation_dt(physics_dt=1.0 / 120.0, rendering_dt=1.0 / 60.0)\n```\n",
"snippet":"simulation_context.set_simulation_dt()\n",
"category":"method"
},
{
"title":"stage",
"description":"**Returns:**\n\n * Usd.Stage: current open USD stage\n\n---\n**Example:**\n\n```python\n>>> simulation_context.stage\nUsd.Stage.Open(rootLayer=Sdf.Find('anon:0x...:World....usd'), sessionLayer=Sdf.Find('anon:0x...:World...-session.usda'), pathResolverContext=<invalid repr>)\n```\n",
"snippet":"stage = simulation_context.stage\n",
"category":"property"
},
{
"title":"stage_callback_exists",
"description":"Check if a stage callback exists\n\n**Args:**\n\n * `callback_name` (str): callback name\n\n**Returns:**\n\n * bool: whether the callback is registered\n\n---\n**Example:**\n\n```python\n>>> # given a registered callback named 'callback_stage'\n>>> simulation_context.stage_callback_exists(\"callback_stage\")\nTrue\n```\n",
"snippet":"value = simulation_context.stage_callback_exists(callback_name=callback_name)\n",
"category":"method"
},
{
"title":"step",
"description":"Steps the physics simulation while rendering or without.\n\n*Warning:*\nCalling this method with the `render` parameter set to True (default value) is not intended to be used\nin the Isaac Sim's Extensions workflow since the Kit application has the control over the rendering steps\n\n**Args:**\n\n * `render` (bool, optional): Set to False to only do a physics simulation without rendering. Note: app UI will be frozen (since its not rendering) in this case. Defaults to True.\n\n**Raises:**\n\n * Exception: if there is no stage currently opened\n\n---\n**Example:**\n\n```python\n>>> simulation_context.step()\n```\n",
"snippet":"simulation_context.step()\n",
"category":"method"
},
{
"title":"stop",
"description":"Stop the physics simulation\n\n---\n**Example:**\n\n```python\n>>> simulation_context.stop()\n```\n",
"snippet":"simulation_context.stop()\n",
"category":"method"
},
{
"title":"stop_async",
"description":"Stop the physics simulation\n\n---\n**Example:**\n\n```python\n>>> from omni.kit.async_engine import run_coroutine\n>>>\n>>> async def task():\n...     await simulation_context.stop_async()\n...\n>>> run_coroutine(task())\n```\n",
"snippet":"simulation_context.stop_async()\n",
"category":"method"
},
{
"title":"timeline_callback_exists",
"description":"Check if a timeline callback exists\n\n**Args:**\n\n * `callback_name` (str): callback name\n\n**Returns:**\n\n * bool: whether the callback is registered\n\n---\n**Example:**\n\n```python\n>>> # given a registered callback named 'callback_timeline'\n>>> simulation_context.timeline_callback_exists(\"callback_timeline\")\nTrue\n```\n",
"snippet":"value = simulation_context.timeline_callback_exists(callback_name=callback_name)\n",
"category":"method"
}
]
},
{
"title":"World",
"snippets":[
{
"title":"import ...",
"description":"Import class",
"snippet":"from omni.isaac.core.world import World\n",
"category":"import"
},
{
"title":"World",
"description":"This class inherits from SimulationContext which provides the following.\n\nSimulationContext provide functions that take care of many time-related events such as\nperform a physics or a render step for instance. Adding/ removing callback functions that\ngets triggered with certain events such as a physics step, timeline event\n(pause or play..etc), stage open/ close..etc.\n\nIt also includes an instance of PhysicsContext which takes care of many physics related\nsettings such as setting physics dt, solver type..etc.\n\nIn addition to what is provided from SimulationContext, this class allows the user to add a\ntask to the world and it contains a scene object.\n\nTo control the default reset state of different objects easily, the object could be added to\na Scene. Besides this, the object is bound to a short keyword that facilitates objects retrievals,\nlike in a dict.\n\nCheckout the required tutorials at\n<https://docs.omniverse.nvidia.com/app_isaacsim/app_isaacsim/overview.html>\n\n**Args:**\n\n * `physics_dt` (Optional\\[float\\], optional): dt between physics steps. Defaults to None.\n * `rendering_dt` (Optional\\[float\\], optional): dt between rendering steps. Note: rendering means rendering a frame of the current application and not only rendering a frame to the viewports/ cameras. So UI elements of Isaac Sim will be refreshed with this dt as well if running non-headless. Defaults to None.\n * `stage_units_in_meters` (Optional\\[float\\], optional): The metric units of assets. This will affect gravity value..etc. Defaults to None.\n * `physics_prim_path` (Optional\\[str\\], optional): specifies the prim path to create a PhysicsScene at, only in the case where no PhysicsScene already defined. Defaults to \"/physicsScene\".\n * `set_defaults` (bool, optional): set to True to use the defaults settings \\[physics\\_dt = 1.0/ 60.0, stage units in meters = 0.01 (i.e in cms), rendering\\_dt = 1.0 / 60.0, gravity = -9.81 m / s ccd\\_enabled, stabilization\\_enabled, gpu dynamics turned off, broadcast type is MBP, solver type is TGS\\]. Defaults to True.\n * `backend` (str, optional): specifies the backend to be used (numpy or torch or warp). Defaults to numpy.\n * `device` (Optional\\[str\\], optional): specifies the device to be used if running on the gpu with torch or warp backends.\n\n---\n**Example:**\n\n```python\n>>> from omni.isaac.core import World\n>>>\n>>> world = World()\n>>> world\n<omni.isaac.core.world.world.World object at 0x...>\n```\n",
"snippet":"world = World()\n",
"category":"class"
},
{
"title":"add_physics_callback",
"description":"Add a callback which will be called before each physics step.\n\n`callback_fn` should take a float argument (e.g., `step_size`)\n\n**Args:**\n\n * `callback_name` (str): should be unique.\n * `callback_fn` (Callable\\[\\[float\\], None\\]): \\[description\\]\n\n---\n**Example:**\n\n```python\n>>> def callback_physics(step_size):\n...     print(\"physics callback -> step_size:\", step_size)\n...\n>>> simulation_context.add_physics_callback(\"callback_physics\", callback_physics)\n```\n",
"snippet":"world.add_physics_callback(callback_name=callback_name, callback_fn=callback_fn)\n",
"category":"method"
},
{
"title":"add_render_callback",
"description":"Add a callback which will be called after each rendering event such as .render().\n\n`callback_fn` should take an argument of type (e.g., `event`)\n\n**Args:**\n\n * `callback_name` (str): \\[description\\]\n * `callback_fn` (Callable): \\[description\\]\n\n---\n**Example:**\n\n```python\n>>> def callback_render(event):\n...     print(\"render callback -> event:\", event)\n...\n>>> simulation_context.add_render_callback(\"callback_render\", callback_render)\n```\n",
"snippet":"world.add_render_callback(callback_name=callback_name, callback_fn=callback_fn)\n",
"category":"method"
},
{
"title":"add_stage_callback",
"description":"Add a callback which will be called after each stage event such as open/close among others\n\n`callback_fn` should take an argument of type `omni.usd.StageEvent` (e.g., `event`)\n\n**Args:**\n\n * `callback_name` (str): \\[description\\]\n * `callback_fn` (Callable\\[\\[omni.usd.StageEvent\\], None\\]): \\[description\\]\n\n---\n**Example:**\n\n```python\n>>> def callback_stage(event):\n...     print(\"stage callback -> event:\", event)\n...\n>>> simulation_context.add_stage_callback(\"callback_stage\", callback_stage)\n```\n",
"snippet":"world.add_stage_callback(callback_name=callback_name, callback_fn=callback_fn)\n",
"category":"method"
},
{
"title":"add_task",
"description":"Add a task to the task registry\n\n*Note:*\nTasks should have a unique name\n\n**Args:**\n\n * `task` (BaseTask): task object\n\n---\n**Example:**\n\n```python\n>>> from omni.isaac.core.tasks import BaseTask\n>>>\n>>> class Task(BaseTask):\n...    def get_observations(self):\n...        return {'obs': [0]}\n...\n...    def calculate_metrics(self):\n...        return {\"reward\": 1}\n...\n...    def is_done(self):\n...        return False\n...\n>>> task = Task(name=\"custom_task\")\n>>> world.add_task(task)\n```\n",
"snippet":"world.add_task(task=task)\n",
"category":"method"
},
{
"title":"add_timeline_callback",
"description":"Add a callback which will be called after each timeline event such as play/pause.\n\n`callback_fn` should take an argument of type `omni.timeline.TimelineEvent` (e.g., `event`)\n\n**Args:**\n\n * `callback_name` (str): \\[description\\]\n * `callback_fn` (Callable\\[\\[omni.timeline.TimelineEvent\\], None\\]): \\[description\\]\n\n---\n**Example:**\n\n```python\n>>> def callback_timeline(event):\n...     print(\"timeline callback -> event:\", event)\n...\n>>> simulation_context.add_timeline_callback(\"callback_timeline\", callback_timeline)\n```\n",
"snippet":"world.add_timeline_callback(callback_name=callback_name, callback_fn=callback_fn)\n",
"category":"method"
},
{
"title":"calculate_metrics",
"description":"Get metrics from all the tasks that were added\n\n**Args:**\n\n * `task_name` (Optional\\[str\\], optional): task name to ask for. Defaults to None, which means all the tasks\n\n**Returns:**\n\n * dict: the computed task (or all tasks) metric\n\n---\n**Example:**\n\n```python\n>>> world.calculate_metrics(\"custom_task\")\n{'reward': 1}\n```\n",
"snippet":"world.calculate_metrics()\n",
"category":"method"
},
{
"title":"clear",
"description":"Clear the current stage leaving the PhysicsScene and /World\n\n---\n**Example:**\n\n```python\n>>> world.clear()\n```\n",
"snippet":"world.clear()\n",
"category":"method"
},
{
"title":"clear",
"description":"Clear the current stage leaving the PhysicsScene and /World\n\n---\n**Example:**\n\n```python\n>>> simulation_context.clear()\n```\n",
"snippet":"world.clear()\n",
"category":"method"
},
{
"title":"clear_all_callbacks",
"description":"Clear all callbacks which were added using any `add_*_callback` method\n\n---\n**Example:**\n\n```python\n>>> simulation_context.clear_render_callbacks()\n```\n",
"snippet":"world.clear_all_callbacks()\n",
"category":"method"
},
{
"title":"clear_physics_callbacks",
"description":"Remove all registered physics callbacks\n\n---\n**Example:**\n\n```python\n>>> simulation_context.clear_physics_callbacks()\n```\n",
"snippet":"world.clear_physics_callbacks()\n",
"category":"method"
},
{
"title":"clear_render_callbacks",
"description":"Remove all registered render callbacks\n\n---\n**Example:**\n\n```python\n>>> simulation_context.clear_render_callbacks()\n```\n",
"snippet":"world.clear_render_callbacks()\n",
"category":"method"
},
{
"title":"clear_stage_callbacks",
"description":"Remove all registered stage callbacks\n\n---\n**Example:**\n\n```python\n>>> simulation_context.clear_stage_callbacks()\n```\n",
"snippet":"world.clear_stage_callbacks()\n",
"category":"method"
},
{
"title":"clear_timeline_callbacks",
"description":"Remove all registered timeline callbacks\n\n---\n**Example:**\n\n```python\n>>> simulation_context.clear_timeline_callbacks()\n```\n",
"snippet":"world.clear_timeline_callbacks()\n",
"category":"method"
},
{
"title":"dc_interface",
"description":"**Returns:**\n\n * \\_dynamic\\_control.DynamicControl: DynamicControl instance\n\n---\n**Example:**\n\n```python\n>>> world.dc_interface\n<omni.isaac.dynamic_control._dynamic_control.DynamicControl object at 0x...>\n```\n",
"snippet":"dc_interface = world.dc_interface\n",
"category":"property"
},
{
"title":"get_block_on_render",
"description":"Get the block on render flag for the simulation thread\n\n**Returns:**\n\n * bool: True if one frame lag between any data captured from the render products and the current USD stage is guaranteed by blocking the step call.\n\n---\n**Example:**\n\n```python\n>>> simulation_context.get_block_on_render()\nFalse\n```\n",
"snippet":"block_on_render = world.get_block_on_render()\n",
"category":"method"
},
{
"title":"get_current_tasks",
"description":"Get a dictionary of the registered tasks where keys are task names\n\n**Returns:**\n\n * List\\[BaseTask\\]: registered tasks\n\n---\n**Example:**\n\n```python\n>>> world.get_current_tasks()\n{'custom_task': <custom.task.scripts.extension.Task object at 0x...>}\n```\n",
"snippet":"current_tasks = world.get_current_tasks()\n",
"category":"method"
},
{
"title":"get_data_logger",
"description":"Return the data logger of the world.\n\n**Returns:**\n\n * DataLogger: data logger instance\n\n---\n**Example:**\n\n```python\n>>> world.get_data_logger()\n<omni.isaac.core.loggers.data_logger.DataLogger object at 0x...>\n```\n",
"snippet":"data_logger = world.get_data_logger()\n",
"category":"method"
},
{
"title":"get_observations",
"description":"Get observations from all the tasks that were added\n\n**Args:**\n\n * `task_name` (Optional\\[str\\], optional): task name to ask for. Defaults to None, which means all the tasks\n\n**Returns:**\n\n * dict: the task (or all tasks) observations\n\n---\n**Example:**\n\n```python\n>>> world.get_observations(\"custom_task\")\n{'obs': [0]}\n```\n",
"snippet":"observations = world.get_observations()\n",
"category":"method"
},
{
"title":"get_physics_context",
"description":"Get the physics context (a class to deal with a physics scene and its settings) instance\n\n**Raises:**\n\n * Exception: if there is no stage currently opened\n\n**Returns:**\n\n * PhysicsContext: physics context object\n\n---\n**Example:**\n\n```python\n>>> simulation_context.get_physics_context()\n<omni.isaac.core.physics_context.physics_context.PhysicsContext object at 0x...>\n```\n",
"snippet":"physics_context = world.get_physics_context()\n",
"category":"method"
},
{
"title":"get_physics_dt",
"description":"Get the current physics dt of the physics context\n\n**Raises:**\n\n * Exception: if there is no stage currently opened\n\n**Returns:**\n\n * float: current physics dt of the PhysicsContext\n\n---\n**Example:**\n\n```python\n>>> simulation_context.get_physics_dt()\n0.016666666666666666\n```\n",
"snippet":"physics_dt = world.get_physics_dt()\n",
"category":"method"
},
{
"title":"get_rendering_dt",
"description":"Get the current rendering dt\n\n**Raises:**\n\n * Exception: if there is no stage currently opened\n\n**Returns:**\n\n * float: current rendering dt\n\n---\n**Example:**\n\n```python\n>>> simulation_context.get_rendering_dt()\n0.016666666666666666\n```\n",
"snippet":"rendering_dt = world.get_rendering_dt()\n",
"category":"method"
},
{
"title":"get_task",
"description":"Get a task by its name\n\n---\n**Example:**\n\n```python\n>>> world.get_task(\"custom_task\")\n<custom.task.scripts.extension.Task object at 0x...>\n```\n",
"snippet":"task = world.get_task(name=name)\n",
"category":"method"
},
{
"title":"initialize_physics",
"description":"Initialize the physics simulation view and each added object to the Scene\n\n---\n**Example:**\n\n```python\n>>> world.initialize_physics()\n```\n",
"snippet":"world.initialize_physics()\n",
"category":"method"
},
{
"title":"initialize_physics",
"description":"Initialize the physics simulation view\n\n---\n**Example:**\n\n```python\n>>> simulation_context.initialize_physics()\n```\n",
"snippet":"world.initialize_physics()\n",
"category":"method"
},
{
"title":"initialize_simulation_context_async",
"description":"Initialize the simulation context\n\n*Hint:*\nThis method is intended to be used in the Isaac Sim's Extensions workflow where\nthe Kit application has the control over timing of physics and rendering steps\n\n---\n**Example:**\n\n```python\n>>> from omni.kit.async_engine import run_coroutine\n>>>\n>>> async def task():\n...     await simulation_context.initialize_simulation_context_async()\n...\n>>> run_coroutine(task())\n```\n",
"snippet":"world.initialize_simulation_context_async()\n",
"category":"method"
},
{
"title":"is_done",
"description":"Get done from all the tasks that were added\n\n**Args:**\n\n * `task_name` (Optional\\[str\\], optional): task name to ask for. Defaults to None, which means all the tasks\n\n**Returns:**\n\n * bool: whether the task (or all tasks) is done\n\n---\n**Example:**\n\n```python\n>>> world.is_done(\"custom_task\")\nFalse\n```\n",
"snippet":"value = world.is_done()\n",
"category":"method"
},
{
"title":"is_playing",
"description":"Check whether the simulation is playing\n\n**Returns:**\n\n * bool: True if the simulator is playing.\n\n---\n**Example:**\n\n```python\n>>> # given a simulation in play\n>>> simulation_context.is_playing()\nTrue\n```\n",
"snippet":"value = world.is_playing()\n",
"category":"method"
},
{
"title":"is_simulating",
"description":"Check whether the simulation is running or not\n\n*Warning:*\nWith deprecation of Dynamic Control Toolbox, this function is not needed\n\n> It can return True if start\\_simulation is called even if play was pressed/called.\n\n**Returns:**\n\n * bool\" True if physics simulation is happening.\n\n---\n**Example:**\n\n```python\n>>> # given a running simulation\n>>> simulation_context.is_simulating()\nTrue\n```\n",
"snippet":"value = world.is_simulating()\n",
"category":"method"
},
{
"title":"is_stopped",
"description":"Check whether the simulation is playing\n\n**Returns:**\n\n * bool: True if the simulator is stopped.\n\n---\n**Example:**\n\n```python\n>>> # given a simulation in play\n>>> simulation_context.is_stopped()\nFalse\n```\n",
"snippet":"value = world.is_stopped()\n",
"category":"method"
},
{
"title":"is_tasks_scene_built",
"description":"Check if the `set_up_scene` method was called for each registered task\n\n---\n**Example:**\n\n```python\n>>> # given a world instance that was rested at some point\n>>> world.is_tasks_scene_built()\nTrue\n```\n",
"snippet":"value = world.is_tasks_scene_built()\n",
"category":"method"
},
{
"title":"pause",
"description":"Pause the physics simulation\n\n---\n**Example:**\n\n```python\n>>> simulation_context.pause()\n```\n",
"snippet":"world.pause()\n",
"category":"method"
},
{
"title":"pause_async",
"description":"Pause the physics simulation\n\n---\n**Example:**\n\n```python\n>>> from omni.kit.async_engine import run_coroutine\n>>>\n>>> async def task():\n...     await simulation_context.pause_async()\n...\n>>> run_coroutine(task())\n```\n",
"snippet":"world.pause_async()\n",
"category":"method"
},
{
"title":"physics_callback_exists",
"description":"Check if a physics callback exists\n\n**Args:**\n\n * `callback_name` (str): callback name\n\n**Returns:**\n\n * bool: whether the callback is registered\n\n---\n**Example:**\n\n```python\n>>> # given a registered callback named 'callback_physics'\n>>> simulation_context.physics_callback_exists(\"callback_physics\")\nTrue\n```\n",
"snippet":"value = world.physics_callback_exists(callback_name=callback_name)\n",
"category":"method"
},
{
"title":"play",
"description":"Start playing simulation\n\n*Note:*\nIt does one step internally to propagate all physics handles properly.\n\n---\n**Example:**\n\n```python\n>>> simulation_context.play()\n```\n",
"snippet":"world.play()\n",
"category":"method"
},
{
"title":"play_async",
"description":"Start playing simulation\n\n---\n**Example:**\n\n```python\n>>> from omni.kit.async_engine import run_coroutine\n>>>\n>>> async def task():\n...     await simulation_context.play_async()\n...\n>>> run_coroutine(task())\n```\n",
"snippet":"world.play_async()\n",
"category":"method"
},
{
"title":"remove_physics_callback",
"description":"Remove a physics callback by its name\n\n**Args:**\n\n * `callback_name` (str): callback name\n\n---\n**Example:**\n\n```python\n>>> # given a registered callback named 'callback_physics'\n>>> simulation_context.remove_physics_callback(\"callback_physics\")\n```\n",
"snippet":"world.remove_physics_callback(callback_name=callback_name)\n",
"category":"method"
},
{
"title":"remove_render_callback",
"description":"Remove a render callback by its name\n\n**Args:**\n\n * `callback_name` (str): callback name\n\n---\n**Example:**\n\n```python\n>>> # given a registered callback named 'callback_render'\n>>> simulation_context.remove_render_callback(\"callback_render\")\n```\n",
"snippet":"world.remove_render_callback(callback_name=callback_name)\n",
"category":"method"
},
{
"title":"remove_stage_callback",
"description":"Remove a stage callback by its name\n\n**Args:**\n\n * `callback_name` (str): callback name\n\n---\n**Example:**\n\n```python\n>>> # given a registered callback named 'callback_stage'\n>>> simulation_context.remove_stage_callback(\"callback_stage\")\n```\n",
"snippet":"world.remove_stage_callback(callback_name=callback_name)\n",
"category":"method"
},
{
"title":"remove_timeline_callback",
"description":"Remove a timeline callback by its name\n\n**Args:**\n\n * `callback_name` (str): callback name\n\n---\n**Example:**\n\n```python\n>>> # given a registered callback named 'timeline'\n>>> simulation_context.timeline_callback(\"timeline\")\n```\n",
"snippet":"world.remove_timeline_callback(callback_name=callback_name)\n",
"category":"method"
},
{
"title":"render",
"description":"Refresh the Isaac Sim app rendering components including UI elements, viewports and others\n\n*Warning:*\nThis method is not intended to be used in the Isaac Sim's Extensions workflow\nsince the Kit application has the control over the rendering steps\n\n---\n**Example:**\n\n```python\n>>> simulation_context.render()\n```\n",
"snippet":"world.render()\n",
"category":"method"
},
{
"title":"render_async",
"description":"Refresh the Isaac Sim app rendering components including UI elements, viewports and others\n\n*Hint:*\nThis method is intended to be used in the Isaac Sim's Extensions workflow where\nthe Kit application has the control over timing of physics and rendering steps\n\n---\n**Example:**\n\n```python\n>>> from omni.kit.async_engine import run_coroutine\n>>>\n>>> async def task():\n...     await simulation_context.render_async()\n...\n>>> run_coroutine(task())\n```\n",
"snippet":"world.render_async()\n",
"category":"method"
},
{
"title":"render_callback_exists",
"description":"Check if a render callback exists\n\n**Args:**\n\n * `callback_name` (str): callback name\n\n**Returns:**\n\n * bool: whether the callback is registered\n\n---\n**Example:**\n\n```python\n>>> # given a registered callback named 'callback_render'\n>>> simulation_context.render_callback_exists(\"callback_render\")\nTrue\n```\n",
"snippet":"value = world.render_callback_exists(callback_name=callback_name)\n",
"category":"method"
},
{
"title":"reset",
"description":"Reset the stage to its initial state and each object included in the Scene to its default state\nas specified by the `set_default_state` and `__init__` methods\n*Note:*\n- All tasks should be added before the first reset is called unless the `clear` method was called.\n- All articulations should be added before the first reset is called unless the `clear` method was called.\n- This method takes care of initializing articulation handles with the first reset called.\n- This will do one step internally regardless\n- Call `post_reset` on each object in the Scene\n- Call `post_reset` on each Task\n\nThings like setting PD gains for instance should happen at a Task reset or a Robot reset since\nthe defaults are restored after `stop` method is called.\n*Warning:*\nThis method is not intended to be used in the Isaac Sim's Extensions workflow since the Kit application\nhas the control over the rendering steps. For the Extensions workflow use the `reset_async` method instead\nArgs:\nsoft (bool, optional): if set to True simulation won't be stopped and start again. It only calls the reset on the scene objects.\nExample:\n.. code-block:: python\n\n\\>\\>\\> world.reset()\n",
"snippet":"world.reset()\n",
"category":"method"
},
{
"title":"reset",
"description":"Reset the physics simulation view.\n\n*Warning:*\nThis method is not intended to be used in the Isaac Sim's Extensions workflow since the Kit application\nhas the control over the rendering steps. For the Extensions workflow use the `reset_async` method instead\n\n**Args:**\n\n * `soft` (bool, optional): if set to True simulation won't be stopped and start again. It only calls the reset on the scene objects.\n\n---\n**Example:**\n\n```python\n>>> simulation_context.reset()\n```\n",
"snippet":"world.reset()\n",
"category":"method"
},
{
"title":"reset_async",
"description":"Reset the stage to its initial state and each object included in the Scene to its default state\nas specified by the `set_default_state` and `__init__` methods\n*Note:*\n- All tasks should be added before the first reset is called unless the `clear` method was called.\n- All articulations should be added before the first reset is called unless the `clear` method was called.\n- This method takes care of initializing articulation handles with the first reset called.\n- This will do one step internally regardless\n- Call `post_reset` on each object in the Scene\n- Call `post_reset` on each Task\n\nThings like setting PD gains for instance should happen at a Task reset or a Robot reset since\nthe defaults are restored after `stop` method is called.\nArgs:\nsoft (bool, optional): if set to True simulation won't be stopped and start again. It only calls the reset on the scene objects.\nExample:\n.. code-block:: python\n\n\\>\\>\\> from omni.kit.async\\_engine import run\\_coroutine\n\\>\\>\\>\n\\>\\>\\> async def task():\n... await world.reset\\_async()\n...\n\\>\\>\\> run\\_coroutine(task())\n",
"snippet":"world.reset_async()\n",
"category":"method"
},
{
"title":"reset_async",
"description":"Reset the physics simulation view (asynchronous version).\n\n**Args:**\n\n * `soft` (bool, optional): if set to True simulation won't be stopped and start again. It only calls the reset on the scene objects.\n\n---\n**Example:**\n\n```python\n>>> from omni.kit.async_engine import run_coroutine\n>>>\n>>> async def task():\n>>>     await simulation_context.reset_async()\n>>>\n>>> run_coroutine(task())\n```\n",
"snippet":"world.reset_async()\n",
"category":"method"
},
{
"title":"reset_async_no_set_up_scene",
"description":"Reset the stage to its initial state and each object included in the Scene to its default state\nas specified by the `set_default_state` and `__init__` methods\n*Note:*\n- All tasks should be added before the first reset is called unless the `clear` method was called.\n- All articulations should be added before the first reset is called unless the `clear` method was called.\n- This method takes care of initializing articulation handles with the first reset called.\n- This will do one step internally regardless\n- Call `post_reset` on each object in the Scene\n- Call `post_reset` on each Task\n\nThings like setting PD gains for instance should happen at a Task reset or a Robot reset since\nthe defaults are restored after `stop` method is called.\nArgs:\nsoft (bool, optional): if set to True simulation won't be stopped and start again. It only calls the reset on the scene objects.\nExample:\n.. code-block:: python\n\n\\>\\>\\> from omni.kit.async\\_engine import run\\_coroutine\n\\>\\>\\>\n\\>\\>\\> async def task():\n\\>\\>\\> await world.reset\\_async\\_no\\_set\\_up\\_scene()\n\\>\\>\\>\n\\>\\>\\> run\\_coroutine(task())\n",
"snippet":"world.reset_async_no_set_up_scene()\n",
"category":"method"
},
{
"title":"reset_async_set_up_scene",
"description":"Reset the stage to its initial state and each object included in the Scene to its default state\nas specified by the `set_default_state` and `__init__` methods\n*Note:*\n- All tasks should be added before the first reset is called unless the `clear` method was called.\n- All articulations should be added before the first reset is called unless the `clear` method was called.\n- This method takes care of initializing articulation handles with the first reset called.\n- This will do one step internally regardless\n- Call `post_reset` on each object in the Scene\n- Call `post_reset` on each Task\n\nThings like setting PD gains for instance should happen at a Task reset or a Robot reset since\nthe defaults are restored after `stop` method is called.\nArgs:\nsoft (bool, optional): if set to True simulation won't be stopped and start again. It only calls the reset on the scene objects.\nExample:\n.. code-block:: python\n\n\\>\\>\\> from omni.kit.async\\_engine import run\\_coroutine\n\\>\\>\\>\n\\>\\>\\> async def task():\n\\>\\>\\> await world.reset\\_async\\_set\\_up\\_scene()\n\\>\\>\\>\n\\>\\>\\> run\\_coroutine(task())\n",
"snippet":"world.reset_async_set_up_scene()\n",
"category":"method"
},
{
"title":"scene",
"description":"**Returns:**\n\n * Scene: Scene instance\n\n---\n**Example:**\n\n```python\n>>> world.scene\n<omni.isaac.core.scenes.scene.Scene object at 0x>\n```\n",
"snippet":"scene = world.scene\n",
"category":"property"
},
{
"title":"set_block_on_render",
"description":"Set block on render flag for the simulation thread\n\n*Note:*\nThis guarantee a one frame lag between any data captured from the render products and the current USD stage if enabled.\n\n**Args:**\n\n * `block` (bool): True to block the thread until the renderer is done.\n\n---\n**Example:**\n\n```python\n>>> simulation_context.set_block_on_render(False)\n```\n",
"snippet":"world.set_block_on_render(block=block)\n",
"category":"method"
},
{
"title":"set_simulation_dt",
"description":"Specify the physics step and rendering step size to use when stepping and rendering.\n\n**Args:**\n\n * `physics_dt` (float): The physics time-step. None means it won't change the current setting. (default: None).\n * `rendering_dt` (float): The rendering time-step. None means it won't change the current setting. (default: None)\n\n*Hint:*\nIt is recommended that the two values be divisible, with the `rendering_dt` being equal to or greater\nthan the `physics_dt`\n\n---\n**Example:**\n\n```python\n>>> set physics dt to 120 Hz and rendering dt to 60Hz (2 physics steps for each rendering)\n>>> simulation_context.set_simulation_dt(physics_dt=1.0 / 120.0, rendering_dt=1.0 / 60.0)\n```\n",
"snippet":"world.set_simulation_dt()\n",
"category":"method"
},
{
"title":"stage_callback_exists",
"description":"Check if a stage callback exists\n\n**Args:**\n\n * `callback_name` (str): callback name\n\n**Returns:**\n\n * bool: whether the callback is registered\n\n---\n**Example:**\n\n```python\n>>> # given a registered callback named 'callback_stage'\n>>> simulation_context.stage_callback_exists(\"callback_stage\")\nTrue\n```\n",
"snippet":"value = world.stage_callback_exists(callback_name=callback_name)\n",
"category":"method"
},
{
"title":"step",
"description":"Step the physics simulation while rendering or without.\n\n*Note:*\nThe `pre_step` for each task is called before stepping. This method also update the Bounding Box Cache\ntime for computing bounding box if enabled\n\n*Warning:*\nCalling this method with the `render` parameter set to True (default value) is not intended to be used\nin the Isaac Sim's Extensions workflow since the Kit application has the control over the rendering steps\n\n**Args:**\n\n * `render` (bool, optional): Set to False to only do a physics simulation without rendering. Note: app UI will be frozen (since its not rendering) in this case. Defaults to True.\n * `step_sim` (bool): True to step simulation (physics and/or rendering)\n\n---\n**Example:**\n\n```python\n>>> world.step()\n```\n",
"snippet":"world.step()\n",
"category":"method"
},
{
"title":"step",
"description":"Steps the physics simulation while rendering or without.\n\n*Warning:*\nCalling this method with the `render` parameter set to True (default value) is not intended to be used\nin the Isaac Sim's Extensions workflow since the Kit application has the control over the rendering steps\n\n**Args:**\n\n * `render` (bool, optional): Set to False to only do a physics simulation without rendering. Note: app UI will be frozen (since its not rendering) in this case. Defaults to True.\n\n**Raises:**\n\n * Exception: if there is no stage currently opened\n\n---\n**Example:**\n\n```python\n>>> simulation_context.step()\n```\n",
"snippet":"world.step()\n",
"category":"method"
},
{
"title":"step_async",
"description":"Call all functions that should be called pre stepping the physics\n\n*Note:*\nThe `pre_step` for each task is called before stepping. This method also update the Bounding Box Cache\ntime for computing bounding box if enabled\n\n**Args:**\n\n * `step_size` (float): step size\n\n---\n**Example:**\n\n```python\n>>> from omni.kit.async_engine import run_coroutine\n>>>\n>>> async def task():\n...     await world.step_async()\n...\n>>> run_coroutine(task())\n```\n",
"snippet":"world.step_async()\n",
"category":"method"
},
{
"title":"stop",
"description":"Stop the physics simulation\n\n---\n**Example:**\n\n```python\n>>> simulation_context.stop()\n```\n",
"snippet":"world.stop()\n",
"category":"method"
},
{
"title":"stop_async",
"description":"Stop the physics simulation\n\n---\n**Example:**\n\n```python\n>>> from omni.kit.async_engine import run_coroutine\n>>>\n>>> async def task():\n...     await simulation_context.stop_async()\n...\n>>> run_coroutine(task())\n```\n",
"snippet":"world.stop_async()\n",
"category":"method"
},
{
"title":"timeline_callback_exists",
"description":"Check if a timeline callback exists\n\n**Args:**\n\n * `callback_name` (str): callback name\n\n**Returns:**\n\n * bool: whether the callback is registered\n\n---\n**Example:**\n\n```python\n>>> # given a registered callback named 'callback_timeline'\n>>> simulation_context.timeline_callback_exists(\"callback_timeline\")\nTrue\n```\n",
"snippet":"value = world.timeline_callback_exists(callback_name=callback_name)\n",
"category":"method"
}
]
},
{
"title":"Tasks",
"snippets":[
{
"title":"BaseTask",
"snippets":[
{
"title":"import ...",
"description":"Import class",
"snippet":"from omni.isaac.core.tasks import BaseTask\n",
"category":"import"
},
{
"title":"BaseTask",
"description":"This class provides a way to set up a task in a scene and modularize adding objects to stage,\ngetting observations needed for the behavioral layer, calculating metrics needed about the task,\ncalling certain things pre-stepping, creating multiple tasks at the same time and much more.\n\nCheckout the required tutorials at\n<https://docs.omniverse.nvidia.com/app_isaacsim/app_isaacsim/overview.html>\n\n**Args:**\n\n * `name` (str): needs to be unique if added to the World.\n * `offset` (Optional\\[np.ndarray\\], optional): offset applied to all assets of the task.\n",
"snippet":"base_task = BaseTask(name=name)\n",
"category":"class"
},
{
"title":"calculate_metrics",
"description":"\\[summary\\]\n\n**Raises:**\n\n * NotImplementedError: \\[description\\]\n",
"snippet":"value = base_task.calculate_metrics()\n",
"category":"method"
},
{
"title":"cleanup",
"description":"Called before calling a reset() on the world to removed temporary objects that were added during\nsimulation for instance.\n",
"snippet":"base_task.cleanup()\n",
"category":"method"
},
{
"title":"device",
"description":"",
"snippet":"device = base_task.device\n",
"category":"property"
},
{
"title":"get_description",
"description":"\\[summary\\]\n\n**Returns:**\n\n * str: \\[description\\]\n",
"snippet":"description = base_task.get_description()\n",
"category":"method"
},
{
"title":"get_observations",
"description":"Returns current observations from the objects needed for the behavioral layer.\n\n**Raises:**\n\n * NotImplementedError: \\[description\\]\n\n**Returns:**\n\n * dict: \\[description\\]\n",
"snippet":"observations = base_task.get_observations()\n",
"category":"method"
},
{
"title":"get_params",
"description":"Gets the parameters of the task.\nThis is defined differently for each task in order to access the task's objects and values.\nNote that this is different from get\\_observations.\nThings like the robot name, block name..etc can be defined here for faster retrieval.\nshould have the form of params\\_representation\\[\"param\\_name\"\\] = {\"value\": param\\_value, \"modifiable\": bool}\nRaises:\nNotImplementedError: \\[description\\]\nReturns:\ndict: defined parameters of the task.\n",
"snippet":"params = base_task.get_params()\n",
"category":"method"
},
{
"title":"get_task_objects",
"description":"\\[summary\\]\n\n**Returns:**\n\n * dict: \\[description\\]\n",
"snippet":"task_objects = base_task.get_task_objects()\n",
"category":"method"
},
{
"title":"is_done",
"description":"Returns True of the task is done.\n\n**Raises:**\n\n * NotImplementedError: \\[description\\]\n",
"snippet":"value = base_task.is_done()\n",
"category":"method"
},
{
"title":"name",
"description":"\\[summary\\]\n\n**Returns:**\n\n * str: \\[description\\]\n",
"snippet":"name = base_task.name\n",
"category":"property"
},
{
"title":"post_reset",
"description":"Calls while doing a .reset() on the world.\n",
"snippet":"base_task.post_reset()\n",
"category":"method"
},
{
"title":"pre_step",
"description":"called before stepping the physics simulation.\n\n**Args:**\n\n * `time_step_index` (int): \\[description\\]\n * `simulation_time` (float): \\[description\\]\n",
"snippet":"base_task.pre_step(time_step_index=time_step_index, simulation_time=simulation_time)\n",
"category":"method"
},
{
"title":"scene",
"description":"Scene of the world\n\n**Returns:**\n\n * Scene: \\[description\\]\n",
"snippet":"scene = base_task.scene\n",
"category":"property"
},
{
"title":"set_params",
"description":"Changes the modifiable parameters of the task\n\n**Raises:**\n\n * NotImplementedError: \\[description\\]\n",
"snippet":"base_task.set_params()\n",
"category":"method"
},
{
"title":"set_up_scene",
"description":"Adding assets to the stage as well as adding the encapsulated objects such as XFormPrim..etc\nto the task\\_objects happens here.\nArgs:\nscene (Scene): \\[description\\]\n",
"snippet":"base_task.set_up_scene(scene=scene)\n",
"category":"method"
}
]
},
{
"title":"FollowTarget",
"snippets":[
{
"title":"import ...",
"description":"Import class",
"snippet":"from omni.isaac.core.tasks import FollowTarget\n",
"category":"import"
},
{
"title":"FollowTarget",
"description":"\\[summary\\]\n\n**Args:**\n\n * `name` (str): \\[description\\]\n * `target_prim_path` (Optional\\[str\\], optional): \\[description\\]. Defaults to None.\n * `target_name` (Optional\\[str\\], optional): \\[description\\]. Defaults to None.\n * `target_position` (Optional\\[np.ndarray\\], optional): \\[description\\]. Defaults to None.\n * `target_orientation` (Optional\\[np.ndarray\\], optional): \\[description\\]. Defaults to None.\n * `offset` (Optional\\[np.ndarray\\], optional): \\[description\\]. Defaults to None.\n",
"snippet":"follow_target = FollowTarget(name=name)\n",
"category":"class"
},
{
"title":"add_obstacle",
"description":"\\[summary\\]\n\n**Args:**\n\n * `position` (np.ndarray, optional): \\[description\\]. Defaults to np.array(\\[0.1, 0.1, 1.0\\]).\n",
"snippet":"follow_target.add_obstacle()\n",
"category":"method"
},
{
"title":"calculate_metrics",
"description":"\\[summary\\]\n",
"snippet":"value = follow_target.calculate_metrics()\n",
"category":"method"
},
{
"title":"calculate_metrics",
"description":"\\[summary\\]\n\n**Raises:**\n\n * NotImplementedError: \\[description\\]\n",
"snippet":"value = follow_target.calculate_metrics()\n",
"category":"method"
},
{
"title":"cleanup",
"description":"\\[summary\\]\n",
"snippet":"follow_target.cleanup()\n",
"category":"method"
},
{
"title":"cleanup",
"description":"Called before calling a reset() on the world to removed temporary objects that were added during\nsimulation for instance.\n",
"snippet":"follow_target.cleanup()\n",
"category":"method"
},
{
"title":"get_description",
"description":"\\[summary\\]\n\n**Returns:**\n\n * str: \\[description\\]\n",
"snippet":"description = follow_target.get_description()\n",
"category":"method"
},
{
"title":"get_observations",
"description":"\\[summary\\]\n\n**Returns:**\n\n * dict: \\[description\\]\n",
"snippet":"observations = follow_target.get_observations()\n",
"category":"method"
},
{
"title":"get_observations",
"description":"Returns current observations from the objects needed for the behavioral layer.\n\n**Raises:**\n\n * NotImplementedError: \\[description\\]\n\n**Returns:**\n\n * dict: \\[description\\]\n",
"snippet":"observations = follow_target.get_observations()\n",
"category":"method"
},
{
"title":"get_obstacle_to_delete",
"description":"\\[summary\\]\n\n**Returns:**\n\n * \\[type\\]: \\[description\\]\n",
"snippet":"follow_target.get_obstacle_to_delete()\n",
"category":"method"
},
{
"title":"get_params",
"description":"\\[summary\\]\n\n**Returns:**\n\n * dict: \\[description\\]\n",
"snippet":"params = follow_target.get_params()\n",
"category":"method"
},
{
"title":"get_params",
"description":"Gets the parameters of the task.\nThis is defined differently for each task in order to access the task's objects and values.\nNote that this is different from get\\_observations.\nThings like the robot name, block name..etc can be defined here for faster retrieval.\nshould have the form of params\\_representation\\[\"param\\_name\"\\] = {\"value\": param\\_value, \"modifiable\": bool}\nRaises:\nNotImplementedError: \\[description\\]\nReturns:\ndict: defined parameters of the task.\n",
"snippet":"params = follow_target.get_params()\n",
"category":"method"
},
{
"title":"get_task_objects",
"description":"\\[summary\\]\n\n**Returns:**\n\n * dict: \\[description\\]\n",
"snippet":"task_objects = follow_target.get_task_objects()\n",
"category":"method"
},
{
"title":"is_done",
"description":"\\[summary\\]\n",
"snippet":"value = follow_target.is_done()\n",
"category":"method"
},
{
"title":"is_done",
"description":"Returns True of the task is done.\n\n**Raises:**\n\n * NotImplementedError: \\[description\\]\n",
"snippet":"value = follow_target.is_done()\n",
"category":"method"
},
{
"title":"obstacles_exist",
"description":"\\[summary\\]\n\n**Returns:**\n\n * bool: \\[description\\]\n",
"snippet":"value = follow_target.obstacles_exist()\n",
"category":"method"
},
{
"title":"post_reset",
"description":"\\[summary\\]\n",
"snippet":"follow_target.post_reset()\n",
"category":"method"
},
{
"title":"post_reset",
"description":"Calls while doing a .reset() on the world.\n",
"snippet":"follow_target.post_reset()\n",
"category":"method"
},
{
"title":"pre_step",
"description":"\\[summary\\]\n\n**Args:**\n\n * `time_step_index` (int): \\[description\\]\n * `simulation_time` (float): \\[description\\]\n",
"snippet":"follow_target.pre_step(time_step_index=time_step_index, simulation_time=simulation_time)\n",
"category":"method"
},
{
"title":"pre_step",
"description":"called before stepping the physics simulation.\n\n**Args:**\n\n * `time_step_index` (int): \\[description\\]\n * `simulation_time` (float): \\[description\\]\n",
"snippet":"follow_target.pre_step(time_step_index=time_step_index, simulation_time=simulation_time)\n",
"category":"method"
},
{
"title":"remove_obstacle",
"description":"\\[summary\\]\n\n**Args:**\n\n * `name` (Optional\\[str\\], optional): \\[description\\]. Defaults to None.\n",
"snippet":"follow_target.remove_obstacle()\n",
"category":"method"
},
{
"title":"set_params",
"description":"\\[summary\\]\n\n**Args:**\n\n * `target_prim_path` (Optional\\[str\\], optional): \\[description\\]. Defaults to None.\n * `target_name` (Optional\\[str\\], optional): \\[description\\]. Defaults to None.\n * `target_position` (Optional\\[np.ndarray\\], optional): \\[description\\]. Defaults to None.\n * `target_orientation` (Optional\\[np.ndarray\\], optional): \\[description\\]. Defaults to None.\n",
"snippet":"follow_target.set_params()\n",
"category":"method"
},
{
"title":"set_params",
"description":"Changes the modifiable parameters of the task\n\n**Raises:**\n\n * NotImplementedError: \\[description\\]\n",
"snippet":"follow_target.set_params()\n",
"category":"method"
},
{
"title":"set_robot",
"description":"\\[summary\\]\n\n**Raises:**\n\n * NotImplementedError: \\[description\\]\n",
"snippet":"follow_target.set_robot()\n",
"category":"method"
},
{
"title":"set_up_scene",
"description":"\\[summary\\]\n\n**Args:**\n\n * `scene` (Scene): \\[description\\]\n",
"snippet":"follow_target.set_up_scene(scene=scene)\n",
"category":"method"
},
{
"title":"set_up_scene",
"description":"Adding assets to the stage as well as adding the encapsulated objects such as XFormPrim..etc\nto the task\\_objects happens here.\nArgs:\nscene (Scene): \\[description\\]\n",
"snippet":"follow_target.set_up_scene(scene=scene)\n",
"category":"method"
},
{
"title":"target_reached",
"description":"\\[summary\\]\n\n**Returns:**\n\n * bool: \\[description\\]\n",
"snippet":"value = follow_target.target_reached()\n",
"category":"method"
}
]
},
{
"title":"PickPlace",
"snippets":[
{
"title":"import ...",
"description":"Import class",
"snippet":"from omni.isaac.core.tasks import PickPlace\n",
"category":"import"
},
{
"title":"PickPlace",
"description":"\\[summary\\]\n\n**Args:**\n\n * `name` (str): \\[description\\]\n * `cube_initial_position` (Optional\\[np.ndarray\\], optional): \\[description\\]. Defaults to None.\n * `cube_initial_orientation` (Optional\\[np.ndarray\\], optional): \\[description\\]. Defaults to None.\n * `target_position` (Optional\\[np.ndarray\\], optional): \\[description\\]. Defaults to None.\n * `cube_size` (Optional\\[np.ndarray\\], optional): \\[description\\]. Defaults to None.\n * `offset` (Optional\\[np.ndarray\\], optional): \\[description\\]. Defaults to None.\n",
"snippet":"pick_place = PickPlace(name=name)\n",
"category":"class"
},
{
"title":"calculate_metrics",
"description":"\\[summary\\]\n",
"snippet":"value = pick_place.calculate_metrics()\n",
"category":"method"
},
{
"title":"calculate_metrics",
"description":"\\[summary\\]\n\n**Raises:**\n\n * NotImplementedError: \\[description\\]\n",
"snippet":"value = pick_place.calculate_metrics()\n",
"category":"method"
},
{
"title":"cleanup",
"description":"Called before calling a reset() on the world to removed temporary objects that were added during\nsimulation for instance.\n",
"snippet":"pick_place.cleanup()\n",
"category":"method"
},
{
"title":"get_description",
"description":"\\[summary\\]\n\n**Returns:**\n\n * str: \\[description\\]\n",
"snippet":"description = pick_place.get_description()\n",
"category":"method"
},
{
"title":"get_observations",
"description":"\\[summary\\]\n\n**Returns:**\n\n * dict: \\[description\\]\n",
"snippet":"observations = pick_place.get_observations()\n",
"category":"method"
},
{
"title":"get_observations",
"description":"Returns current observations from the objects needed for the behavioral layer.\n\n**Raises:**\n\n * NotImplementedError: \\[description\\]\n\n**Returns:**\n\n * dict: \\[description\\]\n",
"snippet":"observations = pick_place.get_observations()\n",
"category":"method"
},
{
"title":"get_params",
"description":"",
"snippet":"params = pick_place.get_params()\n",
"category":"method"
},
{
"title":"get_params",
"description":"Gets the parameters of the task.\nThis is defined differently for each task in order to access the task's objects and values.\nNote that this is different from get\\_observations.\nThings like the robot name, block name..etc can be defined here for faster retrieval.\nshould have the form of params\\_representation\\[\"param\\_name\"\\] = {\"value\": param\\_value, \"modifiable\": bool}\nRaises:\nNotImplementedError: \\[description\\]\nReturns:\ndict: defined parameters of the task.\n",
"snippet":"params = pick_place.get_params()\n",
"category":"method"
},
{
"title":"get_task_objects",
"description":"\\[summary\\]\n\n**Returns:**\n\n * dict: \\[description\\]\n",
"snippet":"task_objects = pick_place.get_task_objects()\n",
"category":"method"
},
{
"title":"is_done",
"description":"\\[summary\\]\n",
"snippet":"value = pick_place.is_done()\n",
"category":"method"
},
{
"title":"is_done",
"description":"Returns True of the task is done.\n\n**Raises:**\n\n * NotImplementedError: \\[description\\]\n",
"snippet":"value = pick_place.is_done()\n",
"category":"method"
},
{
"title":"post_reset",
"description":"",
"snippet":"pick_place.post_reset()\n",
"category":"method"
},
{
"title":"post_reset",
"description":"Calls while doing a .reset() on the world.\n",
"snippet":"pick_place.post_reset()\n",
"category":"method"
},
{
"title":"pre_step",
"description":"\\[summary\\]\n\n**Args:**\n\n * `time_step_index` (int): \\[description\\]\n * `simulation_time` (float): \\[description\\]\n",
"snippet":"pick_place.pre_step(time_step_index=time_step_index, simulation_time=simulation_time)\n",
"category":"method"
},
{
"title":"pre_step",
"description":"called before stepping the physics simulation.\n\n**Args:**\n\n * `time_step_index` (int): \\[description\\]\n * `simulation_time` (float): \\[description\\]\n",
"snippet":"pick_place.pre_step(time_step_index=time_step_index, simulation_time=simulation_time)\n",
"category":"method"
},
{
"title":"set_params",
"description":"",
"snippet":"pick_place.set_params()\n",
"category":"method"
},
{
"title":"set_params",
"description":"Changes the modifiable parameters of the task\n\n**Raises:**\n\n * NotImplementedError: \\[description\\]\n",
"snippet":"pick_place.set_params()\n",
"category":"method"
},
{
"title":"set_robot",
"description":"",
"snippet":"pick_place.set_robot()\n",
"category":"method"
},
{
"title":"set_up_scene",
"description":"\\[summary\\]\n\n**Args:**\n\n * `scene` (Scene): \\[description\\]\n",
"snippet":"pick_place.set_up_scene(scene=scene)\n",
"category":"method"
},
{
"title":"set_up_scene",
"description":"Adding assets to the stage as well as adding the encapsulated objects such as XFormPrim..etc\nto the task\\_objects happens here.\nArgs:\nscene (Scene): \\[description\\]\n",
"snippet":"pick_place.set_up_scene(scene=scene)\n",
"category":"method"
}
]
},
{
"title":"Stacking",
"snippets":[
{
"title":"import ...",
"description":"Import class",
"snippet":"from omni.isaac.core.tasks import Stacking\n",
"category":"import"
},
{
"title":"Stacking",
"description":"\\[summary\\]\n\n**Args:**\n\n * `name` (str): \\[description\\]\n * `cube_initial_positions` (np.ndarray): \\[description\\]\n * `cube_initial_orientations` (Optional\\[np.ndarray\\], optional): \\[description\\]. Defaults to None.\n * `stack_target_position` (Optional\\[np.ndarray\\], optional): \\[description\\]. Defaults to None.\n * `cube_size` (Optional\\[np.ndarray\\], optional): \\[description\\]. Defaults to None.\n * `offset` (Optional\\[np.ndarray\\], optional): \\[description\\]. Defaults to None.\n",
"snippet":"stacking = Stacking(name=name, cube_initial_positions=cube_initial_positions)\n",
"category":"class"
},
{
"title":"calculate_metrics",
"description":"\\[summary\\]\n\n**Raises:**\n\n * NotImplementedError: \\[description\\]\n\n**Returns:**\n\n * dict: \\[description\\]\n",
"snippet":"value = stacking.calculate_metrics()\n",
"category":"method"
},
{
"title":"calculate_metrics",
"description":"\\[summary\\]\n\n**Raises:**\n\n * NotImplementedError: \\[description\\]\n",
"snippet":"value = stacking.calculate_metrics()\n",
"category":"method"
},
{
"title":"cleanup",
"description":"Called before calling a reset() on the world to removed temporary objects that were added during\nsimulation for instance.\n",
"snippet":"stacking.cleanup()\n",
"category":"method"
},
{
"title":"get_cube_names",
"description":"\\[summary\\]\n\n**Returns:**\n\n * List\\[str\\]: \\[description\\]\n",
"snippet":"cube_names = stacking.get_cube_names()\n",
"category":"method"
},
{
"title":"get_description",
"description":"\\[summary\\]\n\n**Returns:**\n\n * str: \\[description\\]\n",
"snippet":"description = stacking.get_description()\n",
"category":"method"
},
{
"title":"get_observations",
"description":"\\[summary\\]\n\n**Returns:**\n\n * dict: \\[description\\]\n",
"snippet":"observations = stacking.get_observations()\n",
"category":"method"
},
{
"title":"get_observations",
"description":"Returns current observations from the objects needed for the behavioral layer.\n\n**Raises:**\n\n * NotImplementedError: \\[description\\]\n\n**Returns:**\n\n * dict: \\[description\\]\n",
"snippet":"observations = stacking.get_observations()\n",
"category":"method"
},
{
"title":"get_params",
"description":"\\[summary\\]\n\n**Returns:**\n\n * dict: \\[description\\]\n",
"snippet":"params = stacking.get_params()\n",
"category":"method"
},
{
"title":"get_params",
"description":"Gets the parameters of the task.\nThis is defined differently for each task in order to access the task's objects and values.\nNote that this is different from get\\_observations.\nThings like the robot name, block name..etc can be defined here for faster retrieval.\nshould have the form of params\\_representation\\[\"param\\_name\"\\] = {\"value\": param\\_value, \"modifiable\": bool}\nRaises:\nNotImplementedError: \\[description\\]\nReturns:\ndict: defined parameters of the task.\n",
"snippet":"params = stacking.get_params()\n",
"category":"method"
},
{
"title":"get_task_objects",
"description":"\\[summary\\]\n\n**Returns:**\n\n * dict: \\[description\\]\n",
"snippet":"task_objects = stacking.get_task_objects()\n",
"category":"method"
},
{
"title":"is_done",
"description":"\\[summary\\]\n\n**Raises:**\n\n * NotImplementedError: \\[description\\]\n\n**Returns:**\n\n * bool: \\[description\\]\n",
"snippet":"value = stacking.is_done()\n",
"category":"method"
},
{
"title":"is_done",
"description":"Returns True of the task is done.\n\n**Raises:**\n\n * NotImplementedError: \\[description\\]\n",
"snippet":"value = stacking.is_done()\n",
"category":"method"
},
{
"title":"post_reset",
"description":"\\[summary\\]\n",
"snippet":"stacking.post_reset()\n",
"category":"method"
},
{
"title":"post_reset",
"description":"Calls while doing a .reset() on the world.\n",
"snippet":"stacking.post_reset()\n",
"category":"method"
},
{
"title":"pre_step",
"description":"\\[summary\\]\n\n**Args:**\n\n * `time_step_index` (int): \\[description\\]\n * `simulation_time` (float): \\[description\\]\n",
"snippet":"stacking.pre_step(time_step_index=time_step_index, simulation_time=simulation_time)\n",
"category":"method"
},
{
"title":"pre_step",
"description":"called before stepping the physics simulation.\n\n**Args:**\n\n * `time_step_index` (int): \\[description\\]\n * `simulation_time` (float): \\[description\\]\n",
"snippet":"stacking.pre_step(time_step_index=time_step_index, simulation_time=simulation_time)\n",
"category":"method"
},
{
"title":"set_params",
"description":"\\[summary\\]\n\n**Args:**\n\n * `cube_name` (Optional\\[str\\], optional): \\[description\\]. Defaults to None.\n * `cube_position` (Optional\\[str\\], optional): \\[description\\]. Defaults to None.\n * `cube_orientation` (Optional\\[str\\], optional): \\[description\\]. Defaults to None.\n * `stack_target_position` (Optional\\[str\\], optional): \\[description\\]. Defaults to None.\n",
"snippet":"stacking.set_params()\n",
"category":"method"
},
{
"title":"set_params",
"description":"Changes the modifiable parameters of the task\n\n**Raises:**\n\n * NotImplementedError: \\[description\\]\n",
"snippet":"stacking.set_params()\n",
"category":"method"
},
{
"title":"set_robot",
"description":"\\[summary\\]\n\n**Raises:**\n\n * NotImplementedError: \\[description\\]\n",
"snippet":"stacking.set_robot()\n",
"category":"method"
},
{
"title":"set_up_scene",
"description":"\\[summary\\]\n\n**Args:**\n\n * `scene` (Scene): \\[description\\]\n",
"snippet":"stacking.set_up_scene(scene=scene)\n",
"category":"method"
},
{
"title":"set_up_scene",
"description":"Adding assets to the stage as well as adding the encapsulated objects such as XFormPrim..etc\nto the task\\_objects happens here.\nArgs:\nscene (Scene): \\[description\\]\n",
"snippet":"stacking.set_up_scene(scene=scene)\n",
"category":"method"
}
]
}
]
}
]