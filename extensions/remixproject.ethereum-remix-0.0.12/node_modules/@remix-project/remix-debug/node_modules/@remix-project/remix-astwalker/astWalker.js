"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const isObject = function (obj) {
    return obj != null && obj.constructor.name === "Object";
};
function isAstNode(node) {
    return (isObject(node) &&
        'id' in node &&
        'nodeType' in node &&
        'src' in node);
}
exports.isAstNode = isAstNode;
/**
 * Crawl the given AST through the function walk(ast, callback)
 */
/**
 * visit all the AST nodes
 *
 * @param {Object} ast  - AST node
 * @return EventEmitter
 * event('node', <Node Type | false>) will be fired for every node of type <Node Type>.
 * event('node', "*") will be fired for all other nodes.
 * in each case, if the event emits false it does not descend into children.
 * If no event for the current type, children are visited.
 */
class AstWalker extends events_1.EventEmitter {
    manageCallback(node, callback // eslint-disable-line @typescript-eslint/ban-types
    ) {
        // FIXME: we shouldn't be doing this callback determination type on each AST node,
        // since the callback function is set once per walk.
        // Better would be to store the right one as a variable and
        // return that.
        if (node) {
            if (node.name in callback) {
                return callback[node.name](node);
            }
            else {
                return callback["*"](node);
            }
        }
        if (node) {
            if (node.nodeType in callback) {
                /* istanbul ignore next */
                return callback[node.nodeType](node);
            }
            else {
                /* istanbul ignore next */
                return callback["*"](node);
            }
        }
    }
    // eslint-disable-next-line @typescript-eslint/ban-types, @typescript-eslint/explicit-module-boundary-types
    walk(ast, callback) {
        if (callback) {
            if (callback instanceof Function) {
                callback = Object({ "*": callback });
            }
            if (!("*" in callback)) {
                callback["*"] = function () {
                    return true;
                };
            }
            if (ast) {
                if (this.manageCallback(ast, callback) &&
                    ast.children &&
                    ast.children.length > 0) {
                    for (const k in ast.children) {
                        const child = ast.children[k];
                        this.walk(child, callback);
                    }
                }
            }
            else if (ast) {
                if (this.manageCallback(ast, callback) &&
                    ast.nodes &&
                    ast.nodes.length > 0) {
                    for (const k in ast.nodes) {
                        const child = ast.nodes[k];
                        this.walk(child, callback);
                    }
                }
            }
        }
        else {
            if (ast) {
                if (ast.children &&
                    ast.children.length > 0) {
                    for (const k in ast.children) {
                        const child = ast.children[k];
                        this.emit("node", child);
                        this.walk(child);
                    }
                }
            }
            if (ast) {
                if (ast.nodes && ast.nodes.length > 0) {
                    for (const k in ast.nodes) {
                        const child = ast.nodes[k];
                        this.emit("node", child);
                        this.walk(child);
                    }
                }
            }
        }
    }
    // eslint-disable-next-line @typescript-eslint/ban-types, @typescript-eslint/explicit-module-boundary-types
    walkFullInternal(ast, callback) {
        if (isAstNode(ast)) {
            // console.log(`XXX id ${ast.id}, nodeType: ${ast.nodeType}, src: ${ast.src}`);
            callback(ast);
            for (const k of Object.keys(ast)) {
                // Possible optimization:
                // if (k in ['id', 'src', 'nodeType']) continue;
                const astItem = ast[k];
                if (Array.isArray(astItem)) {
                    for (const child of astItem) {
                        if (child) {
                            this.walkFullInternal(child, callback);
                        }
                    }
                }
                else {
                    this.walkFullInternal(astItem, callback);
                }
            }
        }
    }
    // Normalizes parameter callback and calls walkFullInternal
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    walkFull(ast, callback) {
        if (!isAstNode(ast))
            throw new TypeError("first argument should be an ast");
        return this.walkFullInternal(ast, callback);
    }
    // eslint-disable-next-line @typescript-eslint/ban-types, @typescript-eslint/explicit-module-boundary-types
    walkAstList(sourcesList, cb) {
        if (cb) {
            if (sourcesList.ast) {
                this.walk(sourcesList.ast, cb);
            }
            else {
                this.walk(sourcesList.legacyAST, cb);
            }
        }
        else {
            if (sourcesList.ast) {
                this.walk(sourcesList.ast);
            }
            else {
                this.walk(sourcesList.legacyAST);
            }
        }
    }
}
exports.AstWalker = AstWalker;
//# sourceMappingURL=astWalker.js.map