"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EditorPlugin = void 0;
const tslib_1 = require("tslib");
const plugin_api_1 = require("@remixproject/plugin-api");
const vscode_1 = require("vscode");
const command_1 = require("./command");
const path_1 = require("../util/path");
function getEditor(filePath) {
    const editors = vscode_1.window.visibleTextEditors;
    return filePath ? editors.find(editor => editor.document.uri.path === vscode_1.Uri.parse(filePath).path) : vscode_1.window.activeTextEditor;
}
function extractColor(themeColor) {
    const [content] = themeColor.match(/(?<=\().+?(?=\))/g);
    const value = content.substring(2);
    return value.split('-').join('.').replace('vscode.', '');
}
class EditorPlugin extends command_1.CommandPlugin {
    constructor(options) {
        super(plugin_api_1.editorProfile);
        super.setOptions(options);
        this.decorations = [];
    }
    setOptions(options) {
        super.setOptions(options);
    }
    onActivation() {
        this.diagnosticCollection = vscode_1.languages.createDiagnosticCollection(this.options.language);
    }
    onDeactivation() {
        this.decoration.dispose();
    }
    highlight(position, filePath, themeColor) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            filePath = path_1.absolutePath(filePath);
            const editors = vscode_1.window.visibleTextEditors;
            // Parse `filePath` to ensure if a valid file path was supplied
            const editor = editors.find(editor => editor.document.uri.path === vscode_1.Uri.parse(filePath).path);
            if (editor) {
                const start = new vscode_1.Position(position.start.line, position.start.column);
                const end = new vscode_1.Position(position.end.line, position.end.column);
                const newDecoration = { range: new vscode_1.Range(start, end) };
                this.decoration = vscode_1.window.createTextEditorDecorationType({
                    backgroundColor: new vscode_1.ThemeColor('editor.wordHighlightStrongBackground'),
                    isWholeLine: true,
                });
                this.decorations.push(this.decoration);
                editor.setDecorations(this.decoration, [newDecoration]);
            }
            else {
                throw new Error(`Could not find file ${filePath}`);
            }
        });
    }
    discardDecorations() {
        var _a;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return (_a = this.decorations) === null || _a === void 0 ? void 0 : _a.forEach(decoration => decoration.dispose());
        });
    }
    discardHighlight() {
        var _a;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return (_a = this.decorations) === null || _a === void 0 ? void 0 : _a.forEach(decoration => decoration.dispose());
        });
    }
    /**
     * Alisas of  discardHighlight
     * Required to match the standard interface of editor
     */
    discardHighlightAt() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this.decoration.dispose();
        });
    }
    addAnnotation(annotation, filePath) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // This function should append to existing map
            // Ref: https://code.visualstudio.com/api/language-extensions/programmatic-language-features#provide-diagnostics
            // const fileUri = window.activeTextEditor ? window.activeTextEditor.document.uri : undefined; // TODO: we might want to supply path to addAnnotation function
            filePath = path_1.absolutePath(filePath);
            const editor = getEditor(filePath);
            const canonicalFile = editor.document.uri.fsPath;
            const diagnostics = [];
            const range = new vscode_1.Range(annotation.row - 1, annotation.column, annotation.row - 1, annotation.column);
            const diagnosticSeverity = {
                'error': vscode_1.DiagnosticSeverity.Error,
                'warning': vscode_1.DiagnosticSeverity.Warning,
                'information': vscode_1.DiagnosticSeverity.Information
            };
            const severity = diagnosticSeverity[annotation.type];
            const diagnostic = new vscode_1.Diagnostic(range, annotation.text, severity);
            diagnostics.push(diagnostic);
            this.diagnosticCollection.set(vscode_1.Uri.file(canonicalFile), diagnostics);
        });
    }
    clearAnnotations() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this.diagnosticCollection.clear();
        });
    }
}
exports.EditorPlugin = EditorPlugin;
//# sourceMappingURL=editor.js.map