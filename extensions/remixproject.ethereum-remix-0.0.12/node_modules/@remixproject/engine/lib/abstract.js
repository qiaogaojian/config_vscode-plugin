"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Plugin = void 0;
const tslib_1 = require("tslib");
const plugin_utils_1 = require("@remixproject/plugin-utils");
class Plugin {
    constructor(profile) {
        this.profile = profile;
        this.activateService = {};
        this.requestQueue = [];
        this.options = {};
    }
    get name() {
        return this.profile.name;
    }
    get methods() {
        return this.profile.methods;
    }
    set methods(methods) {
        this.profile.methods = methods;
    }
    activate() {
        if (this.onActivation)
            this.onActivation();
    }
    deactivate() {
        if (this.onDeactivation)
            this.onDeactivation();
    }
    setOptions(options = {}) {
        this.options = Object.assign(Object.assign({}, this.options), options);
    }
    /** Call a method from this plugin */
    callPluginMethod(key, args) {
        var _a;
        const path = (_a = this.currentRequest) === null || _a === void 0 ? void 0 : _a.path;
        const method = plugin_utils_1.getMethodPath(key, path);
        if (!(method in this)) {
            throw new Error(`Method ${method} is not implemented by ${this.profile.name}`);
        }
        return this[method](...args);
    }
    /** Add a request to the list of current requests */
    addRequest(request, method, args) {
        return new Promise((resolve, reject) => {
            // Add a new request to the queue
            this.requestQueue.push(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
                this.currentRequest = request;
                let timedout = false;
                const letcontinue = () => {
                    if (timedout) {
                        const { from } = this.currentRequest;
                        const params = args.map(arg => JSON.stringify(arg)).join(', ');
                        const error = `[TIMED OUT]: Call to method "${method}" from "${from}" to plugin "${this.profile.name}" has timed out with arguments ${params}."`;
                        reject(error);
                    }
                    // Remove current request and call next
                    delete this.currentRequest;
                    this.requestQueue.shift();
                    if (this.requestQueue.length !== 0)
                        this.requestQueue[0]();
                };
                const ref = setTimeout(() => {
                    timedout = true;
                    letcontinue();
                }, this.options.queueTimeout || 10000);
                try {
                    const result = yield this.callPluginMethod(method, args);
                    delete this.currentRequest;
                    if (timedout)
                        return;
                    resolve(result);
                }
                catch (err) {
                    delete this.currentRequest;
                    reject(err);
                }
                clearTimeout(ref);
                letcontinue();
            }));
            // If there is only one request waiting, call it
            if (this.requestQueue.length === 1) {
                this.requestQueue[0]();
            }
        });
    }
    /**
     * Ask the plugin manager if current request can call a specific method
     * @param method The method to call
     * @param message An optional message to show to the user
     */
    askUserPermission(method, message) {
        // Internal call
        if (!this.currentRequest) {
            return Promise.resolve(true);
        }
        // External call
        if (this.methods.includes(method)) {
            const from = this.currentRequest.from;
            const to = this.name;
            return this.call('manager', 'canCall', from, to, method, message);
        }
        else {
            return Promise.resolve(false);
        }
    }
    /**
     * Called by the engine when a plugin try to activate it
     * @param from the profile of the plugin activating this plugin
     * @param method method used to activate this plugin if any
     */
    canActivate(from, method) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return true;
        });
    }
    /**
     * Called by the engine when a plugin try to deactivate it
     * @param from the profile of the plugin deactivating this plugin
     */
    canDeactivate(from) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return true;
        });
    }
    /////////////
    // SERVICE //
    /////////////
    /**
     * Create a service under the client node
     * @param name The name of the service
     * @param service The service
     */
    createService(name, service) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (this.methods && this.methods.includes(name)) {
                throw new Error('A service cannot have the same name as an exposed method');
            }
            const _service = plugin_utils_1.createService(name, service);
            yield plugin_utils_1.activateService(this, _service);
            return _service;
        });
    }
    /**
     * Prepare a service to be lazy loaded
     * @param name The name of the subservice inside this service
     * @param factory A function to create the service on demand
     */
    prepareService(name, factory) {
        return this.activateService[name] = () => tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (this.methods && this.methods.includes(name)) {
                throw new Error('A service cannot have the same name as an exposed method');
            }
            const service = yield factory();
            const _service = plugin_utils_1.createService(name, service);
            yield plugin_utils_1.activateService(this, _service);
            delete this.activateService[name];
            return _service;
        });
    }
    /** Listen on an event from another plugin */
    on(name, key, cb) {
        throw new Error(`Cannot use method "on" from plugin "${this.name}". It is not registered in the engine yet.`);
    }
    /** Listen once an event from another plugin then remove event listener */
    once(name, key, cb) {
        throw new Error(`Cannot use method "once" from plugin "${this.name}". It is not registered in the engine yet.`);
    }
    /** Stop listening on an event from another plugin */
    off(name, key) {
        throw new Error(`Cannot use method "off" from plugin "${this.name}". It is not registered in the engine yet.`);
    }
    /** Call a method of another plugin */
    call(name, key, ...payload) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            throw new Error(`Cannot use method "call" from plugin "${this.name}". It is not registered in the engine yet.`);
        });
    }
    /** Emit an event */
    emit(key, ...payload) {
        throw new Error(`Cannot use method "emit" from plugin "${this.name}". It is not registered in the engine yet.`);
    }
}
exports.Plugin = Plugin;
//# sourceMappingURL=abstract.js.map