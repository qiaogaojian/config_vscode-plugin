"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PluginConnector = exports.transformUrl = exports.defaultGateways = void 0;
const tslib_1 = require("tslib");
const abstract_1 = require("./abstract");
/** List of available gateways for decentralised storage */
exports.defaultGateways = {
    'ipfs://': (url, name) => `https://${name}.dyn.plugin.remixproject.org/ipfs/${url.replace('ipfs://', '')}`,
    'swarm://': (url, name) => `https://swarm-gateways.net/bzz-raw://${url.replace('swarm://', '')}`
};
/** Transform the URL to use a gateway if decentralised storage is specified */
function transformUrl({ url, name }) {
    const network = Object.keys(exports.defaultGateways).find(key => url.startsWith(key));
    return network ? exports.defaultGateways[network](url, name) : url;
}
exports.transformUrl = transformUrl;
class PluginConnector extends abstract_1.Plugin {
    constructor(profile) {
        super(profile);
        this.id = 0;
        this.pendingRequest = {};
    }
    activate() {
        const _super = Object.create(null, {
            activate: { get: () => super.activate }
        });
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const url = this.options.transformUrl
                ? this.options.transformUrl(this.profile)
                : transformUrl(this.profile);
            yield this.connect(url);
            return _super.activate.call(this);
        });
    }
    deactivate() {
        const _super = Object.create(null, {
            deactivate: { get: () => super.deactivate }
        });
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.loaded = false;
            yield this.disconnect();
            return _super.deactivate.call(this);
        });
    }
    /** Set options for an external plugin */
    setOptions(options = {}) {
        super.setOptions(options);
    }
    /** Call a method from this plugin */
    callPluginMethod(key, payload = []) {
        const action = 'request';
        const id = this.id++;
        const requestInfo = this.currentRequest;
        const name = this.name;
        const promise = new Promise((res, rej) => {
            this.pendingRequest[id] = (result, error) => error ? rej(error) : res(result);
        });
        this.send({ id, action, key, payload, requestInfo, name });
        return promise;
    }
    /** Perform handshake with the client if not loaded yet */
    handshake() {
        var _a, _b;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.loaded) {
                this.loaded = true;
                let methods;
                try {
                    methods = yield this.callPluginMethod('handshake', [this.profile.name, (_a = this.options) === null || _a === void 0 ? void 0 : _a.engine]);
                }
                catch (err) {
                    this.loaded = false;
                    throw err;
                }
                if (methods) {
                    this.profile.methods = methods;
                    this.call('manager', 'updateProfile', this.profile);
                }
            }
            else {
                // If there is a broken connection we want send back the handshake to the plugin client
                return this.callPluginMethod('handshake', [this.profile.name, (_b = this.options) === null || _b === void 0 ? void 0 : _b.engine]);
            }
        });
    }
    /**
     * React when a message comes from client
     * @param message The message sent by the client
     */
    getMessage(message) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Check for handshake request from the client
            if (message.action === 'request' && message.key === 'handshake') {
                return this.handshake();
            }
            switch (message.action) {
                // Start listening on an event
                case 'on':
                case 'listen': {
                    const { name, key } = message;
                    const action = 'notification';
                    this.on(name, key, (...payload) => this.send({ action, name, key, payload }));
                    break;
                }
                case 'off': {
                    const { name, key } = message;
                    this.off(name, key);
                    break;
                }
                case 'once': {
                    const { name, key } = message;
                    const action = 'notification';
                    this.once(name, key, (...payload) => this.send({ action, name, key, payload }));
                    break;
                }
                // Emit an event
                case 'emit':
                case 'notification': {
                    if (!message.payload)
                        break;
                    this.emit(message.key, ...message.payload);
                    break;
                }
                // Call a method
                case 'call':
                case 'request': {
                    const action = 'response';
                    try {
                        const payload = yield this.call(message.name, message.key, ...message.payload);
                        const error = undefined;
                        this.send(Object.assign(Object.assign({}, message), { action, payload, error }));
                    }
                    catch (err) {
                        const payload = undefined;
                        const error = err.message || err;
                        this.send(Object.assign(Object.assign({}, message), { action, payload, error }));
                    }
                    break;
                }
                // Return result from exposed method
                case 'response': {
                    const { id, payload, error } = message;
                    this.pendingRequest[id](payload, error);
                    delete this.pendingRequest[id];
                    break;
                }
                default: {
                    throw new Error('Message should be a notification, request or response');
                }
            }
        });
    }
}
exports.PluginConnector = PluginConnector;
//# sourceMappingURL=connector.js.map