"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LibraryPlugin = exports.isViewLibrary = void 0;
const tslib_1 = require("tslib");
const abstract_1 = require("./abstract");
function isViewLibrary(profile) {
    return !!profile.location;
}
exports.isViewLibrary = isViewLibrary;
class LibraryPlugin extends abstract_1.Plugin {
    constructor(library, profile) {
        super(profile);
        this.library = library;
        this.profile = profile;
        profile.methods.forEach(method => {
            if (!library[method]) {
                throw new Error(`Method ${method} is exposed by LibraryPlugin ${profile.name}. But library doesn't expose this method`);
            }
        });
        this.isView = isViewLibrary(profile);
        if (this.isView && !this['render']) {
            throw new Error(`Profile ${profile.name} define the location ${profile.location}, but method "render" is not implemented`);
        }
    }
    activate() {
        const _super = Object.create(null, {
            activate: { get: () => super.activate }
        });
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (this.isView) {
                yield this.call(this.profile.location, 'addView', this.profile, this['render']());
            }
            // Forward event to the library
            if (this.profile.notifications) {
                if (!this.library.events || !this.library.events.emit) {
                    throw new Error(`"events" object from Library of plugin ${this.name} should implement "emit"`);
                }
                Object.keys(this.profile.notifications).forEach(name => {
                    this.profile.notifications[name].forEach(key => {
                        this.on(name, key, (payload) => this.library.events.emit(`[${name}] ${key}`, ...payload));
                    });
                });
            }
            // Start listening on events from the library
            if (this.profile.events) {
                if (!this.library.events || !this.library.events.emit) {
                    throw new Error(`"events" object from Library of plugin ${this.name} should implement "emit"`);
                }
                this.profile.events.forEach(event => {
                    this.library.events.on(event, (...payload) => this.emit(event, ...payload));
                });
            }
            // Start listening before running onActivation
            _super.activate.call(this);
        });
    }
    deactivate() {
        var _a;
        if (this.isView) {
            this.call(this.profile.location, 'removeView', this.profile);
        }
        // Stop listening on events
        if (this.profile.notifications) {
            Object.keys(this.profile.notifications).forEach(name => {
                this.profile.notifications[name].forEach(key => this.off(name, key));
            });
        }
        // Stop listening on events from the library
        (_a = this.profile.events) === null || _a === void 0 ? void 0 : _a.forEach(e => { var _a; return (_a = this.library.events) === null || _a === void 0 ? void 0 : _a.removeAllListeners(e); });
        super.deactivate();
    }
    /** Call a method from this plugin */
    callPluginMethod(key, payload) {
        if (!this.library[key]) {
            throw new Error(`LibraryPlugin ${this.name} doesn't expose method ${key}`);
        }
        return this.library[key](...payload);
    }
}
exports.LibraryPlugin = LibraryPlugin;
//# sourceMappingURL=library.js.map