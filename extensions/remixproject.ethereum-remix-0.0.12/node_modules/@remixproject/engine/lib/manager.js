"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PluginManager = void 0;
const tslib_1 = require("tslib");
const plugin_api_1 = require("@remixproject/plugin-api");
const abstract_1 = require("./abstract");
/**
 * Wait for all promises to settle
 * catch if one of them fail
 */
function catchAllPromises(promises) {
    return new Promise((res, rej) => {
        const resolved = [];
        const rejected = [];
        let ended = 0;
        const settle = (value, err) => {
            if (err)
                rejected.push(err);
            if (value)
                resolved.push(value);
            if (++ended === promises.length) {
                rejected.length ? rej(resolved) : res(rejected);
            }
        };
        for (const promise of promises) {
            promise
                .then(value => settle(value, null))
                .catch(err => settle(null, err));
        }
    });
}
class PluginManager extends abstract_1.Plugin {
    constructor(profile = plugin_api_1.pluginManagerProfile) {
        super(profile);
        this.profiles = {};
        this.actives = [];
    }
    /** Return the name of the caller. If no request provided, this mean that the method has been called from the IDE so we use "manager" */
    get requestFrom() {
        var _a;
        return ((_a = this.currentRequest) === null || _a === void 0 ? void 0 : _a.from) || 'manager';
    }
    /** Run engine activation. Implemented by Engine */
    engineActivatePlugin(name) {
        const error = `You cannot activate plugin "${name}", manager plugin is not register yet. `;
        const solution = 'Run "engine.register(manager)" first';
        throw new Error(error + solution);
    }
    /** Run engine deactivation. Implemented by Engine */
    engineDeactivatePlugin(name) {
        const error = `You cannot deactivate plugin "${name}", manager plugin is not register yet. `;
        const solution = 'Run "engine.register(manager)" first';
        throw new Error(error + solution);
    }
    /**
     * Get the profile if it's registered.
     * @param name The name of the plugin
     * @note This method can be overrided
     */
    getProfile(name) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this.profiles[name];
        });
    }
    /** Get all the profiles of the manager */
    getProfiles() {
        return Object.values(this.profiles);
    }
    /** Get all active profiles of the manager */
    getActiveProfiles() {
        return this.actives.map(name => this.profiles[name]);
    }
    /**
     * Update the profile of the plugin
     * @param profile The Updated version of the plugin
     * @note Only the caller plugin should be able to update its profile
     */
    updateProfile(to) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!to)
                return;
            if (!this.profiles[to.name]) {
                throw new Error(`Plugin ${to.name} is not register, you cannot update it's profile.`);
            }
            const from = yield this.getProfile(this.requestFrom);
            yield this.canUpdateProfile(from, to);
            this.profiles[to.name] = Object.assign(Object.assign({}, this.profiles[to.name]), to);
            this.emit('profileUpdated', this.profiles[to.name]);
        });
    }
    /**
     * Add a profile to the list of profile
     * @param profile The profile to add
     * @note This method should only be used by the engine
     */
    addProfile(profiles) {
        const add = (profile) => {
            if (this.profiles[profile.name]) {
                throw new Error(`Plugin ${profile.name} already exist`);
            }
            this.profiles[profile.name] = profile;
            // emit only if manager is already activated
            if (this.actives.includes('manager')) {
                this.emit('profileAdded', profile);
            }
            if (this.onProfileAdded) {
                this.onProfileAdded(profile);
            }
        };
        return Array.isArray(profiles) ? profiles.map(add) : add(profiles);
    }
    /**
     * Verify if a plugin is currently active
     * @param name Name of the plugin
     */
    isActive(name) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this.actives.includes(name);
        });
    }
    /**
     * Check if caller can activate plugin and activate it if authorized
     * @param name The name of the plugin to activate
     */
    activatePlugin(names) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.actives.includes('manager')) {
                yield this.toggleActive('manager');
            }
            const activate = (name) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                const isActive = yield this.isActive(name);
                if (isActive)
                    return;
                const [to, from] = yield Promise.all([
                    this.getProfile(name),
                    this.getProfile(this.requestFrom)
                ]);
                const canActivate = yield this.canActivatePlugin(from, to);
                if (canActivate) {
                    yield this.toggleActive(name);
                }
                else {
                    throw new Error(`Plugin ${this.requestFrom} has no right to activate plugin ${name}`);
                }
            });
            return Array.isArray(names) ? catchAllPromises(names.map(activate)) : activate(names);
        });
    }
    /**
     * Check if caller can deactivate plugin and deactivate it if authorized
     * @param name The name of the plugin to activate
     */
    deactivatePlugin(names) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const deactivate = (name) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                const isActive = yield this.isActive(name);
                if (!isActive)
                    return;
                const [to, from] = yield Promise.all([
                    this.getProfile(name),
                    this.getProfile(this.requestFrom)
                ]);
                // Manager should have all right else plugin could totally block deactivation
                if (from.name === 'manager') {
                    return this.toggleActive(name);
                }
                // Check manager rules
                const managerCanDeactivate = yield this.canDeactivatePlugin(from, to);
                if (!managerCanDeactivate) {
                    throw new Error(`Plugin ${this.requestFrom} has no right to deactivate plugin ${name}`);
                }
                // Ask plugin, if it wasn't the one which called on the first place
                const pluginCanDeactivate = from.name !== to.name ? yield this.call(to.name, 'canDeactivate', from) : true;
                if (!pluginCanDeactivate) {
                    throw new Error(`Plugin ${this.requestFrom} has no right to deactivate plugin ${name}`);
                }
                return this.toggleActive(name);
            });
            return Array.isArray(names) ? catchAllPromises(names.map(deactivate)) : deactivate(names);
        });
    }
    /**
     * Activate or deactivate by bypassing permission
     * @param name The name of the plugin to activate
     * @note This method should ONLY be used by the IDE
     */
    toggleActive(names) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const toggle = (name) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                const [isActive, profile] = yield Promise.all([
                    this.isActive(name),
                    this.getProfile(name)
                ]);
                if (isActive) {
                    yield this.engineDeactivatePlugin(name);
                    this.actives = this.actives.filter(pluginName => pluginName !== name);
                    this.emit('pluginDeactivated', profile);
                    if (this.onPluginDeactivated) {
                        this.onPluginDeactivated(profile);
                    }
                }
                else {
                    yield this.engineActivatePlugin(name);
                    this.actives.push(name);
                    this.emit('pluginActivated', profile);
                    if (this.onPluginActivated) {
                        this.onPluginActivated(profile);
                    }
                }
            });
            return Array.isArray(names) ? Promise.all(names.map(toggle)) : toggle(names);
        });
    }
    /**
     * Check if a plugin can activate another
     * @param from Profile of the caller plugin
     * @param to Profile of the target plugin
     * @note This method should be overrided
     */
    canActivatePlugin(from, to) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return true;
        });
    }
    /**
     * Check if a plugin can deactivate another
     * @param from Profile of the caller plugin
     * @param to Profile of the target plugin
     * @note This method should be overrided
     */
    canDeactivatePlugin(from, to) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (from.name === 'manager' || from.name === to.name) {
                return true;
            }
            return false;
        });
    }
    /**
     * Check if a plugin can call a method of another
     * @param from Profile of the caller plugin
     * @param to Profile of the target plugin
     * @param method Method targetted by the caller
     * @param message Method provided by the targetted method plugin
     */
    canCall(from, to, method, message) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return true;
        });
    }
    /**
     * Check if a plugin can update profile of another one
     * @param from Profile of the caller plugin
     * @param to Updates on the profile of the target plugin
     * @note This method can be overrided
     */
    canUpdateProfile(from, to) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (to.name && from.name !== to.name) {
                throw new Error('A plugin cannot change its name.');
            }
            if (to['url'] && to['url'] !== this.profiles[to.name]['url']) {
                throw new Error('Url from Profile cannot be updated.');
            }
            return true;
        });
    }
}
exports.PluginManager = PluginManager;
//# sourceMappingURL=manager.js.map