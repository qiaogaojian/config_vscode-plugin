"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
};
var _inferenceSession;
Object.defineProperty(exports, "__esModule", { value: true });
exports.onnxruntimeBackend = void 0;
const binding_1 = require("./binding");
class OnnxruntimeSessionHandler {
    constructor(pathOrBuffer, options) {
        _inferenceSession.set(this, void 0);
        __classPrivateFieldSet(this, _inferenceSession, new binding_1.binding.InferenceSession());
        if (typeof pathOrBuffer === 'string') {
            __classPrivateFieldGet(this, _inferenceSession).loadModel(pathOrBuffer, options);
        }
        else {
            __classPrivateFieldGet(this, _inferenceSession).loadModel(pathOrBuffer.buffer, pathOrBuffer.byteOffset, pathOrBuffer.byteLength, options);
        }
        this.inputNames = __classPrivateFieldGet(this, _inferenceSession).inputNames;
        this.outputNames = __classPrivateFieldGet(this, _inferenceSession).outputNames;
    }
    async dispose() {
        return Promise.resolve();
    }
    startProfiling() {
        // TODO: implement profiling
    }
    endProfiling() {
        // TODO: implement profiling
    }
    async run(feeds, fetches, options) {
        return new Promise((resolve, reject) => {
            process.nextTick(() => {
                try {
                    resolve(__classPrivateFieldGet(this, _inferenceSession).run(feeds, fetches, options));
                }
                catch (e) {
                    // reject if any error is thrown
                    reject(e);
                }
            });
        });
    }
}
_inferenceSession = new WeakMap();
class OnnxruntimeBackend {
    async init() {
        return Promise.resolve();
    }
    async createSessionHandler(pathOrBuffer, options) {
        return new Promise((resolve, reject) => {
            process.nextTick(() => {
                try {
                    resolve(new OnnxruntimeSessionHandler(pathOrBuffer, options || {}));
                }
                catch (e) {
                    // reject if any error is thrown
                    reject(e);
                }
            });
        });
    }
}
exports.onnxruntimeBackend = new OnnxruntimeBackend();
//# sourceMappingURL=backend.js.map